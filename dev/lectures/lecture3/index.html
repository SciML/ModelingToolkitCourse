<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solvers for Non-Stiff Ordinary Differential Equations · ModelingToolkit Course</title><meta name="title" content="Solvers for Non-Stiff Ordinary Differential Equations · ModelingToolkit Course"/><meta property="og:title" content="Solvers for Non-Stiff Ordinary Differential Equations · ModelingToolkit Course"/><meta property="twitter:title" content="Solvers for Non-Stiff Ordinary Differential Equations · ModelingToolkit Course"/><meta name="description" content="Documentation for ModelingToolkit Course."/><meta property="og:description" content="Documentation for ModelingToolkit Course."/><meta property="twitter:description" content="Documentation for ModelingToolkit Course."/><meta property="og:url" content="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture3/"/><meta property="twitter:url" content="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture3/"/><link rel="canonical" href="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture3/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelingToolkit Course</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../syllabus/">Syllabus</a></li><li><a class="tocitem" href="../lecture1/">Introduction to acausal modeling for physical systems with ModelingToolkit.jl</a></li><li><a class="tocitem" href="../lecture2/">Developing high-fidelity models of hydraulic systems</a></li><li class="is-active"><a class="tocitem" href>Solvers for Non-Stiff Ordinary Differential Equations</a><ul class="internal"><li><a class="tocitem" href="#Euler&#39;s-Method-for-ODEs"><span>Euler&#39;s Method for ODEs</span></a></li><li><a class="tocitem" href="#Going-Beyond-Euler&#39;s-Method"><span>Going Beyond Euler&#39;s Method</span></a></li><li><a class="tocitem" href="#The-Fundamental-Tension-in-ODE-Solvers"><span>The Fundamental Tension in ODE Solvers</span></a></li><li><a class="tocitem" href="#Choosing-the-Optimal-h:-Adaptivity"><span>Choosing the Optimal h: Adaptivity</span></a></li><li><a class="tocitem" href="#Dense-Output-And-Saving-Approximations"><span>Dense Output And Saving Approximations</span></a></li><li><a class="tocitem" href="#Diving-into-the-Simplest-Tsit5"><span>Diving into the Simplest Tsit5</span></a></li><li><a class="tocitem" href="#Conclusion"><span>Conclusion</span></a></li></ul></li><li><a class="tocitem" href="../lecture4/">Numerical Methods for Stiff ODEs and Differential-Algebraic Equations</a></li><li><a class="tocitem" href="../lecture6/">Debugging difficult stiff ODE/DAE models</a></li><li><a class="tocitem" href="../lecture7/">Numerical and Structural Characterizations for DAEs</a></li><li><a class="tocitem" href="../lecture8/">Dummy Derivatives and Reordering of Equations</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Solvers for Non-Stiff Ordinary Differential Equations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solvers for Non-Stiff Ordinary Differential Equations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkitCourse" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkitCourse/blob/main/docs/src/lectures/lecture3.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Solvers-for-Non-Stiff-Ordinary-Differential-Equations"><a class="docs-heading-anchor" href="#Solvers-for-Non-Stiff-Ordinary-Differential-Equations">Solvers for Non-Stiff Ordinary Differential Equations</a><a id="Solvers-for-Non-Stiff-Ordinary-Differential-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers-for-Non-Stiff-Ordinary-Differential-Equations" title="Permalink"></a></h1><p>In this lecture we will set the basis for solving ordinary differential equations (ODE). In order to build up the topic step-by-step, we will walk through the complete details of a non-stiff ODE solver, using this as a basis to then describe the more advanced techniques added to a stiff ODE solver and thus a solver for differential-algebraic equations (DAEs). This discussion will also demonstrate the close mathematical relationship between stiff ODEs and DAEs, the similarities but also the differences.</p><h2 id="Euler&#39;s-Method-for-ODEs"><a class="docs-heading-anchor" href="#Euler&#39;s-Method-for-ODEs">Euler&#39;s Method for ODEs</a><a id="Euler&#39;s-Method-for-ODEs-1"></a><a class="docs-heading-anchor-permalink" href="#Euler&#39;s-Method-for-ODEs" title="Permalink"></a></h2><p>As a starting point, let&#39;s do a full analysis of solving ODEs with Euler&#39;s method. Given an ODE of the form:</p><p class="math-container">\[u&#39; = f(u,p,t)\]</p><p>where <span>$u(t_0) = u_0$</span> is known, to solve this equation on a time span from <span>$t \in [t_0, t_f]$</span> is known as the Initial Value Problem (IVP). The most basic method for handling this type of equation is known as Euler&#39;s method, which is given by the linear approximation of the derivative. Let <span>$u_n$</span> be the numerical approximation to <span>$u(t_0 + nh)$</span> at time <span>$t_n = t_0 + nh$</span> where <span>$h$</span> is the time discretization size, then can approximate via a Taylor Series expansion:</p><p class="math-container">\[u(t+(n+1)h) = u(t+nh) + h u&#39;(t+nh) + \frac{1}{2}h^2 u&#39;&#39;(t) + \mathcal{O}(h^3)\]</p><p>which motivates the approximation by dropping the higher order terms:</p><p class="math-container">\[u_{n+1} = u_n + h f(u_n,p,t_n)\]</p><p>which is Euler&#39;s method.</p><h3 id="Linear-Stability-of-Euler&#39;s-Method"><a class="docs-heading-anchor" href="#Linear-Stability-of-Euler&#39;s-Method">Linear Stability of Euler&#39;s Method</a><a id="Linear-Stability-of-Euler&#39;s-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Stability-of-Euler&#39;s-Method" title="Permalink"></a></h3><p>The linear stability of a numerical method for ODEs is the maximum <span>$h$</span> such that the solution of <span>$u&#39; = \lambda u$</span> converges <span>$t \rightarrow 0$</span>. For the true equation, <span>$u&#39; = \lambda u$</span> implies that <span>$u(t) = u_0 exp(\lambda t)$</span> and thus the solution converges to 0 iff <span>$\lambda &lt; 0$</span>.</p><p>Now let&#39;s see if Euler&#39;s method has similar behavior. To calculate this, plug in the test equation into Euler&#39;s method:</p><p class="math-container">\[u_{n+1} = u_n + h f(u_n, p, t_n)\]</p><p class="math-container">\[u_{n+1} = u_n + h \lambda u_n\]</p><p class="math-container">\[u_{n+1} = (1+h\lambda) u_n\]</p><p>If we let <span>$z = h \lambda$</span>, then we have the difference equation:</p><p class="math-container">\[u_{n+1} = (1+z) u_n\]</p><p class="math-container">\[u_{n+1} = (1+z)^n u_0\]</p><p>Therefore this equation converges to zero if and only if <span>$\Vert 1+z \Vert &lt; 1$</span>. In the complex plane, this corresponds to the unit circle centered around 1. Importantly, for any equation with <span>$\lambda &lt; 0$</span> such that <span>$\Vert 1 + h \lambda \Vert &gt; 1$</span>, we have that the numerical diverges to infinity while the true solution converges to zero!</p><h3 id="Measures-of-Error-in-Euler&#39;s-Method:-Local-Truncation-Error"><a class="docs-heading-anchor" href="#Measures-of-Error-in-Euler&#39;s-Method:-Local-Truncation-Error">Measures of Error in Euler&#39;s Method: Local Truncation Error</a><a id="Measures-of-Error-in-Euler&#39;s-Method:-Local-Truncation-Error-1"></a><a class="docs-heading-anchor-permalink" href="#Measures-of-Error-in-Euler&#39;s-Method:-Local-Truncation-Error" title="Permalink"></a></h3><p>The local truncation error, i.e. the largest error term in each given step, is one of the most important aspects of a numerical ODE solver. To calculate this, assume that <span>$u_n$</span> is exact. Then the LTE is the difference between the true solution <span>$u(t+(n+1)h)$</span> and <span>$u_{n+1}$</span>. To calculate this, we can simply refer back to the Taylor series expansion:</p><p class="math-container">\[u(t+(n+1)h) = u(t+nh) + h u&#39;(t+nh) + \mathcal{O}(h^2)\]</p><p class="math-container">\[LTE = u(t+(n+1)h) - u_{n+1}\]</p><p class="math-container">\[LTE = (u(t+nh) + h u&#39;(t+nh) + \mathcal{O}(h^2)) - (u_n + h f(u_n,p,t_n))\]</p><p class="math-container">\[LTE = (u(t+nh) + h u&#39;(t+nh) + \frac{1}{2}h^2 u&#39;&#39;(t) + \mathcal{O}(h^3)) - (u(t+nh) + h u&#39;(t+nh))\]</p><p class="math-container">\[LTE = \frac{1}{2}h^2 u&#39;&#39;(t) + \mathcal{O}(h^3)\]</p><h3 id="Global-Truncation-Error-in-Euler&#39;s-Method"><a class="docs-heading-anchor" href="#Global-Truncation-Error-in-Euler&#39;s-Method">Global Truncation Error in Euler&#39;s Method</a><a id="Global-Truncation-Error-in-Euler&#39;s-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Global-Truncation-Error-in-Euler&#39;s-Method" title="Permalink"></a></h3><p>The global truncation error is the error in a full integration. Abusing notation a bit and letting <span>$u(t+nh)$</span> be the true solution at time <span>$t+nh$</span>, we can calculate this as:</p><p class="math-container">\[E_{n+1} = u(t+(n+1)h) - u_{n+1}\]</p><p class="math-container">\[E_{n+1} = u(t+(n+1)h) - (u_{n} + h f(u_n,p,t_n))\]</p><p class="math-container">\[E_{n+1} = (u(t+nh)-u_{n}) + (u(t+(n+1)h) - u(t+nh) - hf(u(t+nh),p,t_n)) + (hf(u(t+nh),p,t_n) - h f(u_n,p,t_n))\]</p><p>Notice that the first term is the global error at time step <span>$n$</span> while the second term is simply the LTE at time step <span>$n$</span>, and thus we can simplify:</p><p class="math-container">\[E_{n+1} = E_n + LTE_n + (hf(u(t+nh),p,t_n) - h f(u_n,p,t_n))\]</p><p>If we assume that the derivatives are bounded, in particular: </p><p class="math-container">\[u&#39;&#39;(t) \leq A\]</p><p>over the domain of interest, then by the Taylor Series Remainder Theorem:</p><p><img src="../../img/taylor_remainder.png" alt/></p><p>We can bound the error in the rest of the LTE terms using the maximum of the second derivative, and thus:</p><p class="math-container">\[LTE_n \leq \frac{1}{2} A h^2\]</p><p>For the final term, we use the mean-value theorem:</p><p class="math-container">\[|f(u(t+nh),p,t_n) - f(u_n,p,t_n)| = |\frac{\partial f(u^\ast, p, t_n)}{\partial u}| |u(t+nh)-u_n|\]</p><p>We use assume the first partial derivative is bounded over the domain of interest:</p><p class="math-container">\[\frac{\partial f(u^\ast, p, t_n)}{\partial u} \leq B\]</p><p>and thus</p><p class="math-container">\[|f(u(t+nh),p,t_n) - f(u_n,p,t_n)| \leq B E_n\]</p><p>Substituting all of this together we get:</p><p class="math-container">\[|E_{n+1}| \leq |E_n| + \frac{1}{2} A h^2 + h B |E_n|\]</p><p class="math-container">\[|E_{n+1}| \leq (1+Bh)|E_n| + \frac{1}{2} A h^2\]</p><p>Some manipulations later...</p><p><img src="../../img/geometric_series.png" alt/></p><p>You get that <span>$E_n$</span> is bounded by a geometric series and use the analytical solution to a geometric series to get:</p><p class="math-container">\[|E_n| \leq \frac{A}{2B}[(1+Bh)^n - 1]h\]</p><p>Finally, notice:</p><p class="math-container">\[1+Bh \leq 1 + Bh + \frac{1}{2} (Bh)^2 + \frac{1}{3!} (Bh)^3 + \ldots = e^{Bh}\]</p><p>and therefore:</p><p class="math-container">\[|E_n| \leq \frac{A}{2B}[e^{Bhn} - 1]h\]</p><p>From this we can see that <span>$|E_n| \rightarrow 0$</span> as <span>$h \rightarrow 0$</span>.</p><h3 id="General-Points-About-the-Global-Truncation-Error"><a class="docs-heading-anchor" href="#General-Points-About-the-Global-Truncation-Error">General Points About the Global Truncation Error</a><a id="General-Points-About-the-Global-Truncation-Error-1"></a><a class="docs-heading-anchor-permalink" href="#General-Points-About-the-Global-Truncation-Error" title="Permalink"></a></h3><p>The key factor is that while the leading term of the local truncation error has a nice and clean formula and the global error is related to this LTE, the global error requires propagation of each LTE into the next stage and thus has a compounding factor. Even with that, we can still bound the global error to ensure convergence as <span>$h \rightarrow 0$</span>, but only if:</p><ol><li>Derivatives one order beyond the order of the method are bounded.</li><li>The local truncation error converges to zero</li><li>The partials of <code>f</code> are bounded.</li></ol><p>While this proof can be relaxed to remove some of the required bounding, these are general points to note which are exploited by most solvers. You need the derivatives defined in order for the solvers to work well, and the higher order method you use the higher derivatives you need bounds for. </p><h2 id="Going-Beyond-Euler&#39;s-Method"><a class="docs-heading-anchor" href="#Going-Beyond-Euler&#39;s-Method">Going Beyond Euler&#39;s Method</a><a id="Going-Beyond-Euler&#39;s-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Going-Beyond-Euler&#39;s-Method" title="Permalink"></a></h2><h3 id="The-Midpoint-Method"><a class="docs-heading-anchor" href="#The-Midpoint-Method">The Midpoint Method</a><a id="The-Midpoint-Method-1"></a><a class="docs-heading-anchor-permalink" href="#The-Midpoint-Method" title="Permalink"></a></h3><p>We can use this analysis to extend our methods to higher order approximation by simply matching the Taylor series to a higher order. Intuitively, when we developed the Euler method we had to make a choice:</p><p class="math-container">\[u_{n+1} = u_n + h f(u,p,t)\]</p><p>where do we evaluate <span>$f$</span>? One may think that the best derivative approximation my come from the middle of the interval, in which case we might want to evaluate it at <span>$t + \frac{h}{2}$</span>. To do so, we can use the Euler method to approximate the value at <span>$t + \frac{h}{2}$</span> and then use that value to approximate the derivative at <span>$t + \frac{h}{2}$</span>. This looks like:</p><p class="math-container">\[k_1 = f(u_n,p,t)\\
k_2 = f(u_n + \frac{h}{2} k_1,p,t + \frac{h}{2})\\
u_{n+1} = u_n + h k_2\]</p><p>which we can also write as:</p><p class="math-container">\[u_{n+1} = u_n + h f(u_n + \frac{h}{2} f_n,p,t + \frac{h}{2})\]</p><p>where <span>$f_n = f(u_n,p,t)$</span>. If we do the two-dimensional Taylor expansion we get:</p><p class="math-container">\[u_{n+1} = u_n + h f_n + \frac{h^2}{2}(f_t + f_u f)(u_n,p,t)\\
+ \frac{h^3}{6} (f_{tt} + 2f_{tu}f + f_{uu}f^2)(u_n,p,t)\]</p><p>which when we compare against the true Taylor series:</p><p class="math-container">\[u(t+h) = u_n + h f(u_n,p,t) + \frac{h^2}{2}(f_t + f_u f)(u_n,p,t)
+ \frac{h^3}{6}(f_{tt} + 2f_{tu} + f_{uu}f^2 + f_t f_u + f_u^2 f)(u_n,p,t)\]</p><p>and thus we see that</p><p class="math-container">\[u(t + h) - u_n = \mathcal{O}(h^3)\]</p><h3 id="General-Runge-Kutta-Methods"><a class="docs-heading-anchor" href="#General-Runge-Kutta-Methods">General Runge-Kutta Methods</a><a id="General-Runge-Kutta-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#General-Runge-Kutta-Methods" title="Permalink"></a></h3><p>However, this idea gives rise to a more general scheme for approximating ODEs. The general form is to use previous derivative information to construct an approximation to some value <span>$u(t+ch)$</span>, then using this new value to approximate a new derivative, and thus construct a better approximation <span>$u(t+c_2 h)$</span>, and so on. Then using each of these sub-interval approximations we can approximate the final time point.</p><p>In mathematical terms, this type of scheme can be written as:</p><p class="math-container">\[k_1 = f(u_n,p,t_n)\]</p><p class="math-container">\[k_2 = f(u_n + h a_{11} k_1,p,t_n + c_2 h)\]</p><p class="math-container">\[k_3 = f(u_n + h a_{21} k_1 + a_{22} k_2, p, t_n + c_3 h)\]</p><p class="math-container">\[\vdots\]</p><p class="math-container">\[u_{n+1} = u_n + h(b_1 k_1 + b_2 k_2 + \ldots + b_s k_s)\]</p><p>where <span>$s$</span> is the number of stages. In this schema, the Euler method is simply the one-stage method, while the Midpoint method is the schema with <span>$c_1 = 0$</span>, <span>$c_2 = \frac{1}{2}$</span>, <span>$a_{11} = \frac{1}{2}$</span>, and <span>$b_1 = 0$</span>, <span>$b_2 = 1$</span>. </p><p>This class of methods is known as the Runge-Kutta methods and the set of coefficients <span>$(a_{ij}, b_i, c_i)$</span> is known as the tableau. Normally these tableaus are represented in a table:</p><p><img src="../../img/rk_tableau.png" alt/></p><p>The order of the Runge-Kutta method is simply the number of terms in the Taylor series that ends up being matched by the resulting expansion. For example, for the 4th order you can expand out and see that the following equations need to be satisfied:</p><p><img src="https://user-images.githubusercontent.com/1814174/95117136-105ae780-0716-11eb-9f6a-49fecf7adbeb.PNG" alt/></p><h3 id="Note-about-Order-Conditions"><a class="docs-heading-anchor" href="#Note-about-Order-Conditions">Note about Order Conditions</a><a id="Note-about-Order-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Note-about-Order-Conditions" title="Permalink"></a></h3><p>Since the number of terms in the Taylor series grows exponentially with each increase in the order, this is fairly difficult to write down and thus most people use tricks in order to represent the order conditions. We refer to Hairer I for more information on this process.</p><p><img src="../../img/num_order_conditions.png" alt/></p><p>You basically make rooted trees and then they represent conditions.</p><p><img src="../../img/rooted_tree.png" alt/></p><p>It&#39;s complicated and not necessarily for understanding how the resulting methods are used.</p><h3 id="Note-about-stages-and-order"><a class="docs-heading-anchor" href="#Note-about-stages-and-order">Note about stages and order</a><a id="Note-about-stages-and-order-1"></a><a class="docs-heading-anchor-permalink" href="#Note-about-stages-and-order" title="Permalink"></a></h3><p>1st order (i.e. matching the first term of the Taylor series) can be achieved by Euler&#39;s method which is one stage. Second order can be achieved by the Midpoint method which is two stages. &quot;The Runge-Kutta method&quot;, which is also known as the classic Runge-Kutta method is simply RK4 is a 4th order method which  uses 4 stages:</p><p class="math-container">\[k_1 = f(u_n,p,t)\\
k_2 = f(u_n + \frac{h}{2} k_1,p,t + \frac{h}{2})\\
k_3 = f(u_n + \frac{h}{2} k_2,p,t + \frac{h}{2})\\
k_4 = f(u_n + h k_3,p,t + h)\\
u_{n+1} = u_n + \frac{h}{6}(k_1 + 2 k_2 + 2 k_3 + k_4)\\\]</p><p>It may seem wise to thus extrapolate that one can gain an order per <code>f</code> evaluation, but that is not the case. It turns out that the number of stages required starts to grow more than linearly after 4! With <span>$p$</span> being the order, here&#39;s a table of known minimum orders:</p><p><img src="../../img/minstages.png" alt/></p><p>Given the number of terms in the Taylor series expansion grows exponentially after the first order, this calculation is hard to do but is guaranteed to be larger than linear. However, as we will see later, the effect of better order is exponential, so this does not mean that fourth order is optimal!</p><h2 id="The-Fundamental-Tension-in-ODE-Solvers"><a class="docs-heading-anchor" href="#The-Fundamental-Tension-in-ODE-Solvers">The Fundamental Tension in ODE Solvers</a><a id="The-Fundamental-Tension-in-ODE-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#The-Fundamental-Tension-in-ODE-Solvers" title="Permalink"></a></h2><p>The fundamental tension in ODE solvers is a simple fact:</p><p><strong>The theoretical performance of ODE solvers is well-understood as <span>$h \rightarrow 0$</span>, but the purpose of a good ODE solver is to choose an <span>$h$</span> as large as possible in order to achieve a given error tolerance.</strong></p><p>Let&#39;s disect this a bit. The goal of an efficient code for solving ODEs is to approximate the solution to <span>$u&#39; = f(u,p,t)$</span> &quot;as fast as possible&quot;. But since it&#39;s an approximation, an error tolerance always needs to be known, i.e. &quot;Approximate the solution to <span>$u&#39; = f(u,p,t)$</span> as fast as possible under the constraint that the solution is within TOL of the true solution&quot;. </p><p>This statement has a major caveat. In order to know if we are within TOL of the true solution, we would need some measure of the error. As we saw in the discussion on Euler&#39;s method, even for the simplest of numerical methods for ODEs a complete formula for the error of the full solution is seemingly unobtainable. Thus in general the field has relaxed this constraint to instead be written as &quot;Approximate the solution to <span>$u&#39; = f(u,p,t)$</span> as fast as possible under the constraint that the solution the error of any given step is below TOL&quot;. In other words, we wish to build efficient numerical solvers where <span>$LTE \leq TOL$</span>. </p><p>In order to achieve &quot;efficient&quot;, we thus wish to choose as large of an <span>$h$</span> as possible such that <span>$LTE \approx TOL$</span>, since the larger <span>$h$</span> is, the less total steps are required to solve the equation. This brings up two questions:</p><ol><li>What kinds of methods take the least amount of &quot;work&quot; for the smallest LTE?</li><li>How can we find <span>$h$</span> such that <span>$LTE \leq TOL$</span>?</li></ol><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>There are ways to build ODE solvers that control the global truncation error, but there is no open source software (nor widely used closed source software) which does this with Runge-Kutta methods for IVPs. This is a potential final project.</p></div></div><h3 id="A-Bit-of-Mental-Math-Around-Solver-Work-Calculations-And-Optimal-Order"><a class="docs-heading-anchor" href="#A-Bit-of-Mental-Math-Around-Solver-Work-Calculations-And-Optimal-Order">A Bit of Mental Math Around Solver Work Calculations And Optimal Order</a><a id="A-Bit-of-Mental-Math-Around-Solver-Work-Calculations-And-Optimal-Order-1"></a><a class="docs-heading-anchor-permalink" href="#A-Bit-of-Mental-Math-Around-Solver-Work-Calculations-And-Optimal-Order" title="Permalink"></a></h3><p>Note that for efficiency of (non-stiff) ODE solvers, we simplify the calculation of work to simply assume that the internals of the ODE solver are effectively free compute, and thus the cost of running the ODE solver can be approximated by the number of times <span>$f(u,p,t)$</span> is computed. For Runge-Kutta methods, the number of times <span>$f$</span> is computed in a step is the stage of the method. Thus as we increase the stage of the method, there is more compute required for a given stage, but in theory the error should be less, therefore allowing <span>$h$</span> to be larger and potentially requiring fewer steps.</p><p>To understand this balance a bit better, we note that order has an exponential effect on the error with respect to <span>$h$</span>. For example, if a method is 4th order, then the LTE is <span>$\mathcal{O}(h^5)$</span>, and thus if we change <span>$h$</span> to <span>$\frac{h}{2}$</span>, we end up decreasing the error by a factor of <span>$\frac{1}{2^5} = \frac{1}{32}$</span>. Thus, if going to a higher order does not require an exponential increase in the number of stages required (which it does not), in terms of efficiency then it may seem best to always use the highest order method that we can.</p><p>However, this fact must be balanced around two facts. The first is that this error estimate only holds as <span>$h \rightarrow 0$</span>. As <span>$h$</span> grows, the other terms in the LTE approximation become non-negligible, and thus it becomes no longer guaranteed that a higher order method has a lower error than a lower order method! Secondly, the methods themselves have a maximum step size which is allowed due to the stability requirement on the ODE solver. Thus the ODE solver should have a high enough order in order to make use of the efficiency gains, but if the order is too high then the <span>$h$</span> will need to be artificially decreased in order to ensure stability and accurate error approximations, and therefore there is a &quot;sweet spot&quot; where the order is high but not too high.</p><p>In practice, this has empirically been found to be between 3-9, though this can be very dependent on two things. For one, it&#39;s dependent on the type of problem being solved since the larger the eigenvalues of the Jacobian, i.e. the approximation of the linear stability <span>$\lambda$</span>, the smaller <span>$h$</span> which is allowed. Therefore, equations with larger eigenvalues in the Jacobain tend to be optimal with lower order methods. And the second point, the optimality is dependent on the choice of TOL, since the smaller the error tolerance the smaller <span>$h$</span> will be, and thus the higher order that will be efficient.</p><h3 id="LTE-Optimal-Runge-Kutta-Methods-via-Tableau-Optimization"><a class="docs-heading-anchor" href="#LTE-Optimal-Runge-Kutta-Methods-via-Tableau-Optimization">LTE-Optimal Runge-Kutta Methods via Tableau Optimization</a><a id="LTE-Optimal-Runge-Kutta-Methods-via-Tableau-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#LTE-Optimal-Runge-Kutta-Methods-via-Tableau-Optimization" title="Permalink"></a></h3><p>Let&#39;s take for granted that a two-stage Runge-Kutta method can at most be second order, i.e. can match only the second derivative term of the Taylor Series expansion exactly. This means that for any second order method with two-stages,</p><p class="math-container">\[k_1 = f(u_n,p,t_n)\]</p><p class="math-container">\[k_2 = f(u_n + h a_{11} k_1,p,t_n + c_2 h)\]</p><p class="math-container">\[u_{n+1} = u_n + h(b_1 k_1 + b_2 k_2)\]</p><p>we would have that:</p><p class="math-container">\[LTE = C h^3 u&#39;&#39;&#39;(t) + \mathcal{O}(h^4)\]</p><p>for some value of <span>$C(a_{11}, c_2, b_1, b_2)$</span>. Thus we can consider a LTE-Optimal second order two-stage Runge-Kutta method as the tableau choice that minimizes <span>$C(a_{11}, c_2, b_1, b_2)$</span>.</p><p>Similarly, for any number of stages <span>$s$</span> and order <span>$o$</span>, the LTE-Optimal <span>$s$</span>-stage <span>$o$</span>th order method is the choice of tableau coefficients <span>$(a_{ij}, b_i, c_i)$</span> which minimizes:</p><p class="math-container">\[LTE = C h^{o+1} u^{(o+1)}(t) + \mathcal{O}(h^(o+2))\]</p><p>An equivalent statement to this problem is the following:</p><p><strong>Find the tableau coefficients <span>$(a_{ij}, b_i, c_i)$</span> such that the order conditions for order <span>$o-1$</span> are satisfied exactly, and the divergence from the order constraints <span>$o$</span> is minimal</strong></p><p>This is equivalent because &quot;the order conditions for order <span>$o-1$</span> are satisfied exactly&quot; is equivalent to stating that the method satisfies that the Taylor series expansion exactly calculates the <span>$o$</span>th derivative term in the Taylor series expansion, and as the divergence of the order conditions shrinks then so does <span>$C$</span> which is a linear combination of the divergences of the order conditions. In this formulation, the optimal Runge-Kutta tableau is thus the solution to a (generally high dimensional) nonlinear constrained optimization problem!</p><p>However, similar to how the order conditions can quickly become intractible concisely state or compute by hand, and thus many of the methods used in practice used a mixture of hand-optimization mixed with a numerical optimization process. The most famous method is the Dormand-Prince method, which is the tableau behind popular software such as <code>dopri5</code>, <code>ode45</code>, <code>DP5</code>, and other implementations. It is thus given by the tabeleau:</p><p><img src="../../img/dp5.png" alt/></p><p>It is a 5th order method with 7 stages. Its optimization process looks like:</p><p><img src="../../img/dp5_opt.png" alt/></p><p>There are a few peculiarities to address with this method. </p><ol><li>The method being 5th order with 7 stages is not &quot;stage optimal&quot; since there exist methods with 6 stages which are 5th order. In theory, a method with 6 stages evaluates <span>$f$</span> only 6 times instead of 7, and so therefore wouldn&#39;t that be more optimal? It turns out that while the order conditions can be achieved, the leading terms of the next order LTE are so large that in fact it&#39;s more optimal to take another <span>$f$</span> evaluation per stage.</li><li>This method was derived by hand in 1980 and made the assumption that some of the terms were zero in order to simplify the optimization process. This means it&#39;s not necessarily optimal.</li><li>The last stage of the step exactly matches the update equation. This is a property known as &quot;first same as last&quot; (FSAL), and thus while the method technically requires 7 evaluations per stage, after the first step we can cache the value of the <span>$k_7$</span> and reuse it as <span>$k_1$</span> in the next evaluation, and therefore this method effectively takes 6 steps per stage!</li></ol><h3 id="Note:-Further-Optimizations-Beyond-Dormand-Prince"><a class="docs-heading-anchor" href="#Note:-Further-Optimizations-Beyond-Dormand-Prince">Note: Further Optimizations Beyond Dormand-Prince</a><a id="Note:-Further-Optimizations-Beyond-Dormand-Prince-1"></a><a class="docs-heading-anchor-permalink" href="#Note:-Further-Optimizations-Beyond-Dormand-Prince" title="Permalink"></a></h3><p>You may then ask the question of whether anyone has fixed (2) to derive a 5th order 7-stage method with FSAL which does not make the extra zero column assumptions. If you were thinking this, then you&#39;re right in 2011 someone went back to this problem and used numerical optimization tools in order to derive a method that is approximately 20% more efficient and this is the tableau used in the <code>Tsit5()</code> method of DifferentialEquations.jl.</p><p>Its optimization process was mostly numerical:</p><p><img src="../../img/tsit5_opt.png" alt/></p><p>Giving the following tableau:</p><p><img src="../../img/tsit5_coeffs.png" alt/></p><h2 id="Choosing-the-Optimal-h:-Adaptivity"><a class="docs-heading-anchor" href="#Choosing-the-Optimal-h:-Adaptivity">Choosing the Optimal h: Adaptivity</a><a id="Choosing-the-Optimal-h:-Adaptivity-1"></a><a class="docs-heading-anchor-permalink" href="#Choosing-the-Optimal-h:-Adaptivity" title="Permalink"></a></h2><p>Recall the two fundamental questions for an optimal ODE solver:</p><ol><li>What kinds of methods take the least amount of &quot;work&quot; for the smallest LTE?</li><li>How can we find <span>$h$</span> such that <span>$LTE \leq TOL$</span>?</li></ol><p>We have addressed 1 by exploring LTE-optimal Runge-Kutta methods which minimize the number of <span>$f$</span> evaluations in order to achieve a given accuracy for &quot;non-zero <span>$h$</span>&quot;. However, what is the value of <span>$h$</span> we should use at each time step? This is the question that is addressed through adaptivity.</p><h3 id="A-Priori-Error-Estimators"><a class="docs-heading-anchor" href="#A-Priori-Error-Estimators">A Priori Error Estimators</a><a id="A-Priori-Error-Estimators-1"></a><a class="docs-heading-anchor-permalink" href="#A-Priori-Error-Estimators" title="Permalink"></a></h3><p>In order to approximate the LTE, let&#39;s look at the Euler method. We know in this case that </p><p class="math-container">\[LTE = \frac{1}{2}h^2 u&#39;&#39;(t) + \mathcal{O}(h^3)\]</p><p>and therefore if <span>$h$</span> is sufficiently small, we could simply use:</p><p class="math-container">\[u&#39;&#39; = \frac{\partial}{\partial t} f(u,p,t) = f_u(u,p,t)u&#39; + f_t(u,p,t)\]</p><p>where <span>$f_x = \frac{\partial f}{\partial x}$</span>. Using the fact that we approximated <span>$u&#39; = \frac{u_{n+1} - u_n}{h}$</span>, we can approximate:</p><p class="math-container">\[LTE \approx \frac{1}{2} f_u(u_n,p,t_n) (u_{n+1} - u_n) h + \frac{1}{2} f_t(u_n,p,t_n) h^2\]</p><p>This type of estimate is known an a priori error estimator since we are using a prior-derived equation in order to directly predict the error. However, since this method requires computing the partial derivatives of the function <span>$f$</span>, which you may not have in an ODE solver software if the user only supplies <span>$f$</span>, this type of estimate can be (a) difficult to derive for higher order methods, and (b) can be costly. </p><p>Other a priori error estimators seek to approximate <span>$u&#39;&#39;(t)$</span> more directly. Note that implicit Euler has the same error term as explicit Euler, and in old SPICE circuit simulators the following scheme was derived:</p><pre><code class="language-julia hljs"># Code pulled from OrdinaryDiffEq.jl

# local truncation error (LTE) bound by dt^2/2*max|y&#39;&#39;(t)|
# use 2nd divided differences (DD) a la SPICE and Shampine

# TODO: check numerical stability
uprev2 = integrator.uprev2
tprev = integrator.tprev

dt1 = dt * (t + dt - tprev)
dt2 = (t - tprev) * (t + dt - tprev)
c = 7 / 12 # default correction factor in SPICE (LTE overestimated by DD)
r = c * dt^2 # by mean value theorem 2nd DD equals y&#39;&#39;(s)/2 for some s

@.. E =r * integrator.opts.internalnorm((u - uprev) / dt1 - (uprev - uprev2) / dt2, t)</code></pre><p>which uses the 2nd order divided differences formula in order to approximate <span>$u&#39;&#39;(t)$</span> using the current step and the previous step. </p><h3 id="A-Posteriori-Error-Estimators"><a class="docs-heading-anchor" href="#A-Posteriori-Error-Estimators">A Posteriori Error Estimators</a><a id="A-Posteriori-Error-Estimators-1"></a><a class="docs-heading-anchor-permalink" href="#A-Posteriori-Error-Estimators" title="Permalink"></a></h3><p>However, a much more common form of error estimator is the a posteriori error estimator. The basis for these error estimators comes from a simple observation. If we use the Euler method, then we have the LTE:</p><p class="math-container">\[LTE = \frac{1}{2}h^2 u&#39;&#39;(t) + \mathcal{O}(h^3)\]</p><p>Now, we we instead calculate with a 3rd order method, we have:</p><p class="math-container">\[LTE = C h^3 u&#39;&#39;&#39;(t) + \mathcal{O}(h^4)\]</p><p>In other words, the third order method must exactly compute that missing term in the Taylor series <span>$\frac{1}{2}h^2 u&#39;&#39;(t)$</span> since that is required by definition to be 3rd order. Thus if we compute a step with both Euler&#39;s method <span>$u_{n+1}$</span> and a step with the 3rd order method <span>$hat{u}_{n+1}$</span>, then we have that:</p><p class="math-container">\[u_{n+1} - hat{u}_{n+1} = \frac{1}{2}h^2 u&#39;&#39;(t) + \mathcal{O}(h^3)\]</p><p>While the higher order terms in this case are different from that of the LTE (since they are influenced by the higher order LTE terms of the third order method), as <span>$h \rightarrow 0$</span> then we have that <span>$u_{n+1} - hat{u}_{n+1} \rightarrow LTE$</span> for the Euler method!</p><p>More generally, if we have a first method <span>$u_{n+1}$</span> which is order <span>$o_1$</span> and a second method <span>$hat{u}_{n+1}$</span> which is order <span>$o_2$</span>, where <span>$o_1 &lt; o_2$</span>, then:</p><p class="math-container">\[u_{n+1} - hat{u}_{n+1} = LTE + C^\ast \mathcal{O}(h^{o_1 + 1})\]</p><p>and thus the difference between two ODE solvers with different orders serves as a method to estimate the local truncation error.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If you have computed the steps for the <span>$o_1$</span> method and the <span>$o_2$</span> method, then under the assumption that <span>$h$</span> is sufficiently small, then the LTE of the <span>$o_2$</span> method should be smaller than the LTE of the <span>$o_1$</span> method. Thus while the error estimate is of the <span>$o_1$</span> method, we can take the steps using the <span>$o_2$</span> method. This is known as the local extrapolation trick and is common in adaptive time stepping software.</p></div></div><h3 id="Reassessing-Dormand-Prince,-i.e.-&quot;ode45&quot;,-With-Adaptivity"><a class="docs-heading-anchor" href="#Reassessing-Dormand-Prince,-i.e.-&quot;ode45&quot;,-With-Adaptivity">Reassessing Dormand-Prince, i.e. &quot;ode45&quot;, With Adaptivity</a><a id="Reassessing-Dormand-Prince,-i.e.-&quot;ode45&quot;,-With-Adaptivity-1"></a><a class="docs-heading-anchor-permalink" href="#Reassessing-Dormand-Prince,-i.e.-&quot;ode45&quot;,-With-Adaptivity" title="Permalink"></a></h3><p>Let&#39;s look back at the canonical tableau for the Dormand-Prince method:</p><p><img src="../../img/dp5_opt.png" alt/></p><p>Notice that there are two lines for the <span>$b_i$</span> coefficients. It turns out that this method is designed so that with the same set of <span>$k_i$</span>, there are two methods that are calculated. The first method is a 7-stage 5th order method, and the second method is a 7-stage 4th order method. Their difference is thus an approximation to the LTE, notably with 0 extra <span>$f$</span> evaluations. This is known as an embedded error estimate.</p><h3 id="Choosing-h-and-Rejection-Sampling"><a class="docs-heading-anchor" href="#Choosing-h-and-Rejection-Sampling">Choosing h and Rejection Sampling</a><a id="Choosing-h-and-Rejection-Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Choosing-h-and-Rejection-Sampling" title="Permalink"></a></h3><p>The simplest way to choose <span>$h$</span> is to make it proportional to the current error. If we have a local truncation error estimate <span>$LTE$</span> and have a tolerance target of <span>$TOL$</span>, then we can define the update factor:</p><p class="math-container">\[q = \frac{LTE}{TOL}\]</p><ul><li>If <span>$q &lt; 1$</span>, then <span>$TOL &gt; LTE$</span> and therefore we should not accept this step as doing so will make a step beyond the user&#39;s tolerance. And note that this would void our warrenty on the global error being bounded, since we need the LTE is &quot;bounded&quot; (at least approximately) at every step to then have any statement about the global error. Thus the calculation with the current <span>$h$</span> is rejected, the <span>$h$</span> is changed to <span>$qh$</span> and the step is recomputed with this smaller time step.</li><li>If <span>$q \geq 1$</span>, then <span>$TOL \leq LTE$</span> and thus the step is good. Therefore we accept the step and grow <span>$h$</span>, for example making the new <span>$h$</span> equal to <span>$qh$</span>.</li></ul><p>Importantly, this means that rejection is way more expensive than acceptance, and therefore it&#39;s always good to be a little conservative with step growth. Thus generally the changes are done with a factor, <span>$Cqh$</span>, where this <span>$C = 0.9$</span> or 0.8 or similar.</p><p>This is effectively an integral controller on the error term. More advanced schemes are discussed in detail in the <a href="https://docs.sciml.ai/DiffEqDocs/stable/extras/timestepping/">DifferentialEquations.jl timestepping documentation</a>.</p><h2 id="Dense-Output-And-Saving-Approximations"><a class="docs-heading-anchor" href="#Dense-Output-And-Saving-Approximations">Dense Output And Saving Approximations</a><a id="Dense-Output-And-Saving-Approximations-1"></a><a class="docs-heading-anchor-permalink" href="#Dense-Output-And-Saving-Approximations" title="Permalink"></a></h2><h3 id="Constructing-General-Dense-Output-Schemes"><a class="docs-heading-anchor" href="#Constructing-General-Dense-Output-Schemes">Constructing General Dense Output Schemes</a><a id="Constructing-General-Dense-Output-Schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-General-Dense-Output-Schemes" title="Permalink"></a></h3><p>All of the schemes above only describe the solution at approximation time points <span>$u_n \approx u(t+nh)$</span>, but of course the true solution is a continuous object. How could one construct a continuous approximation over the full interval <span>$t \in (t_0, t_f)$</span>? The simplest idea is to use the points <span>${u_n}$</span> in order to construct an interpolating polynomial <span>$\tilde{u}(t)$</span>. For example, using a linear polynomial, we can approximate any value <span>$u(t+(n+\theta)h)$</span> by:</p><p class="math-container">\[u(t+(n+\theta)h) \approx \theta u_n + (1-\theta) u_{n+1}\]</p><p>for any <span>$\theta \in [0,1]$</span>. Similarly, quadratic, cubic, and further splines can be constructed. However, these approximations can be quite unstable at higher order and it does not make use of information that is already computed. For all of the Runge-Kutta methods, we have that <span>$k_1 = f(u_n,p,t_n) \approx u&#39;(t_n)$</span>, and thus we not only have approximations to <span>$u(t+nh)$</span> but also have &quot;free&quot; (already computed) approximations to <span>$u&#39;(t+nh)$</span> as well. Using this information, we can approximate any value <span>$u(t+(n+\theta)h)$</span> by the Hermite polynoimal:</p><p class="math-container">\[(1 - Θ) u(t_n) + Θ u(t_{n+1}) + (Θ (Θ - 1) ((1 - 2Θ) (u(t_{n+1}) - u(t_n)) + (Θ - 1) h u&#39;(t_n) + Θ h u&#39;(t_{n+1}))\]</p><p>However, this train of thought indicates that we are still missing information since each <span>$k_i$</span> in the Runge-Kutta method is an approximation to some <span>$u&#39;(t+(n+c)h)$</span>! Therefore, what if we constructed an approximation using all of the <span>$k_i$</span> derivative approximation?</p><h3 id="Method-Specific-Dense-Output-Schemes"><a class="docs-heading-anchor" href="#Method-Specific-Dense-Output-Schemes">Method-Specific Dense Output Schemes</a><a id="Method-Specific-Dense-Output-Schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Method-Specific-Dense-Output-Schemes" title="Permalink"></a></h3><p>Each Runge-Kutta method computes <span>$k_i$</span> estimates within each step, which are all derivative estimates. Using these <span>$k_i$</span> we construct the output using the update equation:</p><p class="math-container">\[u_{n+1} = u_n + h(b_1 k_1 + b_2 k_2 + \ldots + b_s k_s)\]</p><p>The update equation has <span>$b_i$</span> chosen such that the final solution <span>$u_{n+1}$</span> is of the desired order. However, we can generalize this process a bit to the following. Assuming we we can calculate the solution at <span>$u_{n+\theta}$</span> for any <span>$\theta \in [0,1]$</span>, we can instead construct the following update equation:</p><p class="math-container">\[u_{n+\theta} = u_n + h(b_1(\theta) k_1 + b_2(\theta) k_2 + \ldots + b_s(\theta) k_s)\]</p><p>where the <span>$b_i(\theta)$</span> are parameterized polynomial equations. We then simply require that <span>$b_i(1) = b_i$</span>, and with to find the parameters <span>$r_{ij}$</span> of the polynomials, i.e. </p><p class="math-container">\[b_i(\theta) = r_{i0} + r_{i1} \theta + \ldots + r_{is} \theta^s\]</p><p>with respect to <span>$\theta$</span> such that <span>$u_{n+\theta}$</span> is an <span>$o$</span>-th order approximation to the solution. This  <span>$o$</span> is generally found to be strictly less than the order of the method. For example, further work by Shampine found a set of coefficients <span>$r_{ij}$</span> for the Dormand-Prince method which gives a 4th order dense approximation, which is thus the commonly used densification for the <code>ode45</code> or <code>dopri5</code> scheme.</p><h3 id="Decoupling-Stepping-From-Saving-in-Adaptive-Schemes"><a class="docs-heading-anchor" href="#Decoupling-Stepping-From-Saving-in-Adaptive-Schemes">Decoupling Stepping From Saving in Adaptive Schemes</a><a id="Decoupling-Stepping-From-Saving-in-Adaptive-Schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Decoupling-Stepping-From-Saving-in-Adaptive-Schemes" title="Permalink"></a></h3><p>Now why is dense output important? When we were using a non-adaptive scheme, we could know where our step points would be. For example, if we wanted values of the solution output at {1/2, 1, 3/2, ...}, we could simply set <span>$h=1/2$</span> and receive these values. If the error was too high, we could simply re-compute the solution with <span>$h=1/4$</span>, or any other integer divisor of our desired outputs.</p><p>However, once we move to an adaptive scheme, we cannot guarantee to the user that the method will step to specific points. We can either do two things:</p><ol><li>Always take the minimum of the desired <span>$h$</span> and the distance to the next saving point. Since decreasing <span>$h$</span> decreases the error, this thus enforces that the TOL is satisfied, though it may be overly conservative in many situations.</li><li>We take steps using the desired <span>$h$</span> and at the end of each step, use the embedded dense output scheme in order to compute the values at save points desired by the user.</li></ol><p>The scheme 2 uses our developed machinery to be as fast as possible, while achieving the goals of the user (TOL goals and save point goals). However given this saving behavior is generally of a lower order than the true steps of the solver, the saved points tend to be approximated to a lower order than the solver itself. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Because the Dormand-Prince method has a 4th order dense output, it&#39;s commonly misstated the <code>ode45</code>/<code>dopri5</code> method is 4th order, since empirical studies which do not carefully control the stepping to match the saving will see 4th order convergence!</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>ode45</code> has a default where when no save points are given, it will return values given by the adaptivity scheme. However, it&#39;s not only the values the method steps to, but also 4 evenly spaced points in the interval, computed using the dense output!</p></div></div><h2 id="Diving-into-the-Simplest-Tsit5"><a class="docs-heading-anchor" href="#Diving-into-the-Simplest-Tsit5">Diving into the Simplest Tsit5</a><a id="Diving-into-the-Simplest-Tsit5-1"></a><a class="docs-heading-anchor-permalink" href="#Diving-into-the-Simplest-Tsit5" title="Permalink"></a></h2><p>Using this background, we can dive into the simplest implementation of the Tsit5 explicit Runge-Kutta method and understand all of the details:</p><p><a href="https://github.com/SciML/SimpleDiffEq.jl/blob/v1.11.1/src/tsit5/gpuatsit5.jl#L99-L223">Link to SimpleDiffEq.jl GPUATsit5 Code</a></p><p><a href="https://github.com/SciML/SimpleDiffEq.jl/blob/v1.11.1/src/tsit5/tsit5.jl#L68-L117">Link to Tsit5 Tableau</a></p><h2 id="Conclusion"><a class="docs-heading-anchor" href="#Conclusion">Conclusion</a><a id="Conclusion-1"></a><a class="docs-heading-anchor-permalink" href="#Conclusion" title="Permalink"></a></h2><p>This is the most basic ODE solver, a non-stiff Runge-Kutta method. There&#39;s a surprising amount of machinery involved, and there&#39;s still more research being done on this topic. But we will continue to the next type of methods using what we have discussed here as now the building block for the more complex implicit methods used for stiff ODEs and DAEs.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lecture2/">« Developing high-fidelity models of hydraulic systems</a><a class="docs-footer-nextpage" href="../lecture4/">Numerical Methods for Stiff ODEs and Differential-Algebraic Equations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Sunday 25 February 2024 21:41">Sunday 25 February 2024</span>. Using Julia version 1.10.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
