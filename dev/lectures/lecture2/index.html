<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Developing high-fidelity models of hydraulic systems · ModelingToolkit Course</title><meta name="title" content="Developing high-fidelity models of hydraulic systems · ModelingToolkit Course"/><meta property="og:title" content="Developing high-fidelity models of hydraulic systems · ModelingToolkit Course"/><meta property="twitter:title" content="Developing high-fidelity models of hydraulic systems · ModelingToolkit Course"/><meta name="description" content="Documentation for ModelingToolkit Course."/><meta property="og:description" content="Documentation for ModelingToolkit Course."/><meta property="twitter:description" content="Documentation for ModelingToolkit Course."/><meta property="og:url" content="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture2/"/><meta property="twitter:url" content="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture2/"/><link rel="canonical" href="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture2/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelingToolkit Course</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../lecture1/">Introduction to acausal modeling for physical systems with ModelingToolkit.jl</a></li><li class="is-active"><a class="tocitem" href>Developing high-fidelity models of hydraulic systems</a><ul class="internal"><li><a class="tocitem" href="#Compressibility"><span>Compressibility</span></a></li><li><a class="tocitem" href="#Momentum-Balance"><span>Momentum Balance</span></a></li></ul></li><li><a class="tocitem" href="../lecture3/">Solvers for Non-Stiff Ordinary Differential Equations</a></li><li><a class="tocitem" href="../lecture4/">Numerical Methods for Stiff ODEs and Differential-Algebraic Equations</a></li><li><a class="tocitem" href="../lecture6/">Debugging difficult stiff ODE/DAE models</a></li><li><a class="tocitem" href="../lecture7/">Numerical and Structural Characterizations for DAEs</a></li><li><a class="tocitem" href="../lecture8/">Dummy Derivatives and Reordering of Equations</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Developing high-fidelity models of hydraulic systems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Developing high-fidelity models of hydraulic systems</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkitCourse" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkitCourse/blob/main/docs/src/lectures/lecture2.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Developing-high-fidelity-models-of-hydraulic-systems"><a class="docs-heading-anchor" href="#Developing-high-fidelity-models-of-hydraulic-systems">Developing high-fidelity models of hydraulic systems</a><a id="Developing-high-fidelity-models-of-hydraulic-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Developing-high-fidelity-models-of-hydraulic-systems" title="Permalink"></a></h1><p>Why focus on hydraulics?  The answer is essentially hydraulic modelling is really hard (in numerical computing terms, hydraulic models are often referred to as &quot;stiff&quot; ODE&#39;s, which require more rigorous solvers from standard ODE&#39;s).  Solving the challenges of modeling hydraulics is applicable to the numerical modeling challenges of all other domains.  Let&#39;s first start with the concept of <em>compressibility</em>.  Often we think of a liquid as incompressible, imagine attempting to &quot;squeeze&quot; water, it can be done but takes some very high forces.  Therefore, if the model in question won&#39;t be solving a problem with high forces, it can be assumed incompressible.  However, most hydrulic industrial models will involve high forces, this is precisely the area where most hydraulic machines are used.  </p><h2 id="Compressibility"><a class="docs-heading-anchor" href="#Compressibility">Compressibility</a><a id="Compressibility-1"></a><a class="docs-heading-anchor-permalink" href="#Compressibility" title="Permalink"></a></h2><h3 id="Density"><a class="docs-heading-anchor" href="#Density">Density</a><a id="Density-1"></a><a class="docs-heading-anchor-permalink" href="#Density" title="Permalink"></a></h3><p>Density is simply mass over volume</p><p class="math-container">\[\rho = m/V\]</p><p>Given a volume and mass of liquid, if the volume were to change from <span>$V_0$</span> to <span>$V$</span>, we know that the pressure would increase, and since the mass in this case was constant, the density will increase as well.</p><p><img src="../../img/VolumeChange.svg" alt="volume change"/></p><p>The change in pressure for an isothermal compressible process is typically given as</p><p class="math-container">\[\Delta p = -\beta \frac{\Delta V}{V_0}\]</p><h3 id="Calculating-Density-as-a-Function-of-Pressure"><a class="docs-heading-anchor" href="#Calculating-Density-as-a-Function-of-Pressure">Calculating Density as a Function of Pressure</a><a id="Calculating-Density-as-a-Function-of-Pressure-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-Density-as-a-Function-of-Pressure" title="Permalink"></a></h3><p>Substituting <span>$\Delta p$</span> and <span>$\Delta V$</span></p><p class="math-container">\[p - p_0 = -\beta \frac{V - V_0}{V_0}\]</p><p>substituting <span>$V = m / \rho$</span></p><p class="math-container">\[p - p_0 = -\beta (1 - \rho/\rho_0)  \]</p><p>Solving for <span>$\rho$</span></p><p class="math-container">\[\rho = \rho_0 (1 + (p - p_0)/\beta)\]</p><p>Taking a known <span>$\rho_0$</span> when <span>$p_0$</span> is 0 (at gage pressure), simplifies to</p><p class="math-container">\[\rho = \rho_0 (1 + p/\beta) \]</p><h3 id="Change-in-Mass"><a class="docs-heading-anchor" href="#Change-in-Mass">Change in Mass</a><a id="Change-in-Mass-1"></a><a class="docs-heading-anchor-permalink" href="#Change-in-Mass" title="Permalink"></a></h3><p>Conservation of mass gives us</p><p class="math-container">\[m_{in} - m_{out} = m_s \]</p><p>The stored mass of oil is simply</p><p class="math-container">\[m_s = \rho V \]</p><p>Taking the derivative gives us the rate of mass change</p><p class="math-container">\[\dot{m}_{in} - \dot{m}_{out} = \frac{\delta (\rho V)}{\delta t} \]</p><p>Here is where the standard hydraulic modeling often makes a simplification.  </p><p>Correct Derivation (1):  </p><p class="math-container">\[\frac{\delta (\rho V)}{\delta t} = \dot{\rho} V + \rho \dot{V} \]</p><p>Standard Practice<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> (2):  </p><p class="math-container">\[\color{red} \frac{\delta (\rho V)}{\delta t} = \dot{\rho} V + \rho_0 \dot{V}   \]</p><p>Given <span>$\dot{\rho} = \rho_0 (\dot{p} / \beta)$</span>, and <span>$q = \dot{m}/\rho_0$</span> the above is often written as</p><p class="math-container">\[\color{red} q_{in} - q_{out} = (\dot{p} / \beta) V + \dot{V} \]</p><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>Problem Definition - Given:</p><ul><li><span>$M = 10,000 kg$</span></li><li><span>$A = 0.01 m^2$</span> </li><li><span>$\rho_0 = 876 kg/m^3$</span></li><li><span>$\beta = 1.2e9 Pa$</span></li><li><span>$g = 9.807 m/s^2$</span></li></ul><p><img src="../../img/Example.svg" alt="example"/></p><p>Find the mass flow rate (<span>$\dot{m}$</span>) that provides a sinusodial output of <span>$x$</span>:</p><p class="math-container">\[x(t) = amp \cdot sin(2πtf) + x_0\]</p><p>There are 3 fundamental equations needed to solve this problem.</p><p><strong>(1) Mass balance</strong>: </p><p class="math-container">\[\dot{m} = \dot{\rho} \cdot V + \rho \cdot \dot{V}\]</p><p>where <span>$V$</span> is the cylinder volume <span>$=x \cdot A$</span></p><p><strong>(2) Newton&#39;s law</strong>:</p><p class="math-container">\[M \cdot \ddot{x} = p \cdot A - m \cdot g\]</p><p><strong>(3) Density equation</strong>:</p><p class="math-container">\[\rho = \rho_0 (1 + p/\beta) \]</p><p>The variables of this system are <span>$x$</span>, <span>$p$</span>, <span>$\rho$</span>, and <span>$\dot{m}$</span>.  By including 1 input condition that gives 4 equations and 4 variables to be solved.  We will solve the problem 3 different ways</p><p><img src="../../img/cases.svg" alt="cases"/></p><ul><li>case 1: guess <span>$\dot{m}$</span>, partial mass balance</li><li>case 2: guess <span>$\dot{m}$</span>, complete mass balance</li><li>case 3: solution, solve <span>$\dot{m}$</span> directly</li></ul><div class="admonition is-info"><header class="admonition-header">mass flow guess</header><div class="admonition-body"><p>We know that mass flow rate thru a pipe is equal to </p><p class="math-container">\[\dot{m} = \rho \bar{u} A\]</p><p>where <span>$\bar{u}$</span> is the average flow velocity thru cross section <span>$A$</span>.  We can assume that <span>$\bar{u} \approx \dot{x}$</span>.  Therefore we have</p><p class="math-container">\[\dot{m} = \rho \cdot \dot{x} \cdot A\]</p></div></div><p>To solve this in ModelingToolkit.jl, let&#39;s start by defining our parameters and <code>x</code> function</p><pre><code class="language-julia hljs">using ModelingToolkit
using DifferentialEquations
using Symbolics
using Plots
using ModelingToolkit: t_nounits as t, D_nounits as D

# parameters -------
pars = @parameters begin
    r₀ = 876 #kg/m^3
    β = 1.2e9 #Pa
    A = 0.01 #m²
    x₀ = 1.0 #m
    M = 10_000 #kg
    g = 9.807 #m/s²
    amp = 5e-2 #m
    f = 15 #Hz
end

dt = 1e-4 #s
t_end = 0.2 #s
time = 0:dt:t_end

x_fun(t,amp,f) = amp*sin(2π*t*f) + x₀</code></pre><p>Now, to supply <span>$\dot{m}$</span> we need an <span>$\dot{x}$</span> function.  This can be automatically generated for us with Symbolics.jl</p><pre><code class="language-julia hljs">ẋ_fun = build_function(expand_derivatives(D(x_fun(t,amp,f))), t, amp, f; expression=false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RuntimeGeneratedFunction(#=in Symbolics=#, #=using Symbolics=#, :((t, amp, f)-&gt;begin
          #= /home/runner/.julia/packages/SymbolicUtils/c0xQb/src/code.jl:373 =#
          #= /home/runner/.julia/packages/SymbolicUtils/c0xQb/src/code.jl:374 =#
          #= /home/runner/.julia/packages/SymbolicUtils/c0xQb/src/code.jl:375 =#
          (*)((*)((*)(6.283185307179586, amp), f), NaNMath.cos((*)((*)(6.283185307179586, f), t)))
      end))</code></pre><p>As can be seen, we get a <code>cos</code> function as expected taking the derivative of <code>sin</code>.  Now let&#39;s build the variables and equations of our system.  The base equations are generated in a function so we can easily compare the correct derivation of mass balance (<code>density_type = r(t)</code>) with the standard practice (<code>density_type = r₀</code>).</p><pre><code class="language-julia hljs">vars = @variables begin
    x(t) = x₀
    ẋ(t)
    ẍ(t)
    p(t) = M*g/A #Pa
    ṁ(t)
    r(t)
    ṙ(t)
end

function get_base_equations(density_type)

    eqs = [
        D(x) ~ ẋ
        D(ẋ) ~ ẍ
        D(r) ~ ṙ

        r ~ r₀*(1 + p/β)

        ṁ ~ ṙ*x*A + (density_type)*ẋ*A
        M*ẍ ~ p*A - M*g
    ]

    return eqs
end</code></pre><p>Note: we&#39;ve only specified the initial values for the known states of <code>x</code> and <code>p</code>.  We will find the additional unknown initial conditions before solving.  Now we have 7 variables defined and only 6 equations, missing the final driving input equation.  Let&#39;s build 3 different cases:</p><p><strong>case 1</strong>:</p><pre><code class="language-julia hljs">eqs_ṁ1 = [
    get_base_equations(r₀)...
    ṁ ~ ẋ_fun(t,amp,f)*A*r # (4) Input - mass flow guess
]</code></pre><p><strong>case 2</strong>:</p><pre><code class="language-julia hljs">eqs_ṁ2 = [
    get_base_equations(r)...
    ṁ ~ ẋ_fun(t,amp,f)*A*r # (4) Input - mass flow guess
]</code></pre><p><strong>case 3</strong>:</p><pre><code class="language-julia hljs">eqs_x = [
    get_base_equations(r)...
    x ~ x_fun(t,amp,f) # (4) Input - target x
]</code></pre><p>Now we have 3 sets of equations, let&#39;s construct the systems and solve.  If we start with case 3 with the target <span>$x$</span> input, notice that the <code>structural_simplify</code> step outputs a system with 0 equations!</p><pre><code class="language-julia hljs">@mtkbuild odesys_x = ODESystem(eqs_x, t, vars, pars)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; odesys_x</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">Model odesys_x with 0 equations</span>
<span class="sgr1">Unknowns (0):</span>
<span class="sgr1">Parameters (8):</span>
  r₀ [defaults to 876]
  β [defaults to 1.2e9]
  A [defaults to 0.01]
  x₀ [defaults to 1.0]
⋮
<span class="sgr35">Incidence matrix:</span>0×0 SparseArrays.SparseMatrixCSC{Symbolics.Num, Int64} with 0 stored entries</code></pre><p>What this means is ModelingToolkit.jl has found that this model can be solved entirely analytically.  The full system of equations has been moved to what is called &quot;observables&quot;, which can be obtained using the <code>observed()</code> function</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; observed(odesys_x)</code><code class="nohighlight hljs ansi" style="display:block;">15-element Vector{Symbolics.Equation}:
 xˍt(t) ~ 6.283185307179586amp*f*cos(6.283185307179586f*t)
 xˍtt(t) ~ -39.47841760435743amp*(f^2)*sin(6.283185307179586f*t)
 xˍttt(t) ~ -248.05021344239853amp*(f^3)*cos(6.283185307179586f*t)
 x(t) ~ x₀ + amp*sin(6.283185307179586f*t)
 ẋ(t) ~ xˍt(t)
 ẋˍt(t) ~ xˍtt(t)
 ẋˍtt(t) ~ xˍttt(t)
 ẍ(t) ~ ẋˍt(t)
 ẍˍt(t) ~ ẋˍtt(t)
 p(t) ~ (-M*g - M*ẍ(t)) / (-A)
 pˍt(t) ~ (M*ẍˍt(t)) / A
 r(t) ~ r₀*(1 + p(t) / β)
 rˍt(t) ~ (r₀*pˍt(t)) / β
 ṙ(t) ~ rˍt(t)
 ṁ(t) ~ A*r(t)*ẋ(t) + A*x(t)*ṙ(t)</code></pre><div class="admonition is-info"><header class="admonition-header">dummy derivatives</header><div class="admonition-body"><p>Some of the observables have a <code>ˍt</code> appended to the name.  These are called dummy derivatives, which are a consequence of the algorithm to reduce the system DAE index.  </p></div></div><p>This system can still be &quot;solved&quot; using the same steps to generate an <code>ODESolution</code> which allows us to easily obtain any calculated observed state.</p><pre><code class="language-julia hljs">prob_x = ODEProblem(odesys_x, [], (0, t_end))
sol_x = solve(prob_x; saveat=time)
plot(sol_x; idxs=ṁ)</code></pre><img src="8a6eb093.svg" alt="Example block output"/><p>Now let&#39;s solve the other system and compare the results. </p><pre><code class="language-julia hljs">@mtkbuild odesys_ṁ1 = ODESystem(eqs_ṁ1, t, vars, pars)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; odesys_ṁ1</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">Model odesys_ṁ1 with 4 equations</span>
<span class="sgr1">Unknowns (4):</span>
  x(t) [defaults to x₀]
  ẋ(t)
  r(t)
  ṙ(t)
<span class="sgr1">Parameters (8):</span>
  r₀ [defaults to 876]
  β [defaults to 1.2e9]
  A [defaults to 0.01]
  x₀ [defaults to 1.0]
⋮
<span class="sgr35">Incidence matrix:</span>4×7 SparseArrays.SparseMatrixCSC{Symbolics.Num, Int64} with 10 stored entries:
 ⋅  ×  ⋅  ×  ⋅  ⋅  ⋅
 ⋅  ⋅  ×  ⋅  ×  ⋅  ⋅
 ⋅  ⋅  ⋅  ⋅  ⋅  ×  ×
 ×  ×  ×  ⋅  ⋅  ⋅  ×</code></pre><p>Notice that now, with a simple change of the system input variable, <code>structural_simplify()</code> outputs a system with 4 states to be solved.  We can find the initial conditions needed for these states from <code>sol_x</code> and solve.</p><pre><code class="language-julia hljs">u0 = [sol_x[s][1] for s in unknowns(odesys_ṁ1)]
prob_ṁ1 = ODEProblem(odesys_ṁ1, u0, (0, t_end))
@time sol_ṁ1 = solve(prob_ṁ1; initializealg=NoInit());</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Warning: Initialization system is overdetermined. 3 equations for 0 unknowns. Initialization will default to using least squares. To suppress this warning pass warn_initialize_determined = false.
└ @ ModelingToolkit ~/.julia/packages/ModelingToolkit/PtnSY/src/systems/diffeqs/abstractodesystem.jl:1625
  4.375370 seconds (2.95 M allocations: 213.425 MiB, 1.29% gc time, 99.98% compilation time)</code></pre><p>The resulting mass flow rate required to hit the target <span>$x$</span> position can be seen to be completely wrong.  This is the large impact that compressibility can have when high forces are involved.</p><pre><code class="language-julia hljs">plot(sol_ṁ1; idxs=ṁ, label=&quot;guess&quot;, ylabel=&quot;ṁ&quot;)
plot!(sol_x; idxs=ṁ, label=&quot;solution&quot;)</code></pre><img src="a5075602.svg" alt="Example block output"/><p>If we now solve for case 2, we can study the impact the compressibility derivation</p><pre><code class="language-julia hljs">@mtkbuild odesys_ṁ2 = ODESystem(eqs_ṁ2, t, vars, pars)
prob_ṁ2 = ODEProblem(odesys_ṁ2, u0, (0, t_end))
@time sol_ṁ2 = solve(prob_ṁ2; initializealg=NoInit());</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Warning: Initialization system is overdetermined. 3 equations for 0 unknowns. Initialization will default to using least squares. To suppress this warning pass warn_initialize_determined = false.
└ @ ModelingToolkit ~/.julia/packages/ModelingToolkit/PtnSY/src/systems/diffeqs/abstractodesystem.jl:1625
  4.100711 seconds (2.69 M allocations: 195.261 MiB, 0.85% gc time, 99.98% compilation time)</code></pre><p>As can be seen, a significant error forms between the 2 cases. Plotting first the absolute position.</p><pre><code class="language-julia hljs">plot(sol_x; idxs=x, label=&quot;solution&quot;, ylabel=&quot;x&quot;)
plot!(sol_ṁ1; idxs=x, label=&quot;case 1: r₀&quot;)
plot!(sol_ṁ2; idxs=x, label=&quot;case 2: r&quot;)</code></pre><img src="b422b9a7.svg" alt="Example block output"/><p>And now plotting the difference between case 1 and 2.</p><pre><code class="language-julia hljs">plot(time, (sol_ṁ1(time)[x] .- sol_ṁ2(time)[x])/1e-3,
            label=&quot;x&quot;,
            ylabel=&quot;error (case 1 - case 2) [mm]&quot;,
            xlabel=&quot;t [s]&quot;
        )</code></pre><img src="fc2a1903.svg" alt="Example block output"/><p>Also note the difference in computation.  </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sol_ṁ1.destats</code><code class="nohighlight hljs ansi" style="display:block;">SciMLBase.DEStats
Number of function 1 evaluations:                  452
Number of function 2 evaluations:                  0
Number of W matrix evaluations:                    30
Number of linear solves:                           240
Number of Jacobians created:                       30
Number of nonlinear solver iterations:             0
Number of nonlinear solver convergence failures:   0
Number of fixed-point solver iterations:                     0
Number of fixed-point solver convergence failures:           0
Number of rootfind condition calls:                0
Number of accepted steps:                          30
Number of rejected steps:                          0</code></pre><p>As can be seen, including the detail of full compressibility resulted in more computation: more function evaluations, Jacobians, solves, and steps.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sol_ṁ2.destats</code><code class="nohighlight hljs ansi" style="display:block;">SciMLBase.DEStats
Number of function 1 evaluations:                  528
Number of function 2 evaluations:                  0
Number of W matrix evaluations:                    36
Number of linear solves:                           288
Number of Jacobians created:                       34
Number of nonlinear solver iterations:             0
Number of nonlinear solver convergence failures:   0
Number of fixed-point solver iterations:                     0
Number of fixed-point solver convergence failures:           0
Number of rootfind condition calls:                0
Number of accepted steps:                          34
Number of rejected steps:                          2</code></pre><h3 id="ModelingToolkitStandardLibrary.jl"><a class="docs-heading-anchor" href="#ModelingToolkitStandardLibrary.jl">ModelingToolkitStandardLibrary.jl</a><a id="ModelingToolkitStandardLibrary.jl-1"></a><a class="docs-heading-anchor-permalink" href="#ModelingToolkitStandardLibrary.jl" title="Permalink"></a></h3><p>Now let&#39;s re-create this example using components from the ModelingToolkitStandardLibrary.jl.  It can be shown that by connecting <code>Mass</code> and <code>Volume</code> components that the same exact result is achieved.  The important thing is to pay very close attention to the initial conditions.  </p><pre><code class="language-julia hljs">import ModelingToolkitStandardLibrary.Mechanical.Translational as T
import ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible as IC
import ModelingToolkitStandardLibrary.Blocks as B

using DataInterpolations
mass_flow_fun = LinearInterpolation(sol_x[ṁ], sol_x.t)

include(&quot;volume.jl&quot;) # &lt;-- missing Volume component from MTKSL (will be released in new version)

function MassVolume(; name, dx, drho, dm)

    pars = @parameters begin
        A = 0.01 #m²
        x₀ = 1.0 #m
        M = 10_000 #kg
        g = 9.807 #m/s²
        amp = 5e-2 #m
        f = 15 #Hz
        p_int=M*g/A
        dx=dx
        drho=drho
        dm=dm
    end
    vars = []
    systems = @named begin
        fluid = IC.HydraulicFluid(; density = 876, bulk_modulus = 1.2e9)
        mass = T.Mass(;v=dx,m=M,g=-g)
        vol = Volume(;area=A, x=x₀, p=p_int, dx, drho, dm) # &lt;-- missing Volume component from MTKSL (will be released in new version)
        mass_flow = IC.MassFlow(;p_int)
        mass_flow_input = B.TimeVaryingFunction(;f = mass_flow_fun)
    end

    eqs = [
        connect(mass.flange, vol.flange)
        connect(vol.port, mass_flow.port)
        connect(mass_flow.dm, mass_flow_input.output)
        connect(mass_flow.port, fluid)
    ]

    return ODESystem(eqs, t, vars, pars; systems, name)
end

dx = sol_x[ẋ][1]
drho = sol_x[ṙ][1]
dm = sol_x[ṁ][1]

@mtkbuild odesys = MassVolume(; dx, drho, dm)

prob = ODEProblem(odesys, [], (0, t_end))
sol=solve(prob)

plot(sol; idxs=odesys.vol.x, linewidth=2)
plot!(sol_x; idxs=x)</code></pre><img src="a778103a.svg" alt="Example block output"/><h2 id="Momentum-Balance"><a class="docs-heading-anchor" href="#Momentum-Balance">Momentum Balance</a><a id="Momentum-Balance-1"></a><a class="docs-heading-anchor-permalink" href="#Momentum-Balance" title="Permalink"></a></h2><p>The next challenging aspect of hydraulic modeling is modeling flow through a pipe, which for compressible flow requires resolving the momentum balance equation. To derive the momentum balance we can draw a control volume (<code>cv</code>) in a pipe with area <span>$A$</span>, as shown in the figure below, and apply Newton&#39;s second law.  Across this control volume from <span>$x_1$</span> to <span>$x_2$</span> the pressure will change from <span>$p_1$</span> to <span>$p_2$</span>.  Assuming this is written for an acausal component we put nodes at <span>$p_1$</span> to <span>$p_2$</span> which will have equal mass flow <span>$\dot{m}$</span> entering and exiting the <code>cv</code><sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>.</p><p>Now taking the sum of forces acting on the <code>cv</code> we have the pressure forces at each end as well as the viscous drag force from the pipe wall and the body force from gravity.  The sum of forces is equal to the product of mass (<span>$\rho V$</span>) and flow acceleration (<span>$\dot{u}$</span>).   </p><p class="math-container">\[    \rho V \dot{u} = (p_1 - p_2) A - F_{viscous} + \rho V g\]</p><p>where</p><p class="math-container">\[\begin{align}
F_{viscous} = A \frac{1}{2} \rho u^2 f \frac{L}{d_h}
\end{align}\]</p><p>given <span>$f$</span> is the fully developed flow pipe friction factor for a given shape, <span>$L$</span> is the pipe length, and <span>$d_h$</span> is the pipe hydraulic diameter.</p><div class="admonition is-info"><header class="admonition-header">Project Idea</header><div class="admonition-body"><p>the current implementation of this component in the ModelingToolkitStandardLibrary.jl does not include gravity force for this makes initialization challenging and will take some work to implement.</p></div></div><p>The density <span>$\rho$</span> is an average of <span>$\rho_1$</span> and <span>$\rho_2$</span>.  The velocity is also taken as an average of <span>$u_1$</span> and <span>$u_2$</span></p><p class="math-container">\[u_1 = \frac{\dot{m}}{\rho_1 A}\]</p><p class="math-container">\[u_2 = \frac{\dot{m}}{\rho_2 A}\]</p><p><img src="../../img/momentum_balance.svg" alt="momentum balance"/></p><div class="admonition is-info"><header class="admonition-header">Conservation of Momentum</header><div class="admonition-body"><p>the term <span>$\rho V \dot{u}$</span> introduces what is referd to as fluid inertia.  This is what resolves the pressure wave propagation through a pipe.  A classic wave propagation example in pipes is the &quot;water hammer&quot; effect.  The full derivation for the flow velocity derivative is when deriving in 2 dimensions is </p><p class="math-container">\[\frac{D \text{V}}{Dt} = \frac{\partial \text{V}}{\partial t} + \frac{\partial \text{V}}{\partial x} u + \frac{\partial \text{V}}{\partial z} w\]</p><p>where <span>$\text{V}$</span> is the velocity vector, <span>$u$</span> and <span>$w$</span> are the flow components in <span>$x$</span> and <span>$y$</span> directions.  In the ModelingToolkitStandardLibrary.jl this assumption is taken</p><p class="math-container">\[\rho V \frac{D \text{V}}{Dt} \approx \frac{\partial \dot{m}}{\partial t}\]</p></div></div><div class="admonition is-info"><header class="admonition-header">Project Idea</header><div class="admonition-body"><p>Implement a more detailed Conservation of Momentum using the standard derivation.  One idea is to implement the MethodOfLines.jl to provide the derivative in <span>$x$</span>.</p></div></div><h3 id="Pipe-Component"><a class="docs-heading-anchor" href="#Pipe-Component">Pipe Component</a><a id="Pipe-Component-1"></a><a class="docs-heading-anchor-permalink" href="#Pipe-Component" title="Permalink"></a></h3><p>To model a pipe for compressible flow, we can combine the mass balance and momentum balance components to give both mass storage and flow resistance.  Furthermore, to provide a more accurate model that allows for wave propagation we can discretize the volume connected by node of equal pressure and mass flow.  The diagram below shows an example of discretizing with 3 mass balance volumes and 2 momentum balance resistive elements.  Note: the Modelica Standard Library does this in a different way, by combining the mass and momentum balance in a single base class.  </p><p><img src="../../img/pipe.svg" alt="pipe"/></p><h3 id="Dynamic-Volume-Component"><a class="docs-heading-anchor" href="#Dynamic-Volume-Component">Dynamic Volume Component</a><a id="Dynamic-Volume-Component-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamic-Volume-Component" title="Permalink"></a></h3><p>Both Modelica and SimScape model the actuator component with simply a uniform pressure volume component.  The Modelica library defines the base fluids class around the assumption of constant length (see: <a href="https://elib.dlr.de/11988/1/otter2003-modelica-fluid.pdf">Object-Oriented Modeling of Thermo-Fluid Systems</a>) and therefore adapting to a component that changes length is not possible.  But in cases with long actuators with high dynamics the pressure is not at all uniform, therefore this detail cannot be ignored.  Therefore, adding in the momentum balance to provide flow resistance and fluid inertia are necessary.  The diagram below shows the design of a <code>DynamicVolume</code> component which includes both mass and momentum balance in addition to discretization by volume.  The discretization is similar to the pipe, except the scheme becomes a bit more complicated with the moving wall (<span>$x$</span>).  As the volume shrinks, the control volumes will also shrink, however not in unison, but one at a time.  In this way, as the moving wall closes, the flow will come from the first volume <span>$cv1$</span> and travel thru the full size remaining elements (<span>$cv2$</span>, <span>$cv3$</span>, etc.).  After the first component length drops to zero, the next element will then start to shrink.  </p><p><img src="../../img/volume.svg" alt="volume"/></p><p>This design has a flaw unfortunately, expanding the system for N=3 gives </p><p><img src="../../img/volume_eq1.png" alt="eqs1"/></p><p>What happens when transitioning from one cv to the next, if the moving wall velocity is significant, then an abrupt change occurs due to the <span>$\rho_i \dot{x}$</span> term.  This creates an unstable condition for the solver and results in poor quality/accuracy.  To resolve this problem, the mass balance equation is split into 2 parts: mass balance 1 \&amp; 2 </p><p class="math-container">\[\text{mass balance 1: } \dot{m}/A = \dot{\rho} x\]</p><p class="math-container">\[\text{mass balance 2: } \dot{m}/A = \rho \dot{x}\]</p><p>The below diagram explains how this component is constructed</p><p><img src="../../img/dynamic_volume.svg" alt="dynamic volume"/></p><p>Now the flows are simplified and are more numerically stable.  The acausal connections then handle the proper summing of flows.</p><p><img src="../../img/volume_eq2.png" alt="eqs2"/></p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>See <a href="https://www.mathworks.com/help/simscape/ref/variablehydraulicchamber.html">simscape hydraulic chamber</a>.  Note the deprecation warning moving to isothermal liquid library which uses the correct derivation.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>The Modelica Standard Library combines the mass and momentum balance to the same base class, therefore, mass flow in and out of the <code>cv</code> is not equal, which introduces an additional term to the lhs of the momentum balance:  $ \frac{\partial \left( \rho u^2 A \right) }{\partial x}  $  </li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lecture1/">« Introduction to acausal modeling for physical systems with ModelingToolkit.jl</a><a class="docs-footer-nextpage" href="../lecture3/">Solvers for Non-Stiff Ordinary Differential Equations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Wednesday 8 May 2024 16:46">Wednesday 8 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
