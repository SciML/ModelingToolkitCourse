<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Numerical and Structural Characterizations for DAEs · ModelingToolkit Course</title><meta name="title" content="Numerical and Structural Characterizations for DAEs · ModelingToolkit Course"/><meta property="og:title" content="Numerical and Structural Characterizations for DAEs · ModelingToolkit Course"/><meta property="twitter:title" content="Numerical and Structural Characterizations for DAEs · ModelingToolkit Course"/><meta name="description" content="Documentation for ModelingToolkit Course."/><meta property="og:description" content="Documentation for ModelingToolkit Course."/><meta property="twitter:description" content="Documentation for ModelingToolkit Course."/><meta property="og:url" content="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture7/"/><meta property="twitter:url" content="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture7/"/><link rel="canonical" href="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture7/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelingToolkit Course</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../lecture1/">Introduction to acausal modeling for physical systems with ModelingToolkit.jl</a></li><li><a class="tocitem" href="../lecture2/">Developing high-fidelity models of hydraulic systems</a></li><li><a class="tocitem" href="../lecture3/">Solvers for Non-Stiff Ordinary Differential Equations</a></li><li><a class="tocitem" href="../lecture4/">Numerical Methods for Stiff ODEs and Differential-Algebraic Equations</a></li><li><a class="tocitem" href="../lecture6/">Debugging difficult stiff ODE/DAE models</a></li><li class="is-active"><a class="tocitem" href>Numerical and Structural Characterizations for DAEs</a><ul class="internal"><li><a class="tocitem" href="#Numerical-Integrability-Criterion-for-DAEs"><span>Numerical Integrability Criterion for DAEs</span></a></li><li><a class="tocitem" href="#Structural-Analysis"><span>Structural Analysis</span></a></li><li><a class="tocitem" href="#Structural-Integrability-Criterion-for-DAEs"><span>Structural Integrability Criterion for DAEs</span></a></li><li><a class="tocitem" href="#Consistency-Solvability-Criterion-for-DAEs"><span>Consistency Solvability Criterion for DAEs</span></a></li><li><a class="tocitem" href="#Pantelides-Algorithm"><span>Pantelides Algorithm</span></a></li></ul></li><li><a class="tocitem" href="../lecture8/">Dummy Derivatives and Reordering of Equations</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Numerical and Structural Characterizations for DAEs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Numerical and Structural Characterizations for DAEs</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkitCourse" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkitCourse/blob/main/docs/src/lectures/lecture7.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Numerical-and-Structural-Characterizations-for-DAEs"><a class="docs-heading-anchor" href="#Numerical-and-Structural-Characterizations-for-DAEs">Numerical and Structural Characterizations for DAEs</a><a id="Numerical-and-Structural-Characterizations-for-DAEs-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-and-Structural-Characterizations-for-DAEs" title="Permalink"></a></h1><p>Numerical solvers cannot solve all DAEs. Consider the DAE system</p><p class="math-container">\[F(\{x&#39;, y&#39;, z&#39;\}, \{x, y, z\}, t) = \begin{pmatrix}
    x + y - \sin(t) \\
    z - \sin(t) \\
    z&#39; - \cos(t)
\end{pmatrix} = 0.\]</p><p>Note that the second equation and the third equation are equivalent, and there are not enough constraints to uniquely determine <span>$x$</span> and <span>$y$</span>. Let&#39;s see how numerical solvers and ModelingToolkit behave.</p><pre><code class="language-julia hljs">using DifferentialEquations, Sundials, ModelingToolkit, Plots, LinearAlgebra
using ModelingToolkit: t_nounits as t, D_nounits as D

function f!(out, du, u, p, t)
    # u[1]: x, du[1]: x&#39;
    # u[2]: y, du[2]: y&#39;
    # u[3]: z, du[3]: z&#39;
    out[1] = u[1] + u[2] - sin(t)
    out[2] = u[3] - sin(t)
    out[3] = du[3] - cos(t)
end
prob = DAEProblem(f!, [0.0, 0.0, 1.0], [0.0, 0.0, 0.0], (0, 100.0), differential_vars=[false, false, true])
sol1 = solve(prob, IDA())
sol2 = solve(prob, DFBDF())
println(sol1.retcode, &quot;\t&quot;, sol2.retcode)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
[IDAS ERROR]  IDASolve
  At t = 0 and h = 8.25906e-13, the corrector convergence failed repeatedly or with |h| = hmin.

ConvergenceFailure	Success</code></pre><p>As expected, numerical solvers exit early and they cannot take more than one step. We call such systems non-integrable or singular. Let&#39;s try to use ModelingToolkit to analyze this problem.</p><pre><code class="language-julia hljs">@variables x(t) y(t) z(t)

eqs = [
    x + y ~ sin(t)
    z ~ sin(t)
    D(z) ~ cos(t)
]
@named sys = ODESystem(eqs, t)
sys = complete(sys);
try structural_simplify(sys) catch e println(e) end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ModelingToolkit.InvalidSystemException(&quot;The system is structurally singular! Here are the problematic variables: \n y(t)&quot;)</code></pre><p>We can see that ModelingToolkit also errors, correctly identifying that the system is singular.</p><p>Let&#39;s consider another DAE system</p><p class="math-container">\[F(\{x&#39;, y&#39;\}, \{x, y\}, t) = \begin{pmatrix}
    x - \sin(t) \\
    x&#39; - y
\end{pmatrix} = 0.\]</p><p>If we plug the first equation into the second equation, we have</p><p class="math-container">\[y(t) = (\sin(t))&#39; = \cos(t).\]</p><p>Superficially, we can have the initial condition</p><p class="math-container">\[x&#39;(0) = x(0) = y(0) = y&#39;(0) = 0.\]</p><p>However, if we differentiate the first equation once, we get the hidden constraint</p><p class="math-container">\[x&#39;(t) - \cos(t) = 0.\]</p><p>Thus, the true consistent initial condition is</p><p class="math-container">\[x&#39;(0) = y(0) = 1, x(0) = y&#39;(0) = 0.\]</p><p>Let&#39;s try to solve this simple DAE using a numerical solver.</p><pre><code class="language-julia hljs">function f!(out, du, u, p, t)
    # u[1]: x, du[1]: x&#39;
    # u[2]: y, du[2]: y&#39;
    out[1] = u[1] - sin(t)
    out[2] = du[1] - u[2]
end
prob = DAEProblem(f!, [1, 0.0], [0.0, 1.0], (0, 100pi), differential_vars=[true, false])
sol1 = solve(prob, IDA())
sol2 = solve(prob, DFBDF())
println(&quot;[sol1: &quot;, sol1.retcode, &quot;]&quot;,
&quot;\n&quot;, &quot;[sol2 &quot;, sol2.retcode, &quot;: y(100pi)=&quot;, sol2[2, end], &quot; steps: &quot;, length(sol2.t), &quot;]&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
[IDAS ERROR]  IDASolve
  At t = 16.335 and h = 8.49321e-06, the error test failed repeatedly or with |h| = hmin.

[sol1: Unstable]
[sol2 Success: y(100pi)=1.0001207192054915 steps: 3086]</code></pre><p>To better understand the numerical behavior, let&#39;s analyze the variable step size behavior of the implicit Euler method of the original system. The local truncation error for <span>$y$</span> is</p><p class="math-container">\[\begin{align}
&amp;\text{lte} = \frac{\frac{y(t_n) - y(t_{n-1})}{h_n} - \frac{y(t_{n-1}) - y(t_{n-2})}{h_{n-1}}}
{h_{n} + h_{n-1}} (h_{n} + h_{n-1}) h_n \\
=&amp; \left(\frac{y(t_n) - y(t_{n-1})}{h_n} - \frac{y(t_{n-1}) - y(t_{n-2})}{h_{n-1}}\right) h_n
\\
=&amp; h_n\left(\frac{\frac{\sin(t_{n}) - \sin(t_{n-1})}{h_n} - \frac{\sin(t_{n-1}) - \sin(t_{n-2})}{h_{n-1}}}{h_n} -
\frac{\frac{\sin(t_{n-1}) - \sin(t_{n-2})}{h_{n-1}} - \frac{\sin(t_{n-2}) - \sin(t_{n-3})}{h_{n-2}}}{h_{n-1}}\right)
\\
=&amp;
\frac{\sin(t_{n}) - \sin(t_{n-1})}{h_n} - \frac{\sin(t_{n-1}) - \sin(t_{n-2})}{h_{n-1}} -
h_n
\frac{\frac{\sin(t_{n-1}) - \sin(t_{n-2})}{h_{n-1}} - \frac{\sin(t_{n-2}) - \sin(t_{n-3})}{h_{n-2}}}{h_{n-1}}
\end{align}\]</p><p>Note that when <span>$h_{n} \to 0$</span>, the local truncation error becomes</p><p class="math-container">\[\lim_{h_{n}\to 0} \text{lte} = \frac{\sin(t_{n}) - \sin(t_{n-1})}{h_n} - \frac{\sin(t_{n-1}) - \sin(t_{n-2})}{h_{n-1}}
= \cos(t_{n}) - \frac{\sin(t_{n-1}) - \sin(t_{n-2})}{h_{n-1}}\]</p><p>Note that this in general does not converge to <span>$0$</span>. Thus, numerical solvers could have difficulties in solving this system. Let&#39;s also confirm this numerical behavior by setting the maximum order to <span>$1$</span>.</p><pre><code class="language-julia hljs">solve(prob, DFBDF(max_order=Val(1)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: MaxIters
Interpolation: 1st order linear
t: 999997-element Vector{Float64}:
   0.0
   5.9122259226118514e-8
   3.482873403416318e-7
   9.878837822595348e-7
   1.939419135851393e-6
   3.1005754683177864e-6
   4.38401403708843e-6
   5.734204194967433e-6
   7.119991498544613e-6
   8.52489468131624e-6
   ⋮
 168.01102271497368
 168.0111152896093
 168.01120773239938
 168.0113000435422
 168.01139222321862
 168.01148427162423
 168.01157618895002
 168.01166797537934
 168.01175963109773
u: 999997-element Vector{Vector{Float64}}:
 [0.0, 1.0]
 [5.912225922611848e-8, 0.9999999999999996]
 [3.4828734034162474e-7, 0.9999999999999758]
 [9.878837822593741e-7, 0.9999999999997597]
 [1.939419135850177e-6, 0.9999999999988911]
 [3.1005754683128185e-6, 0.999999999996769]
 [4.384014037074387e-6, 0.9999999999929289]
 [5.7342041949360085e-6, 0.9999999999871271]
 [7.119991498484456e-6, 0.9999999999792661]
 [8.524894681212984e-6, 0.9999999999693221]
 ⋮
 [-0.9979408979309449, -0.06418644985168312]
 [-0.9979468314096368, -0.06409399995040455]
 [-0.9979527479036147, -0.06400168118153492]
 [-0.9979586474619813, -0.06390949332473912]
 [-0.9979645301326023, -0.06381743622441657]
 [-0.9979703959641649, -0.06372550968654046]
 [-0.9979762450049405, -0.0636337135112199]
 [-0.9979820773025937, -0.06354204751854926]
 [-0.99798789290481, -0.06345051151707824]</code></pre><p>Let&#39;s replace the first equation with the differentiated equation and solve it numerically,</p><pre><code class="language-julia hljs">function g!(out, du, u, p, t)
    # u[1]: x, du[1]: x&#39;
    # u[2]: y, du[2]: y&#39;
    out[1] = du[1] - cos(t)
    out[2] = du[1] - u[2]
end
prob = DAEProblem(g!, [1, 0.0], [0.0, 1.0], (0, 100pi), differential_vars=[true, false])
sol1_diff = solve(prob, IDA())
sol2_diff = solve(prob, DFBDF())
println(&quot;[sol1_diff: &quot;, sol1_diff.retcode, &quot;: y(100pi)=&quot;, sol1_diff[2, end], &quot; steps: &quot;, length(sol1_diff.t), &quot;]&quot;,
&quot;\n&quot;, &quot;[sol2_diff &quot;, sol2_diff.retcode, &quot;: y(100pi)=&quot;, sol2_diff[2, end], &quot; steps: &quot;, length(sol2_diff.t), &quot;]&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[sol1_diff: Success: y(100pi)=1.0000000000000002 steps: 1837]
[sol2_diff Success: y(100pi)=1.0 steps: 1130]</code></pre><p>We can see that it takes far fewer iterations to solve the system, and the numerical solution is much closer to the analytical solution <span>$y(100\pi) = 1$</span>. If we check the residual of the original constraint, we get</p><pre><code class="language-julia hljs">plot(sol1_diff.t, sol1_diff[1, :] - sin.(sol1_diff.t), lab = &quot;IDA&quot;)
plot!(sol2_diff.t, sol2_diff[1, :] - sin.(sol2_diff.t), lab = &quot;DFBDF&quot;)</code></pre><img src="f8f9e892.svg" alt="Example block output"/><p>We see a significant numerical drift from the original constraint for both DAE solvers. Again, let&#39;s see how ModelingToolkit does.</p><pre><code class="language-julia hljs">@variables x(t) y(t)
eqs = [
    x ~ sin(t)
    D(x) ~ y
]
@named sys = ODESystem(eqs, t)
sys = complete(sys)
model = structural_simplify(sys)
prob = ODEProblem(model, [x=&gt;0.0, y=&gt;1.0, D(x)=&gt;0.0, D(y)=&gt;1.0], (0, 100pi))
sol = solve(prob, Rodas5P())
println(&quot;[sol: &quot;, sol.retcode, &quot;: y(100pi)=&quot;, sol[y, end], &quot; steps: &quot;, length(sol.t), &quot;]&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[sol: Success: y(100pi)=1.0 steps: 2]</code></pre><pre><code class="language-julia hljs">norm(sol[x, :] - sin.(sol.t))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0</code></pre><p>We can see that ModelingToolkit handles this DAE system perfectly. <span>$y(t)$</span> is completely accurate, the original constraints are satisfied without drift, and the numerical solver needs to take minimal steps. In my following lectures, we will study how ModelingToolkit handles this example system.</p><h2 id="Numerical-Integrability-Criterion-for-DAEs"><a class="docs-heading-anchor" href="#Numerical-Integrability-Criterion-for-DAEs">Numerical Integrability Criterion for DAEs</a><a id="Numerical-Integrability-Criterion-for-DAEs-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-Integrability-Criterion-for-DAEs" title="Permalink"></a></h2><p>There are both differential equations and algebraic equations in acausal models. Thus, a generic acausal model is a system of differential-algebraic equations (DAEs). In general, additional processing steps are required to simulate DAEs. To see this more clearly, we will analyze the implicit Euler algorithm which is the most basic form of both Runge-Kutta and linear multistep methods for DAEs.</p><p>Given the DAE of the form</p><p class="math-container">\[\begin{equation}
0 = F(u&#39;(t), u(t), p, t),
\end{equation}\]</p><p>where <span>$F: (\mathbb{R}^n, \mathbb{R}^n, \mathbb{R}^m, \mathbb{R}) \rightarrow \mathbb{R}^n$</span>. The implicit Euler solves for <span>$u(t+h)$</span> from</p><p class="math-container">\[\begin{equation}
0 = F\left(\frac{\hat{u}(t+h) - u(t)}{h},\; \hat{u}(t+h),\; p,\; t+h\right),
\end{equation}\]</p><p>with fixed <span>$t, h, p$</span>, and <span>$u(t)$</span>.</p><p>Numerically, we use Newton&#39;s method to solve potentially nonlinear equations by iteratively solving the best approximating linear equations (i.e., the Jacobian of the nonlinear function with respect to the unknowns) to refine an initial guess. By the chain rule, we have</p><p class="math-container">\[\begin{equation}
\frac{\partial F}{\partial u} = \frac{1}{h}F_{u&#39;} + F_{u}.
\end{equation}\]</p><p>The Newton iteration is then</p><p class="math-container">\[\begin{align}
\frac{\partial F}{\partial u} \Delta^{[i]} &amp;= F\left(\frac{\hat{u}^{[i]}(t+h) - u(t)}{h}, \hat{u}^{[i]}(t+h), p, t+h\right) \\
\hat{u}^{[i+1]} &amp;= \hat{u}^{[i]} - \Delta^{[i]},
\end{align}\]</p><p>where <span>$\{\cdot\}^{[i]}$</span> denotes the iteration variable at the <span>$i$</span>-th iteration. Thus, for the implicit Euler algorithm to work, <span>$\lambda F_{u&#39;} + F_{u}$</span> has to be non-singular for sufficiently small <span>$\lambda\in\mathbb{R}$</span>. In fact, this conclusion holds for all linear multistep methods and Runge-Kutta methods, that is, they all need to solve an iteration matrix of the form <span>$\lambda F_{u&#39;} + F_{u}$</span>. Curious readers can check this <a href="https://github.com/SciML/DiffEqDevMaterials/blob/master/newton/output/main.pdf">development documentation</a> on how the Newton iteration is set up for all the other cases. Formally, the <em>numerical integrability criterion</em> is</p><p class="math-container">\[\begin{equation}
\forall u, u&#39;, \exists \lambda &gt; 0, \det(\lambda F_{u&#39;} + F_{u}) \ne 0.
\end{equation}\]</p><h2 id="Structural-Analysis"><a class="docs-heading-anchor" href="#Structural-Analysis">Structural Analysis</a><a id="Structural-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Structural-Analysis" title="Permalink"></a></h2><p>The above criterion is too hard to verify at compile time, since we do not yet know the exact values to solve the DAE. To make it computationally easier to check, we can change the <span>$\forall$</span> to <span>$\exists$</span>, which is</p><p class="math-container">\[\begin{equation}
\exists u, u&#39;, \lambda &gt; 0, \det(\lambda F_{u&#39;} + F_{u}) \ne 0,
\end{equation}\]</p><p>so that we only need to validate a single instance. To make the criterion even easier to check, we introduce the following definitions.</p><div class="admonition is-category-definition"><header class="admonition-header">Sparse Matrix</header><div class="admonition-body"><p>A sparse matrix is a matrix that could contain structural zeros. Structural zeros are entries that are zero by construction denoted by <span>$\hat{0}$</span>. We call an entry structural nonzero if it is not a structural zero. We also define <span>$\mathbb{F}:=\mathbb{R}\cup\hat{0}$</span>.</p></div></div><div class="admonition is-category-definition"><header class="admonition-header">Incidence Matrix</header><div class="admonition-body"><p>A incidence matrix of the symbolically defined function <span>$f: \mathbb{R}^n \to \mathbb{R}^m$</span> with respect to the indexed set of variables <span>$\{x_{j} \}$</span> is a sparse matrix <span>$M\in\mathbb{F}^{m \times n}$</span> defined by</p><p class="math-container">\[\begin{equation}
M_{ij} := \begin{cases}
1, &amp; \text{if } x_{j} \text{ appears in the expression for computing the
$i$-th output of $f$, i.e. } f(\{x_{j}\})_i \\
\hat{0}, &amp; \text{else}
\end{cases}.
\end{equation}\]</p><p>We use <span>$\mathfrak{I}(f, \{x_j\}) := M$</span> to denote the incidence matrix of <span>$f$</span> with respect to <span>$\{x_j\}$</span>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Structural Zeros</header><div class="admonition-body"><p>For convenience, we will simply use <span>$0$</span> and <span>$\mathbb{R}$</span> when structural zeros are obvious in context.</p></div></div><div class="admonition is-category-definition"><header class="admonition-header">Structurally Non-singular</header><div class="admonition-body"><p>A sparse matrix <span>$A$</span> is structurally non-singular if and only if there exists a set of real numbers when it replaces all the structural nonzero entries, the new matrix <span>$\mathfrak{N}(A)$</span> is numerically non-singular.</p></div></div><div class="admonition is-category-example"><header class="admonition-header">Structurally Non-singular</header><div class="admonition-body"><ul><li><span>$A = \begin{pmatrix} 1 &amp; 1 \\ 1 &amp; 1 \end{pmatrix}$</span> is structurally non-singular but numerically singular because we can replace a nonzero such that we get <span>$\mathfrak{N}(A) = \begin{pmatrix} 1 &amp; 10 \\ 1 &amp; 1 \end{pmatrix}$</span> which is numerically non-singular.</li><li><span>$A = \begin{pmatrix} 1 &amp; 2 &amp; 3\\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \end{pmatrix}$</span> is structurally non-singular but numerically singular because we can replace nonzeros such that we get <span>$\mathfrak{N}(A) = \begin{pmatrix} 10 &amp; 2 &amp; 3\\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 10 \end{pmatrix}$</span> which is numerically non-singular.</li><li><span>$\begin{pmatrix} 1 &amp; 1 \\ \hat{0} &amp; \hat{0} \end{pmatrix}$</span> is structurally singular because <span>$\begin{pmatrix} a &amp; b \\ 0 &amp; 0 \end{pmatrix}$</span> is numerically singular for all real <span>$a$</span> and <span>$b$</span>.</li></ul></div></div><p>Although structurally non-singular is a strictly weaker condition than numerically non-singular, checking it seems to be more difficult on the surface because we need to come up with an example that is numerically non-singular. However, the following powerful theorem gives us a dramatically simpler way of checking if a sparse matrix is structurally non-singular.</p><div class="admonition is-info"><header class="admonition-header">Structurally Non-singularity Theorem</header><div class="admonition-body"><p>A square sparse matrix <span>$A$</span> is structurally non-singular if and only if there exist permutation matrices <span>$P$</span> and <span>$Q$</span> such that all the diagonal entries of <span>$PA$</span> and <span>$AQ$</span> are structural nonzeros.</p><h5>Proof:</h5><ul><li><span>$\Leftarrow$</span>: Suppose <span>$A$</span> is a square sparse matrix such that all diagonal entries of <span>$PA$</span> and <span>$AQ$</span> are structural nonzeros, where <span>$P$</span> and <span>$Q$</span> are permutation matrices. Let <span>$\mathfrak{N}(A) = P^{-1}I$</span> or <span>$\mathfrak{N}(A) = IQ^{-1}$</span> which are numerically non-singular. Thus, <span>$A$</span> is structurally non-singular.</li><li><span>$\Rightarrow$</span>: Suppose <span>$\hat{A}\in\mathbb{R}^{n\times n}$</span> is a square sparse matrix that is structurally non-singular. Let <span>$A = \mathfrak{N} (\hat{A})$</span>, we have <span>$\det(A) \ne 0$</span>. Expanding the definition of the determinant, we have<p class="math-container">\[\begin{equation}
\det(A)=\sum_{\sigma \in S_{n}}\operatorname{sgn}(\sigma)\prod_{i = 1}^n
a_{i,\sigma(i)} \ne 0,
\end{equation}\]</p>where <span>$S_n$</span> denotes the set of all permutations of the set <span>$\{1, 2, ..., n\}$</span> (the symmetric group of order <span>$n$</span>). For <span>$\det(A)\ne 0$</span>, there must exist one <span>$\sigma\in S_n$</span> such that <span>$\prod_{i = 1}^n a_{i,\sigma (i)} \ne 0$</span>. Note that we also have <span>$\prod_{i = 1}^n a_{i,\sigma (i)} = \prod_{i = 1}^n a_{\sigma^{-1}(i), i}$</span>. Thus, the desired <span>$Q$</span> is the permutation matrix corresponding to <span>$\sigma$</span>, and the desired <span>$P$</span> is <span>$Q^{-1}$</span>. <span>$\blacksquare$</span></li></ul></div></div><p>The above condition is equivalent with checking the existence of a perfect matching on the induced bipartite graph of the incidence matrix, and it can be efficiently solved by using the augmenting path algorithm to find the maximum cardinality matching.</p><div class="admonition is-category-definition"><header class="admonition-header">Induced Bipartite Graph</header><div class="admonition-body"><p>Given an incidence matrix <span>$A\in\mathbb{R}^{m\times n}$</span> the induced bipartite graph <span>$(U, V, E)$</span> is a tuple of a set of source vertices <span>$U = \{1, 2, ..., m\}$</span>, a set of destination vertices <span>$V\in \{1, 2, ..., n\}$</span>, and edges between them <span>$E \subseteq U\times V$</span> defined by</p><p class="math-container">\[\begin{equation}
E = \{(i, j): A_{i,j} \ne 0\}.
\end{equation}\]</p><p>Similarly, the induced bipartite graph of a sparse matrix is the induced bipartite graph of its induced incidence matrix.</p></div></div><div class="admonition is-category-definition"><header class="admonition-header">Bipartite Matching</header><div class="admonition-body"><p>A matching of a bipartite graph <span>$(U, V, E)$</span> is a set <span>$M \subseteq E$</span> where every vertex in <span>$U$</span> and <span>$V$</span> can appear at most once in <span>$M$</span>. A matching <span>$M$</span> is perfect if <span>$|M| = |U| = |V|$</span>. We call an edge in a matching matched, otherwise, free. It is often more convenient to interpret matching as the function <span>$M: U \to (V \cup \emptyset)$</span> defined as</p><p class="math-container">\[\begin{equation}
m(i) = \begin{cases}
    j, &amp; \text{if } (i, j) \in E \\
    \emptyset, &amp; \text{else}
\end{cases}.
\end{equation}\]</p></div></div><div class="admonition is-info"><header class="admonition-header">Structural Non-singularity and Perfect Matching Equivalence Theorem</header><div class="admonition-body"><p>A sparse matrix <span>$A\in\mathbb{R}^{m\times n}$</span> is structurally non-singular if and only if its induced bipartite graph has a perfect matching.</p><h5>Proof:</h5><ul><li><span>$\Leftarrow$</span>: Suppose <span>$A\in\mathbb{R}^{m\times n}$</span> is a structurally non-singular sparse matrix, then <span>$m=n$</span> and there exists a row permutation <span>$\sigma\in S_n$</span> such that <span>$\forall i\in\{1, ..., n\}, A_{\sigma(i), i} \ne 0$</span>. Note that <span>$\sigma$</span> is a perfect matching.</li><li><span>$\Rightarrow$</span>: Suppose the induced bipartite graph <span>$(U, V, E)$</span> of <span>$A\in\mathbb{R}^{m\times n}$</span> has a perfect bipartite matching <span>$\sigma$</span>, then <span>$|U| = |V| = |\sigma| = m = n$</span> and <span>$\sigma\in S_n$</span>. In particular, <span>$\forall i\in\{1, ..., n\}, A_{\sigma(i), i} \ne 0$</span>. Hence, <span>$A$</span> is structurally non-singular. <span>$\blacksquare$</span></li></ul></div></div><div class="admonition is-category-definition"><header class="admonition-header">Augmenting Path</header><div class="admonition-body"><p>Given a particular matching, an alternating path is a sequence of adjacent edges that alternate between being matched and free. In particular, an augmenting path is a alternating path that starts and ends with free vertices.</p></div></div><div class="admonition is-info"><header class="admonition-header">Bipartite Graph Maximum Cardinality Matching Theorem</header><div class="admonition-body"><p>A matching <span>$M$</span> of a bipartite graph has maximum cardinality matching if and only if there is no augmenting path with respect to <span>$M$</span>.</p><h5>Proof:</h5><ul><li><span>$\Rightarrow$</span>: We will show this using proof by contrapositive. Suppose a bipartite graph has a matching <span>$M$</span> and an augmenting path <span>$A$</span>. Let <span>$\hat{M} = M \bigtriangleup A := (M \setminus A)\cup (A\setminus M)$</span>, then <span>$\hat{M}$</span> is a matching and <span>$|\hat{M}| = |M| + 1$</span>. Thus, <span>$M$</span> is not a maximum cardinality matching.</li><li><span>$\Leftarrow$</span>: We will should this using proof by contrapositive, again. Suppose a bipartite graph <span>$(U, V, E)$</span> has a non-maximum cardinality matching <span>$B$</span>, we want to seek an augmenting path. Let <span>$A$</span> be a maximum cardinality matching. We claim <span>$P = A\bigtriangleup B$</span> contains at least one augmenting path by the following arguments<ul><li>Since all edges of <span>$P$</span> come from two matchings, by the definition of a matching, each vertex can have at most two edges. Therefore, <span>$P$</span> contains either paths or cycles, and such segments are alternating between <span>$A$</span> and <span>$B$</span>.</li><li><span>$|P\cap A| &gt; |P\cap B|$</span>. Note that <span>$P\cap A = ((A\setminus B) \cup (B\setminus A)) \cap A = ((A\setminus B)\cap A)\cup ((B\setminus A) \cap A) = (A\setminus B)$</span>, and similarly <span>$|P\cap B| = |B\setminus A|$</span>. Thus, <span>$|P\cap A| = |A| - |A \cap B|$</span> and <span>$|P\cap B| = |B| - |A \cap B|$</span>. By the maximality of <span>$A$</span>, we know <span>$|A|&gt;|B|$</span>. Therefore, <span>$|P\cap A| &gt; |P\cap B|$</span>.</li><li>By the previous argument, there must be at least one connected component such that it contains more edges in <span>$A$</span> than <span>$B$</span>. Since all cycles in <span>$P$</span> must be even length and alternating, such segment can only be a path, and in particular, an augmenting path with respect to <span>$B$</span>.</li></ul><span>$\blacksquare$</span></li></ul></div></div><div class="admonition is-info"><header class="admonition-header">Augmenting Path Algorithm</header><div class="admonition-body"><p>Input: bipartite graph <span>$g = (U, V, E)$</span>, a vertex <span>$\text{vsrc} \in U$</span>, and a partial matching.</p><p>Output: return a boolean indicating the existence of an augmenting path, and if one is present, use the augmenting path to increase the cardinality of the partial matching by exactly one.</p><p>In ModelingToolkit, there are the <code>𝑠neighbors(g, i)</code> function that returns a sorted list containing <span>$\{j: (i, j) \in E\}$</span>, and the <code>𝑑neighbors(g, j)</code> function that returns a sorted list containing <span>$\{i: (i, j) \in E\}$</span>. ModelingToolkit also encodes matching <code>M</code> using the <code>m::Matching</code> structure, let <code>j = m[i]</code>, it holds that <code>j::Int</code> if and only if <span>$(i, j) \in M$</span> and <code>j::Unassigned</code> if and only if <span>$(i, j) \not\in M$</span>. It following code comes directly from ModelingToolkit.</p><pre><code class="language-julia hljs">function construct_augmenting_path!(matching::Matching, g::BipartiteGraph, vsrc, dstfilter,
        dcolor = falses(ndsts(g)), scolor = nothing)
    scolor === nothing || (scolor[vsrc] = true)

    # if a `vdst` is unassigned and the edge `vsrc &lt;=&gt; vdst` exists
    for vdst in 𝑠neighbors(g, vsrc)
        if dstfilter(vdst) &amp;&amp; matching[vdst] === unassigned
            matching[vdst] = vsrc
            return true
        end
    end

    # for every `vsrc` such that edge `vsrc &lt;=&gt; vdst` exists and `vdst` is uncolored
    for vdst in 𝑠neighbors(g, vsrc)
        (dstfilter(vdst) &amp;&amp; !dcolor[vdst]) || continue
        dcolor[vdst] = true
        if construct_augmenting_path!(matching, g, matching[vdst], dstfilter, dcolor,
            scolor)
            matching[vdst] = vsrc
            return true
        end
    end
    return false
end</code></pre><p>Note that the augmenting path algorithm never removes any matched vertices in <span>$U$</span>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Augmenting Path Algorithm for Finding a Maximum Cardinality Matching</header><div class="admonition-body"><p>Input: bipartite graph <span>$g = (U, V, E)$</span>.</p><p>Output: matching <span>$M$</span>.</p><p>The following code comes directly from ModelingToolkit. Note that <code>𝑠vertices(g)</code> returns <code>1:n</code> where <span>$n=|U|$</span>.</p><pre><code class="language-julia hljs">function maximal_matching(g::BipartiteGraph, srcfilter = vsrc -&gt; true,
        dstfilter = vdst -&gt; true, ::Type{U} = Unassigned) where {U}
    matching = Matching{U}(ndsts(g))
    foreach(Iterators.filter(srcfilter, 𝑠vertices(g))) do vsrc
        construct_augmenting_path!(matching, g, vsrc, dstfilter)
    end
    return matching
end</code></pre><p>Given that the augmenting path algorithm never removes any matched vertices in <span>$U$</span>, and if no augmenting path starts in vertex <span>$i\in U$</span>, then <span>$i$</span> will never be matched using the augmenting path algorithm. It is sufficient to run the augmenting path algorithm for all vertices in <span>$U$</span> by the Bipartite Graph Maximum Cardinality Matching Theorem.</p></div></div><h2 id="Structural-Integrability-Criterion-for-DAEs"><a class="docs-heading-anchor" href="#Structural-Integrability-Criterion-for-DAEs">Structural Integrability Criterion for DAEs</a><a id="Structural-Integrability-Criterion-for-DAEs-1"></a><a class="docs-heading-anchor-permalink" href="#Structural-Integrability-Criterion-for-DAEs" title="Permalink"></a></h2><p>To utilize the structural analysis framework, we need weaken the integrability criterion further from</p><p class="math-container">\[\begin{equation}
\exists u, u&#39;, \lambda &gt; 0, \det(\lambda F_{u&#39;} + F_{u}) \ne 0,
\end{equation}\]</p><p>to the <em>structural integrability criterion</em></p><p class="math-container">\[\begin{equation}
\mathfrak{I}(\mathfrak{I}(F, \{u_i&#39;\}) + \mathfrak{I}(F, \{u_i\})) \text{ is
structurally non-singular.}
\end{equation}\]</p><h2 id="Consistency-Solvability-Criterion-for-DAEs"><a class="docs-heading-anchor" href="#Consistency-Solvability-Criterion-for-DAEs">Consistency Solvability Criterion for DAEs</a><a id="Consistency-Solvability-Criterion-for-DAEs-1"></a><a class="docs-heading-anchor-permalink" href="#Consistency-Solvability-Criterion-for-DAEs" title="Permalink"></a></h2><p>Consider the DAE system</p><p class="math-container">\[\begin{equation}
F(\{x&#39;, y&#39;\}, \{x, y\}, t) =
\begin{pmatrix}
f_1(x, t) \\
f_2(x&#39;, y&#39;, t)
\end{pmatrix} = 0,
\end{equation}\]</p><p>where <span>$f_1$</span> and <span>$f_2$</span> are some arbitrary smooth functions. We have</p><p class="math-container">\[\begin{equation}
\mathfrak{I}(F, \{x&#39;, y&#39;\}) = \begin{pmatrix}
0 &amp; 0 \\
1 &amp; 1
\end{pmatrix},\quad
\mathfrak{I}(F, \{x, y\}) = \begin{pmatrix}
1 &amp; 0 \\
0 &amp; 0
\end{pmatrix}.
\end{equation}\]</p><p>Thus,</p><p class="math-container">\[\begin{equation}
\mathfrak{I}(\mathfrak{I}(F, \{u_i&#39;\}) + \mathfrak{I}(F, \{u_i\})) =
\begin{pmatrix}
1 &amp; 0 \\
1 &amp; 1
\end{pmatrix}
\end{equation}\]</p><p>is structurally non-singular, which means that the DAE system is structurally integrable.</p><p>However, solving for a consistent initial condition <span>$u(t_0)$</span> and <span>$u&#39;(t_0)$</span> is not as simple as simply solving for <span>$F(u&#39;(t_0), u(t_0), t_0) = 0$</span>. Because given a general DAE in the form of <span>$F(u&#39;, u, p, t) = 0$</span>, all its total time derivatives are also valid constraints, i.e.</p><p class="math-container">\[\begin{align}
F(u&#39;, u, p, t) &amp;= 0 \\
F&#39;(u&#39;&#39;, u&#39;, u, p, t) &amp;= 0  \\
F&#39;&#39;(u&#39;&#39;&#39;, u&#39;&#39;, u&#39;, u, p, t) &amp;= 0 \\
    &amp;\vdots \nonumber
\end{align}\]</p><p>For the above example, we can differentiate the <span>$f_1$</span> equation once and get</p><p class="math-container">\[\begin{equation}
\begin{pmatrix}
f&#39;_1(x&#39;, t) \\
f_2(x&#39;, y&#39;, t)
\end{pmatrix} = 0.
\end{equation}\]</p><p>Note that differentiating <span>$f&#39;_1$</span> and <span>$f_2$</span> further is not necessary because we will not get additional constraints for the states (<span>$u(t)$</span> and <span>$u&#39;(t)$</span>) of the DAE system.</p><p>We need a more systematic way of knowing when differentiating <span>$F$</span> does not add new &quot;information&quot; into the system. First, let&#39;s develop a characterization on the variables. Let <span>$z=\{z_i\}$</span> be the set of the highest order derivative variables, and let <span>$\lambda = \{\lambda_i\}$</span> contain the rest of the variables. Note that <span>$z$</span> and <span>$\lambda$</span> must be disjoint. Therefore, DAEs can then be written as</p><p class="math-container">\[0 = F(z, \lambda, p, t) \\\]</p><p>Differentiating the above equation gives us</p><p class="math-container">\[F_z z&#39; + F_\lambda \lambda&#39; + F_t = 0\]</p><p>Note that <span>$z&#39; = \{z&#39;_i\}$</span> contains all the new terms generated by the differentiation, as it contains variables with higher order derivatives than before. Rearranging terms, we get</p><p class="math-container">\[F_z z&#39; = -F_\lambda \lambda&#39; - F_t.\]</p><p>When <span>$F_z$</span> is non-singular, we can use old terms to explicitly solve for <span>$z&#39;$</span>, so we don&#39;t generate genuinely new equations, and this is the <em>numerical consistency solvability criterion</em>. Therefore, we only add new equations to the system if and only if <span>$F_z$</span> is singular. It&#39;s wasteful to differentiate the entire system until the matrix is invertible; we can differentiate a minimal subset of equations to make <span>$F_z$</span> non-singular.</p><p>Similarly, the <em>structural consistency solvability criterion</em> is then</p><p class="math-container">\[\mathfrak{I}(F, z) \text{ is structurally non-singular.}\]</p><p>For the above system, the differentiated system has</p><p class="math-container">\[\mathfrak{I}(F, \{x&#39;, y&#39;\}) = \begin{pmatrix}
1 &amp; 0 \\
1 &amp; 1
\end{pmatrix},\]</p><p>which is structurally non-singular. Thus, the differentiated system satisfies the structural consistency solvability criterion.</p><p>Note that the sparsity pattern of <span>$\mathfrak{I}(\mathfrak{I}(F, \{u_i&#39;\}) + \mathfrak{I}(F, \{u_i\}))$</span> is always a subset of <span>$\mathfrak{I}(F, z)$</span> for arbitrary systems.</p><div class="admonition is-info"><header class="admonition-header">Structural Consistency Solvability Theorem</header><div class="admonition-body"><p>Structural consistency solvability implies structural integrability. Moreover, if a DAE system is not integrable, then structural consistency solvability cannot be achieved by differentiating any equation any number of times. <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup></p></div></div><h2 id="Pantelides-Algorithm"><a class="docs-heading-anchor" href="#Pantelides-Algorithm">Pantelides Algorithm</a><a id="Pantelides-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Pantelides-Algorithm" title="Permalink"></a></h2><p>We can use the Pantelides algorithm <sup class="footnote-reference"><a id="citeref-Pantelides1988" href="#footnote-Pantelides1988">[Pantelides1988]</a></sup> to efficiently convert a DAE system that has structural integrability to a system with structural consistency solvability, even if it initially lacks this property.</p><p>The gist of the Pantelides algorithm is that, we can try to find an augmenting path for all equation (source) vertices on the sub-graph that only contains highest differentiated variable (destination) vertices, and if there is no augmenting path starting at an equation vertex, then we can differentiate all the equations and variables reached in the augmenting path search until there is an augmenting path starting at the differentiated equation vertex. Note that if we differentiate an equation in the form of <span>$f(x, y, ...)$</span> we get</p><p class="math-container">\[\frac{d}{dt}f(x, y, ...) = \frac{\partial f}{\partial x}x&#39; + \frac{\partial f}{\partial y}y&#39; + ...\]</p><p>Thus, the incidence of the differentiated equation is trivial to compute.</p><p>The following code comes directly from ModelingToolkit.</p><pre><code class="language-julia hljs">function pantelides!(state::TransformationState; finalize = true, maxiters = 8000)
    @unpack graph, solvable_graph, var_to_diff, eq_to_diff = state.structure
    neqs = nsrcs(graph)
    nvars = nv(var_to_diff)
    vcolor = falses(nvars)
    ecolor = falses(neqs)
    var_eq_matching = Matching(nvars)
    neqs′ = neqs
    nnonemptyeqs = count(eq -&gt; !isempty(𝑠neighbors(graph, eq)) &amp;&amp; eq_to_diff[eq] === nothing,
        1:neqs′)

    varwhitelist = computed_highest_diff_variables(state.structure)

    if nnonemptyeqs &gt; count(varwhitelist)
        throw(InvalidSystemException(&quot;System is structurally singular&quot;))
    end

    for k in 1:neqs′
        eq′ = k
        eq_to_diff[eq′] === nothing || continue
        isempty(𝑠neighbors(graph, eq′)) &amp;&amp; continue
        pathfound = false
        # In practice, `maxiters=8000` should never be reached, otherwise, the
        # index would be on the order of thousands.
        for iii in 1:maxiters
            # run matching on (dx, y) variables
            #
            # the derivatives and algebraic variables are zeros in the variable
            # association list
            resize!(vcolor, nvars)
            fill!(vcolor, false)
            resize!(ecolor, neqs)
            fill!(ecolor, false)
            pathfound = construct_augmenting_path!(var_eq_matching, graph, eq′,
                v -&gt; varwhitelist[v], vcolor, ecolor)
            pathfound &amp;&amp; break # terminating condition
            if is_only_discrete(state.structure)
                error(&quot;The discrete system has high structural index. This is not supported.&quot;)
            end
            for var in eachindex(vcolor)
                vcolor[var] || continue
                if var_to_diff[var] === nothing
                    # introduce a new variable
                    nvars += 1
                    var_diff = var_derivative!(state, var)
                    push!(var_eq_matching, unassigned)
                    push!(varwhitelist, false)
                    @assert length(var_eq_matching) == var_diff
                end
                varwhitelist[var] = false
                varwhitelist[var_to_diff[var]] = true
            end

            for eq in eachindex(ecolor)
                ecolor[eq] || continue
                # introduce a new equation
                neqs += 1
                eq_derivative!(state, eq)
            end

            for var in eachindex(vcolor)
                vcolor[var] || continue
                # the newly introduced `var`s and `eq`s have the inherits
                # assignment
                var_eq_matching[var_to_diff[var]] = eq_to_diff[var_eq_matching[var]]
            end
            eq′ = eq_to_diff[eq′]
        end # for _ in 1:maxiters
        pathfound ||
            error(&quot;maxiters=$maxiters reached! File a bug report if your system has a reasonable index (&lt;100), and you are using the default `maxiters`. Try to increase the maxiters by `pantelides(sys::ODESystem; maxiters=1_000_000)` if your system has an incredibly high index and it is truly extremely large.&quot;)
    end # for k in 1:neqs′

    finalize &amp;&amp; for var in 1:ndsts(graph)
        varwhitelist[var] &amp;&amp; continue
        var_eq_matching[var] = unassigned
    end
    return var_eq_matching
end</code></pre><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Curious readers can read the original Pantelides paper for ideas to prove this.</li><li class="footnote" id="footnote-Pantelides1988"><a class="tag is-link" href="#citeref-Pantelides1988">Pantelides1988</a>Pantelides, Constantinos C. &quot;The consistent initialization of differential-algebraic systems.&quot; SIAM Journal on scientific and statistical computing 9.2 (1988): 213-231.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lecture6/">« Debugging difficult stiff ODE/DAE models</a><a class="docs-footer-nextpage" href="../lecture8/">Dummy Derivatives and Reordering of Equations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Wednesday 17 July 2024 16:45">Wednesday 17 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
