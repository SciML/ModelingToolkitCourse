<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Dummy Derivatives and Reordering of Equations · ModelingToolkit Course</title><meta name="title" content="Dummy Derivatives and Reordering of Equations · ModelingToolkit Course"/><meta property="og:title" content="Dummy Derivatives and Reordering of Equations · ModelingToolkit Course"/><meta property="twitter:title" content="Dummy Derivatives and Reordering of Equations · ModelingToolkit Course"/><meta name="description" content="Documentation for ModelingToolkit Course."/><meta property="og:description" content="Documentation for ModelingToolkit Course."/><meta property="twitter:description" content="Documentation for ModelingToolkit Course."/><meta property="og:url" content="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture8/"/><meta property="twitter:url" content="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture8/"/><link rel="canonical" href="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture8/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelingToolkit Course</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../syllabus/">Syllabus</a></li><li><a class="tocitem" href="../lecture1/">Introduction to acausal modeling for physical systems with ModelingToolkit.jl</a></li><li><a class="tocitem" href="../lecture2/">Developing high-fidelity models of hydraulic systems</a></li><li><a class="tocitem" href="../lecture3/">Solvers for Non-Stiff Ordinary Differential Equations</a></li><li><a class="tocitem" href="../lecture4/">Numerical Methods for Stiff ODEs and Differential-Algebraic Equations</a></li><li><a class="tocitem" href="../lecture6/">Debugging difficult stiff ODE/DAE models</a></li><li><a class="tocitem" href="../lecture7/">Numerical and Structural Characterizations for DAEs</a></li><li class="is-active"><a class="tocitem" href>Dummy Derivatives and Reordering of Equations</a><ul class="internal"><li><a class="tocitem" href="#Demo"><span>Demo</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Dummy Derivatives and Reordering of Equations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Dummy Derivatives and Reordering of Equations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkitCourse" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkitCourse/blob/main/docs/src/lectures/lecture8.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Dummy-Derivatives-and-Reordering-of-Equations"><a class="docs-heading-anchor" href="#Dummy-Derivatives-and-Reordering-of-Equations">Dummy Derivatives and Reordering of Equations</a><a id="Dummy-Derivatives-and-Reordering-of-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Dummy-Derivatives-and-Reordering-of-Equations" title="Permalink"></a></h1><p>Consider a single pendulum in the Cartesian coordinate</p><p class="math-container">\[\begin{align}
&amp;e_1: x&#39;&#39; - \lambda x = 0 \\
&amp;e_2: y&#39;&#39; - (\lambda y - g) = 0 \\
&amp;e_3: x^2 + y^2 - 1 = 0.
\end{align}\]</p><p>Its incidence matrix with respect to the highest differentiated variables <span>$\{x&#39;&#39;, y&#39;&#39;, \lambda\}$</span> is</p><p class="math-container">\[\begin{pmatrix}
1 &amp; 0 &amp; 1 \\
0 &amp; 1 &amp; 1 \\
0 &amp; 0 &amp; 0
\end{pmatrix}\]</p><p>We can obtain a structurally non-singular incidence matrix if we were to differentiate the last equation two times and get:</p><p class="math-container">\[\begin{pmatrix}
1 &amp; 0 &amp; 1 \\
0 &amp; 1 &amp; 1 \\
1 &amp; 1 &amp; 0
\end{pmatrix}\]</p><p>The perfect matching <span>$m$</span> can be <span>$1 \mapsto 1, 2 \mapsto 3, 3 \mapsto 2$</span>. According to the perfect matching, we need to interchange the second and the third row of the incidence matrix to move all nonzero entries to the diagonal.</p><p class="math-container">\[\begin{pmatrix}
1 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 1
\end{pmatrix}\]</p><p>The matching also informs us that we can attempt to solve the highest order differentiated variables by the assignment</p><p class="math-container">\[\begin{align}
&amp;e_1: \lambda \mapsto x&#39;&#39; \\
&amp;e_3: x&#39;&#39; \mapsto y&#39;&#39; \\
&amp;e_2: y&#39;&#39; \mapsto \lambda
\end{align}\]</p><p>Hence, we have the following dependency graph</p><pre><code class="language-mermaid hljs">flowchart LR
    A(x&#39;&#39;) --&gt; B(λ)
    C(y&#39;&#39;) --&gt; A
    B --&gt; C</code></pre><p>Since all the variables are in one strongly connected component, unfortunately, we cannot break the nonlinear system into smaller subsystems. Let&#39;s implement the differentiated system and solve it numerically.</p><pre><code class="language-julia hljs">using ModelingToolkit, OrdinaryDiffEq, Plots, LinearAlgebra

function pend_manual(out, u, g, t)
    ẋ, x, ẏ, y, λ = u
    ẍ = out[1] = λ * x
    out[2] = ẋ
    ÿ = out[3] = λ * y - g
    out[4] = ẏ
    # x^2 + y^2 - 1
    # x&#39; x + y&#39; y
    # x&#39;&#39; x + x&#39;^2 + y&#39;&#39; y + y&#39;^2
    out[5] = ẍ*x + ẋ^2 + ÿ*y + ẏ^2
end
fun = ODEFunction(pend_manual, mass_matrix = Diagonal([1, 1, 1, 1, 0]))
prob = ODEProblem(fun, [0, 1, 0, 0, 0.0], (0, 500.0), 1)
sol = solve(prob, Rodas5P())
plot(sol.t, (@. sol[2, :]^2 + sol[4, :]^2), lab = &quot;d0&quot;)</code></pre><img src="b8bf0241.svg" alt="Example block output"/><pre><code class="language-julia hljs">plot(sol.t, (@. sol[1, :] * sol[2, :] + sol[3, :] * sol[4, :]), lab = &quot;d1&quot;)</code></pre><img src="58f2d3ff.svg" alt="Example block output"/><p>Note that the original constraints are not satisfied and, even worse, the residual drifts over time. Let&#39;s plot the pendulum in the Cartesian coordinate over time.</p><pre><code class="language-julia hljs">plot(sol, idxs = (2, 4), lab = &quot;pendulum&quot;, aspect_ratio = 1)</code></pre><img src="0bd19d61.svg" alt="Example block output"/><p>The drift causes the system to be completely unphysical.</p><p>The issue stems from the fact that we are not explicitly enforcing length and momentum constraints in the differentiated DAE system. However, if we were to enforce the equations simultaneously</p><p class="math-container">\[\begin{align}
&amp;e_3: x^2 + y^2 - 1 &amp;= 0 \\
&amp;e&#39;_3: x&#39; x + y&#39; y &amp;= 0 \\
&amp;e&#39;&#39;_3: x&#39;&#39; x + x&#39;^2 + y&#39;&#39; y + y&#39;^2 &amp;= 0
\end{align}\]</p><p>We will get an under-determined system that is not numerically integrable. However, we only need to balance the number of highest order differentiated variables with the number of equations. We can demote highest order differentiated variables to algebraic variables to increase the number of highest order differentiated variables by <span>$1$</span>. Also, since our objective it to increase the number of highest order differentiated variables by the number of differentiated equations introduced during index reduction, we can just focus on the incidence matrix <span>$\mathfrak{I}(F_d, \{z_i\})$</span>, where <span>$F_d$</span> denotes differentiated equations. For the pendulum system, we have</p><p class="math-container">\[\mathfrak{I}(e&#39;&#39;_3, \{x&#39;&#39;, y&#39;&#39;, \lambda\}) = \begin{pmatrix}
1 &amp; 1 &amp; 0
\end{pmatrix}.\]</p><p>Furthermore, we want the newly introduced algebraic variables to be solvable. By analyzing the incidence matrix, we can conclude that we can pick either <span>$x&#39;&#39;$</span> or <span>$y&#39;&#39;$</span>. Let&#39;s arbitrarily pick <span>$x&#39;&#39;$</span>, we have</p><p class="math-container">\[\mathfrak{I}(e&#39;&#39;_3, \{x&#39;&#39;\}) = \begin{pmatrix}
1
\end{pmatrix}\]</p><p>which is structurally nonsingular. After demoteing <span>$x&#39;&#39;$</span> to an algebraic variable, the remaining highest order differentiated variable associated with <span>$x$</span> is <span>$x&#39;$</span>. Thus, we need to pick a variable in</p><p class="math-container">\[\mathfrak{I}(e&#39;_3, \{x&#39;\}) = \begin{pmatrix}
1
\end{pmatrix}\]</p><p>so that the incidence matrix is structurally nonsingular. Trivially, we can just pick <span>$x&#39;$</span>. From the above process, we can demote <span>$x&#39;&#39;\in \{u&#39;_i\}$</span> and <span>$x&#39;\in \{u&#39;_i\}$</span> to algebraic variables <span>$x_{dd}\in\{u_i\}$</span> and <span>$x_d\in\{u_i\}$</span>. We get the system</p><p class="math-container">\[\begin{align}
&amp;e_1: x_{dd} - \lambda x = 0 \\
&amp;e_2: y&#39;&#39; - (\lambda y - g) = 0 \\
&amp;e_3: x^2 + y^2 - 1 = 0 \\
&amp;e&#39;_3: x_d x + y&#39; y = 0 \\
&amp;e&#39;&#39;_3: x_{dd} x + x_{d}^2 + y&#39;&#39; y + y&#39;^2 = 0,
\end{align}\]</p><p>with the corresponding incidence matrix</p><p class="math-container">\[\mathfrak{I}(F, \{x_{dd}, x_{d}, x, y&#39;&#39;, \lambda\}) = \begin{pmatrix}
1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
1 &amp; 1 &amp; 1 &amp; 1 &amp; 0
\end{pmatrix}\]</p><p>A perfect matching <span>$m$</span> for this system can be <span>$1\mapsto 5, 2\mapsto 4, 3\mapsto 3, 4\mapsto 2, 5\mapsto 1$</span>, i.e. we can reverse all rows to move all nonzeros to the diagonal</p><p class="math-container">\[\begin{pmatrix}
1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
1 &amp; 0 &amp; 1 &amp; 0 &amp; 1
\end{pmatrix}.\]</p><p>Note that if we reorder the variables to <span>$\{x\}, \{x_{d}\}, \{y&#39;&#39;, \lambda, x_{dd}\}$</span> according to the matching, the equation order should be <span>$\{e_3, e&#39;_3, e_2, e_1, e&#39;&#39;_3\}$</span> the incidence matrix is then</p><p class="math-container">\[\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\
    1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
    1 &amp; 1 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}.\]</p><p>The reordered original system is then</p><p class="math-container">\[\begin{align}
&amp;e_3: x^2 + y^2 - 1 = 0 \\
&amp;e&#39;_3: x_d x + y&#39; y = 0 \\
&amp;e_2: y&#39;&#39; - (\lambda y - g) = 0 \\
&amp;e_1: x_{dd} - \lambda x = 0 \\
&amp;e&#39;&#39;_3: x_{dd} x + x_{d}^2 + y&#39;&#39; y + y&#39;^2 = 0,
\end{align}\]</p><p>and applying the symbolic solving, we have</p><p class="math-container">\[\begin{align}
&amp;e_3: x^2 + y^2 - 1 = 0 \\
&amp;e&#39;_3: x_d := -\frac{y&#39; y}{x} \\
&amp;e_2: y&#39;&#39; = \lambda y - g\\
&amp;e_1: x_{dd} := \lambda x \\
&amp;e&#39;&#39;_3: x_{dd} x + x_{d}^2 + y&#39;&#39; y + y&#39;^2 = 0,
\end{align}.\]</p><p>The above system is still second order, we can lower its order to one if we introduce a variable <span>$y&#39; = v$</span>, i.e.</p><p class="math-container">\[\begin{align}
&amp;e_0: y&#39; = v \\
&amp;e_3: x^2 + y^2 - 1 = 0 \\
&amp;e&#39;_3: x_d = -\frac{v y}{x} \\
&amp;e_2: v&#39; = \lambda y - g\\
&amp;e_1: x_{dd} = \lambda x \\
&amp;e&#39;&#39;_3: x_{dd} x + x_{d}^2 + v&#39; y + v^2 = 0,
\end{align}\]</p><p>Note that <span>$v&#39;$</span> appears nonlinearly in <span>$e&#39;&#39;_3$</span>, so it is impossible to implement the above system in the mass matrix formulation <span>$Mu&#39; = f(u, p, t)$</span>. However, we can substitute <span>$e_2$</span> to <span>$e&#39;&#39;_3$</span> to alleviate this problem. Let&#39;s implement this simplified system and solve it using a numerical solver.</p><pre><code class="language-julia hljs">function pend_manual_2(out, u, g, t)
    y, x, v, λ = u
    out[1] = v
    out[2] = x^2 + y^2 - 1
    x_d = -v*y/x
    v̇ = out[3] = λ * y - g
    x_dd = λ * x
    out[4] = x_dd * x + x_d^2 + v̇ * y + v^2
end
fun = ODEFunction(pend_manual_2, mass_matrix = Diagonal([1, 0, 1, 0]))
prob = ODEProblem(fun, [0, 1, 0, 0.0], (0, 500.0), 1)
sol = solve(prob, Rodas5P())
plot(sol.t, (@. sol[1, :]^2 + sol[2, :]^2), lab = &quot;d0&quot;, ylims = (0, 2))</code></pre><img src="04462332.svg" alt="Example block output"/><pre><code class="language-julia hljs">plot(sol.t, (@. sol[2, :] * (-sol[3, :] * sol[1, :] / sol[2, :]) + sol[1, :] * sol[3, :]), lab = &quot;d1&quot;, ylims = (-1, 1))</code></pre><img src="c5ac8e27.svg" alt="Example block output"/><pre><code class="language-julia hljs">plot(sol, idxs = (2, 1), lab = &quot;pendulum&quot;, aspect_ratio = 1)</code></pre><img src="0470e293.svg" alt="Example block output"/><p>Note that this formulation solves the drift problem. However, this time, the numerical solver terminates early at <span>$x = 0$</span>. The root problem is that the true symbolic Jacobian is</p><p class="math-container">\[\mathfrak{J}(e&#39;&#39;_3, \{x&#39;&#39;, y&#39;&#39;, \lambda\}) = \begin{pmatrix}
x &amp; y &amp; 0
\end{pmatrix},\]</p><p>and when <span>$x=0$</span>, the sub-matrix that we selected will become numerically singular. Even if we initially pick <span>$y$</span>, we would run into a similar problem when <span>$y=0$</span>. Therefore, a globally valid state selection does not exist in this system. We can implement the same system in ModelingToolkit and see the same behavior.</p><pre><code class="language-julia hljs">@parameters g
@variables t x(t) y(t) [state_priority = 10] λ(t)
D = Differential(t)
eqs = [
       D(D(x)) ~ λ * x
       D(D(y)) ~ λ * y - g
       x^2 + y^2 ~ 1
      ]
@named pend = ODESystem(eqs)
pend = complete(pend)
ss = structural_simplify(pend)
prob_ir = ODEProblem(ss, [ModelingToolkit.missing_variable_defaults(ss); x =&gt; 1], (0.0, 25.0), [g =&gt; 1])
sol = solve(prob_ir, Rodas5P())
plot(sol, idxs = (x, y), lab = &quot;pendulum&quot;, aspect_ratio = 1)</code></pre><img src="0c7d1d0e.svg" alt="Example block output"/><p>To have a globally valid state selection, we must pick the polar coordinate, and the system is then</p><p class="math-container">\[\begin{align}
&amp;e_1: x&#39;&#39; - \lambda x = 0 \\
&amp;e_2: y&#39;&#39; - (\lambda y - g) = 0 \\
&amp;e_3: x = \cos(\theta) \\
&amp;e_3: y = \sin(\theta).
\end{align}\]</p><p>To save the hassle of running algorithms by hand, we can just implement the new system in ModelingToolkit.</p><pre><code class="language-julia hljs">@parameters g
@variables t x(t) y(t) λ(t) θ(t) [state_priority = 10] T(t) V(t) E(t)
D = Differential(t)
eqs = [
       D(D(x)) ~ λ * x
       D(D(y)) ~ λ * y - g
       x ~ cos(θ)
       y ~ sin(θ)
       T ~ (D(x)^2 + D(y)^2) / 2
       V ~ y * g
       E ~ T + V
      ]
@named pend = ODESystem(eqs)
pend = complete(pend)
ss = structural_simplify(pend)
prob_ir = ODEProblem(ss, ModelingToolkit.missing_variable_defaults(ss), (0.0, 25.0), [g =&gt; 1])
sol = solve(prob_ir, Rodas5P())
plot(sol, idxs = (x, y), lab = &quot;pendulum&quot;, aspect_ratio = 1)</code></pre><img src="ccfe6200.svg" alt="Example block output"/><p>The trajectory looks perfect! For another sanity check, let&#39;s plot the energy variation of the system</p><pre><code class="language-julia hljs">plot(sol, idxs = [E-sol[E, 1]])</code></pre><img src="ad036b45.svg" alt="Example block output"/><p>Unfortunately, we see that the total energy is slowly increasing. This is because <code>Rodas5P</code> is not symplectic. A relatively straightforward compiler internal project is to lower second dynamical systems directly to a <code>SecondOrderODEProblem</code> so that users can use symplectic integrators from ModelingToolkit as well. Finally, we note that a detail description of the balancing algorithm is available in the original dummy derivative paper <sup class="footnote-reference"><a id="citeref-Mattsson1993" href="#footnote-Mattsson1993">[Mattsson1993]</a></sup>.</p><h3 id="Bonus-Demo"><a class="docs-heading-anchor" href="#Bonus-Demo">Bonus Demo</a><a id="Bonus-Demo-1"></a><a class="docs-heading-anchor-permalink" href="#Bonus-Demo" title="Permalink"></a></h3><pre><code class="language-julia hljs">@parameters g
@variables t x1(t) x2(t) y1(t) y2(t) λ1(t) λ2(t) θ1(t) [state_priority = 10] θ2(t) [state_priority = 10]
@variables T(t) V(t) lx2(t) ly2(t)
D = Differential(t)
eqs = [
       D(D(x1)) ~ λ1 * x1 - λ2 * lx2
       D(D(y1)) ~ λ1 * y1 - λ2 * ly2 - g
       x1 ~ cos(θ1)
       y1 ~ sin(θ1)
       D(D(x2)) ~ λ2 * lx2
       D(D(y2)) ~ λ2 * ly2 - g
       lx2 ~ cos(θ2)
       ly2 ~ sin(θ2)
       x2 ~ lx2 + x1
       y2 ~ ly2 + y1
       T ~ (D(x1)^2 + D(y1)^2) / 2 + (D(x2)^2 + D(y2)^2) / 2
       V ~ y1 * g + y2 * g
      ]

@named pend = ODESystem(eqs)
pend = complete(pend)
ss = structural_simplify(pend)
prob_ir = ODEProblem(ss,
                     [ModelingToolkit.missing_variable_defaults(ss); θ2=&gt;1.4],
                     (0.0, 25.0), [g =&gt; 1])
sol = solve(prob_ir, Rodas5P(), reltol=1e-7, abstol=1e-9)
plot(sol, idxs = (x1, y1))
plot!(sol, idxs = (x2, y2), xlab = &quot;x&quot;, ylab = &quot;y&quot;, aspect_ratio=1, dpi=400)</code></pre><img src="dc1aa714.svg" alt="Example block output"/><pre><code class="language-julia hljs">plot(sol, idxs = [T+V-sol[T+V, 1]])</code></pre><img src="d96d4d39.svg" alt="Example block output"/><p><video src="../../img/double_pendulum.mp4" controls="true" title><a href="../../img/double_pendulum.mp4"></a></video></p><p>Plotting code:</p><pre><code class="language-julia hljs">nframes = ceil(Int, sol.t[end]*20)
ts = range(0, sol.t[end], length=nframes)
fps = 20
loop_pend = let (x1s, y1s, x2s, y2s) = [Float64[] for _ in 1:4]
    @time @animate for t in ts
        @show t
        nnn = sol(t, idxs=[x1, y1, x2, y2])
        push!(x1s, nnn[1])
        push!(y1s, nnn[2])
        push!(x2s, nnn[3])
        push!(y2s, nnn[4])
        x1s = x1s[max(1, end-100):end]
        y1s = y1s[max(1, end-100):end]
        x2s = x2s[max(1, end-100):end]
        y2s = y2s[max(1, end-100):end]
        n = length(x1s)
        plot([0, x1s[end]], [0, y1s[end]], linewidth = 3, color=:black)
        plot!([x1s[end], x2s[end]], [y1s[end], y2s[end]], linewidth = 3, color=:black)
        linewidth = 10
        seriesalpha = 1
        if n != 1
            linewidth = range(0, linewidth, length = n)
            seriesalpha = range(0, seriesalpha, length = n)
        end
        plot!(x1s, y1s; linewidth, seriesalpha)
        linewidth = 10
        if n != 1
            linewidth = range(0, linewidth, length = n)
        end
        plot!(x2s, y2s; linewidth, seriesalpha,
              dpi = 400, aspect_ratio = 1,
              xlims = (-2.3, 2.3), ylims = (-2.3, 2.3),
              axis=false, leg = false, grid=false)
    end every 5
end
@time mp4(loop_pend, &quot;double_pendulum.mp4&quot;; fps)</code></pre><h3 id="Details-on-Reordering"><a class="docs-heading-anchor" href="#Details-on-Reordering">Details on Reordering</a><a id="Details-on-Reordering-1"></a><a class="docs-heading-anchor-permalink" href="#Details-on-Reordering" title="Permalink"></a></h3><div class="admonition is-category-definition"><header class="admonition-header">Induced Directed Graphs</header><div class="admonition-body"><p>The induced directed graph <span>$G = (V, E_v)$</span> from the destination vertices of a bipartite graph <span>$(U, V, E)$</span> and a perfect matching <span>$M$</span> is defined as</p><p class="math-container">\[E_v = \{(i, j): (M(i), j) \in E\}.\]</p><p>Similarly, the induced directed graph <span>$G = (V, E_u)$</span> from the source vertices is defined as</p><p class="math-container">\[E_u = \{(i, j): (i, M^{-1}(j)) \in E\}.\]</p></div></div><div class="admonition is-category-definition"><header class="admonition-header">Strongly Connected Component</header><div class="admonition-body"><p>A strongly connected component <span>$c\subseteq E$</span> of a directed graph <span>$G = (V, E)$</span> is a maximum cardinality set of vertices such that any pair <span>$i \in c, j \in c$</span>, there exists a path <span>$i \rightsquigarrow j$</span> in <span>$G$</span>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Strongly Connected Components Uniqueness Theorem</header><div class="admonition-body"><p>The strongly connected components are unique for induced directed graphs from bipartite graphs with a perfect matching.</p><h4>Proof:</h4><p>See <sup class="footnote-reference"><a id="citeref-DulmageMendelsohn1958" href="#footnote-DulmageMendelsohn1958">[DulmageMendelsohn1958]</a></sup>.</p></div></div><h4 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h4><p>Consider a nonlinear system represented by</p><p class="math-container">\[\begin{align}
f_1(v_1, v_3) &amp;= 0 \\
f_2(v_1, v_3) &amp;= 0 \\
f_3(v_1, v_2) &amp;= 0
\end{align}\]</p><p>The incidence matrix is</p><p class="math-container">\[\begin{pmatrix}
1 &amp; 0 &amp; 1 \\
1 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 0
\end{pmatrix}\]</p><p>where a perfect matching <span>$m$</span> is then defined as</p><p class="math-container">\[1 \mapsto 1, 2 \mapsto 3, 3 \mapsto 2.\]</p><p>The permuted matrix is then</p><p class="math-container">\[\begin{pmatrix}
1 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 1
\end{pmatrix}.\]</p><p>The matching can be interpreted as a solvability assignment, i.e.</p><p class="math-container">\[\begin{align}
v_1 &amp;= \hat{f}_1(v_3) \\
v_2 &amp;= \hat{f}_3(v_1) \\
v_3 &amp;= \hat{f}_2(v_2)
\end{align}\]</p><p>Even if all <span>$\{\hat{f}_i\}$</span> are symbolically solvable, the above assignment will not work because the interdependence of variables. The strongly connected component definition captures this idea well. Variables in a non-trivial strongly connected component are the largest set of variables that are interdependent. The strongly connected components of the above system are <span>$\{\{1, 3\}, \{2\}\}$</span>. Thus, by the previous matching, we should reorder the equations as <span>$e_1, e_2, e_3$</span> and variables as <span>$v_1, v_3, v_2$</span> to isolate the interdependent part. The resulting system is then</p><p class="math-container">\[\begin{pmatrix}
1 &amp; 1 &amp; 0 \\
1 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 1
\end{pmatrix}.\]</p><p>Note that resulting matrix is block lower triangular and this is not a coincidence. We can always reorder the system to be block lower triangular granted by the following theorem.</p><div class="admonition is-category-definition"><header class="admonition-header">Condensation Graph</header><div class="admonition-body"><p>A condensation graph <span>$G_c = (V_c, E_c)$</span> of a directed graph <span>$G = (V, E)$</span> is a directed graph that has vertices</p><p class="math-container">\[V_c = \{\text{strongly connected components of } G\},\]</p><p>and edges</p><p class="math-container">\[E_c = \{(i, j): \exists i_e \in i, j_e \in j, i \ne j \land (i_e, j_e)
\in E\}.\]</p></div></div><div class="admonition is-info"><header class="admonition-header">Condensation Graphs are Acyclic Theorem</header><div class="admonition-body"><p>The condensation graph <span>$G_c = (V_c, E_c)$</span> induced from the directed graph <span>$G = (V, E)$</span> is acyclic.</p><h4>Proof:</h4><p>Suppose <span>$G_c$</span> is cyclic with a cycle consisting of vertices <span>$s = \{v_1, v_2, ...\} \subseteq V_c$</span>. Then, any original vertices in <span>$v_i$</span> has a path to any vertices in <span>$v_j$</span> for all <span>$i, j$</span>. Thus, <span>$G_c$</span> must have only one vertex. By the definition of a condensation graph, <span>$G_c$</span> must has no edges, and therefore, no cycles.</p></div></div><p>Since the condensation graph has no cycles, we can topologically sort strongly connected components so that the resulting system is always block lower triangular. Further, each block on the diagonal must be square, because the perfect matching will map all variables in each strongly connected components to distinct equations.</p><h2 id="Demo"><a class="docs-heading-anchor" href="#Demo">Demo</a><a id="Demo-1"></a><a class="docs-heading-anchor-permalink" href="#Demo" title="Permalink"></a></h2><pre><code class="language-julia hljs">using ModelingToolkit, OrdinaryDiffEq, LinearAlgebra
import ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible as IC
import ModelingToolkitStandardLibrary.Blocks as B
import ModelingToolkitStandardLibrary.Mechanical.Translational as T

@parameters t
D = Differential(t)

function System(use_input, f; name)
    @parameters t

    pars = @parameters begin
        p_s = 200e5
        p_r = 5e5

        A_1 = 360e-4
        A_2 = 360e-4

        p_1 = 45e5
        p_2 = 45e5

        l_1 = 0.01
        l_2 = 0.05
        m_f = 250
        g = 0

        d = 100e-3

        Cd = 0.01

        m_piston = 880
    end

    vars = @variables begin
        ddx(t) = 0
    end

    systems = @named begin
        src = IC.FixedPressure(; p = p_s)
        valve = IC.SpoolValve2Way(; p_s_int = p_s, p_a_int = p_1, p_b_int = p_2,
            p_r_int = p_r, g, m = m_f, x_int = 0, d, Cd)
        piston = IC.Actuator(5;
            p_a_int = p_1,
            p_b_int = p_2,
            area_a = A_1,
            area_b = A_2,
            length_a_int = l_1,
            length_b_int = l_2,
            m = m_piston,
            g = 0,
            x_int = 0,
            minimum_volume_a = A_1 * 1e-3,
            minimum_volume_b = A_2 * 1e-3,
            damping_volume_a = A_1 * 5e-3,
            damping_volume_b = A_2 * 5e-3)
        body = T.Mass(; m = 1500)
        pipe = IC.Tube(5; p_int = p_2, area = A_2, length = 2.0)
        snk = IC.FixedPressure(; p = p_r)
        pos = T.Position()

        m1 = IC.FlowDivider(; p_int = p_2, n = 3)
        m2 = IC.FlowDivider(; p_int = p_2, n = 3)

        fluid = IC.HydraulicFluid()
    end

    if use_input
        @named input = B.SampledData(Float64)
    else
        @named input = B.TimeVaryingFunction(f)
    end

    push!(systems, input)

    eqs = [connect(input.output, pos.s)
        connect(valve.flange, pos.flange)
        connect(valve.port_a, piston.port_a)
        connect(piston.flange, body.flange)
        connect(piston.port_b, m1.port_a)
        connect(m1.port_b, pipe.port_b)
        connect(pipe.port_a, m2.port_b)
        connect(m2.port_a, valve.port_b)
        connect(src.port, valve.port_s)
        connect(snk.port, valve.port_r)
        connect(fluid, src.port, snk.port)
        D(body.v) ~ ddx]

    ODESystem(eqs, t, vars, pars; name, systems)
end

@named system = System(true, nothing)

# sys = structural_simplify(system)
using ModelingToolkit.StructuralTransformations, ModelingToolkit.BipartiteGraphs,
    Graphs
ts = TearingState(ModelingToolkit.expand_connections(system))
m = BipartiteGraphs.maximal_matching(ts.structure.graph, _-&gt;true, x-&gt;ts.structure.var_to_diff[x] === nothing);
count(x-&gt;x isa Int, m)
count(x-&gt;x===nothing, ts.structure.eq_to_diff)
ModelingToolkit.pantelides!(ts)
m = BipartiteGraphs.maximal_matching(ts.structure.graph, x-&gt;ts.structure.eq_to_diff[x]===nothing, x-&gt;ts.structure.var_to_diff[x] === nothing);
count(x-&gt;x isa Int, m)
count(x-&gt;x===nothing, ts.structure.eq_to_diff)
M = incidence_matrix(ts.structure.graph)
A = M[Int[m[i] for i in eachindex(m) if m[i] isa Int], Int[i for i in eachindex(m) if m[i] isa Int]]
all(isequal(1), diag(A))
g = BipartiteGraphs.DiCMOBiGraph{true}(complete(ts.structure.graph), complete(m));
scc = strongly_connected_components(g);
M[Int[m[i] for i in reduce(vcat, scc) if m[i] isa Int], Int[i for i in reduce(vcat, scc) if m[i] isa Int]]
for c in scc
    length(c) &gt; 1 || continue
    B = M[Int[m[i] for i in c if m[i] isa Int], Int[i for i in c if m[i] isa Int]]
    display(B)
end</code></pre><pre><code class="language-julia hljs">using ModelingToolkit, OrdinaryDiffEq, Plots

@parameters g
@variables t x1(t) x2(t) y1(t) y2(t) λ1(t) λ2(t) θ1(t) [state_priority = 10] θ2(t) [state_priority = 10]
D = Differential(t)
eqs = [
       D(D(x1)) ~ λ1 * x1,
       D(D(y1)) ~ λ1 * y1 - g,
       x1 ~ cos(θ1),
       y1 ~ sin(θ1),
       D(D(x2)) ~ λ2 * x2,
       D(D(y2)) ~ λ2 * y2 - g,
       x2 ~ x1 + cos(θ2),
       y2 ~ y1 + sin(θ2),
      ]

@named pend = ODESystem(eqs)
pend = complete(pend)
ss = structural_simplify(pend)
prob_ir = ODEProblem(ss,
    [
     ModelingToolkit.missing_variable_defaults(ss);
     θ1 =&gt; 0
     θ2 =&gt; 0
     D(θ1) =&gt; 0.0
     D(θ2) =&gt; 0.0
     λ1 =&gt; 0
     λ2 =&gt; 0
    ],
    (0.0, 25.0), [g =&gt; 1])
sol = solve(prob_ir, Rodas5P())
plot(sol, idxs = (x1, y1))
plot!(sol, idxs = (x2, y2), xlab = &quot;x&quot;, ylab = &quot;y&quot;, aspect_ratio=1, dpi=400)
nframes = ceil(Int, sol.t[end]*20)
ts = range(0, sol.t[end], length=nframes)
fps = 20
let (x1s, y1s, x2s, y2s) = [Float64[] for _ in 1:4]
    loop_pend = @time @animate for t in ts
        nnn = sol(t, idxs=[x1, y1, x2, y2])
        push!(x1s, nnn[1])
        push!(y1s, nnn[2])
        push!(x2s, nnn[3])
        push!(y2s, nnn[4])
        x1s = x1s[max(1, end-100):end]
        y1s = y1s[max(1, end-100):end]
        x2s = x2s[max(1, end-100):end]
        y2s = y2s[max(1, end-100):end]
        n = length(x1s)
        plot([0, x1s[end]], [0, y1s[end]], linewidth = 3, color=:black)
        plot!([x1s[end], x2s[end]], [y1s[end], y2s[end]], linewidth = 3, color=:black)
        linewidth = 10
        seriesalpha = 1
        if n != 1
            linewidth = range(0, linewidth, length = n)
            seriesalpha = range(0, seriesalpha, length = n)
        end
        plot!(x1s, y1s; linewidth, seriesalpha)
        linewidth = 10
        if n != 1
            linewidth = range(0, linewidth, length = n)
        end
        plot!(x2s, y2s; linewidth, seriesalpha,
              dpi = 400, aspect_ratio = 1,
              xlims = (-2.3, 2.3), ylims = (-2.3, 1),
              axis=false, leg = false, grid=false)
    end every 5
    @time mp4(loop_pend, &quot;double_pendulum.mp4&quot;; fps)
end</code></pre><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Mattsson1993"><a class="tag is-link" href="#citeref-Mattsson1993">Mattsson1993</a>Mattsson, Sven Erik, and Gustaf Söderlind. &quot;Index reduction in differential-algebraic equations using dummy derivatives.&quot; SIAM Journal on Scientific Computing 14.3 (1993): 677-692.</li><li class="footnote" id="footnote-DulmageMendelsohn1958"><a class="tag is-link" href="#citeref-DulmageMendelsohn1958">DulmageMendelsohn1958</a>Dulmage, Andrew L., and Nathan S. Mendelsohn. &quot;Coverings of bipartite graphs.&quot; Canadian Journal of Mathematics 10 (1958): 517-534.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lecture7/">« Numerical and Structural Characterizations for DAEs</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Sunday 25 February 2024 21:42">Sunday 25 February 2024</span>. Using Julia version 1.10.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
