<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Numerical Methods for Stiff ODEs and Differential-Algebraic Equations · ModelingToolkit Course</title><meta name="title" content="Numerical Methods for Stiff ODEs and Differential-Algebraic Equations · ModelingToolkit Course"/><meta property="og:title" content="Numerical Methods for Stiff ODEs and Differential-Algebraic Equations · ModelingToolkit Course"/><meta property="twitter:title" content="Numerical Methods for Stiff ODEs and Differential-Algebraic Equations · ModelingToolkit Course"/><meta name="description" content="Documentation for ModelingToolkit Course."/><meta property="og:description" content="Documentation for ModelingToolkit Course."/><meta property="twitter:description" content="Documentation for ModelingToolkit Course."/><meta property="og:url" content="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture4/"/><meta property="twitter:url" content="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture4/"/><link rel="canonical" href="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture4/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelingToolkit Course</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../lecture1/">Introduction to acausal modeling for physical systems with ModelingToolkit.jl</a></li><li><a class="tocitem" href="../lecture2/">Developing high-fidelity models of hydraulic systems</a></li><li><a class="tocitem" href="../lecture3/">Solvers for Non-Stiff Ordinary Differential Equations</a></li><li class="is-active"><a class="tocitem" href>Numerical Methods for Stiff ODEs and Differential-Algebraic Equations</a><ul class="internal"><li><a class="tocitem" href="#A-Deeper-Look-into-the-Stability-of-Numerical-Methods"><span>A Deeper Look into the Stability of Numerical Methods</span></a></li><li><a class="tocitem" href="#Understanding-Stiffness-and-the-Relationship-to-DAEs"><span>Understanding Stiffness and the Relationship to DAEs</span></a></li><li><a class="tocitem" href="#The-Steps-of-an-Implicit-Solver"><span>The Steps of an Implicit Solver</span></a></li><li><a class="tocitem" href="#Some-Quick-Notes"><span>Some Quick Notes</span></a></li><li><a class="tocitem" href="#Generation-of-the-Jacobian"><span>Generation of the Jacobian</span></a></li><li><a class="tocitem" href="#Linear-Solving"><span>Linear Solving</span></a></li></ul></li><li><a class="tocitem" href="../lecture6/">Debugging difficult stiff ODE/DAE models</a></li><li><a class="tocitem" href="../lecture7/">Numerical and Structural Characterizations for DAEs</a></li><li><a class="tocitem" href="../lecture8/">Dummy Derivatives and Reordering of Equations</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Numerical Methods for Stiff ODEs and Differential-Algebraic Equations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Numerical Methods for Stiff ODEs and Differential-Algebraic Equations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkitCourse" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkitCourse/blob/main/docs/src/lectures/lecture4.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Numerical-Methods-for-Stiff-ODEs-and-Differential-Algebraic-Equations"><a class="docs-heading-anchor" href="#Numerical-Methods-for-Stiff-ODEs-and-Differential-Algebraic-Equations">Numerical Methods for Stiff ODEs and Differential-Algebraic Equations</a><a id="Numerical-Methods-for-Stiff-ODEs-and-Differential-Algebraic-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-Methods-for-Stiff-ODEs-and-Differential-Algebraic-Equations" title="Permalink"></a></h1><p>Before jumping into this lecture, I want to start by mentioning that <a href="https://epubs.siam.org/doi/10.1137/0903023">DAEs are not ODEs</a>. There are substantial differences that must be addressed. The abstract is rather clear:</p><blockquote><p>This paper outlines a number of difficulties which can arise when numerical methods are used to solve systems of differential/algebraic equations of the form. Problems which can be written in this general form include standard ODE systems as well as problems which are substantially different from standard ODE’S. Some of the differential/algebraic systems can be solved using numerical methods which are commonly used for solving stiff systems of ordinary differential equations. Other problems can be solved using codes based on the stiff methods, but only after extensive modifications to the error estimates and other strategies in the code. A further class of problems cannot be solved at all with such codes, because changing the stepsize causes large errors in the solution. We describe in detail the causes of these difficulties and indicate solutions in some cases.</p></blockquote><p>However, a good portion of those issues can be mitigated by symbolic tooling which will be covered in later lectures. Other aspects will be highlighted on an as-needed basis. If you want more details, refer to that classic article.</p><p>That said, we will be using stiff ODEs to introduce the numerical methods for DAEs since, while they are distinctly not the same, many of the methods for DAEs are derived as extensions to those for stiff ODEs. Thus we will start by introducing the methods for stiff ODEs, see how they can be extended to DAEs, and point out some of the caveats. Fully handling all of these caveats is a deep research topic that is beyond the scope of this course.</p><p>A good resource on this topic is <a href="https://link.springer.com/book/10.1007/978-3-642-05221-7">Hairer&#39;s Solving Ordinary Differential Equations II</a></p><h2 id="A-Deeper-Look-into-the-Stability-of-Numerical-Methods"><a class="docs-heading-anchor" href="#A-Deeper-Look-into-the-Stability-of-Numerical-Methods">A Deeper Look into the Stability of Numerical Methods</a><a id="A-Deeper-Look-into-the-Stability-of-Numerical-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#A-Deeper-Look-into-the-Stability-of-Numerical-Methods" title="Permalink"></a></h2><h3 id="Stability-of-a-Method"><a class="docs-heading-anchor" href="#Stability-of-a-Method">Stability of a Method</a><a id="Stability-of-a-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Stability-of-a-Method" title="Permalink"></a></h3><p>Simply having an order on the truncation error does not imply convergence of the method. The disconnect is that the errors at a given time point may not dissipate. What also needs to be checked is the asymptotic behavior of a disturbance. To see this, one can utilize the linear test problem:</p><p class="math-container">\[u&#39; = \alpha u\]</p><p>and ask the question, does the discrete dynamical system defined by the discretized ODE end up going to zero? You would hope that the discretized dynamical system and the continuous dynamical system have the same properties in this simple case, and this is known as linear stability analysis of the method.</p><p>As an example, take a look at the Euler method. Recall that the Euler method was given by:</p><p class="math-container">\[u_{n+1} = u_n + \Delta t f(u_n,p,t)\]</p><p>When we plug in the linear test equation, we get that</p><p class="math-container">\[u_{n+1} = u_n + \Delta t \alpha u_n\]</p><p>If we let <span>$z = \Delta t \alpha$</span>, then we get the following:</p><p class="math-container">\[u_{n+1} = u_n + z u_n = (1+z)u_n\]</p><p>which is stable when <span>$z$</span> is in the shifted unit circle. This means that, as a necessary condition, the step size <span>$\Delta t$</span> needs to be small enough that <span>$z$</span> satisfies this condition, placing a stepsize limit on the method.</p><p><img src="https://user-images.githubusercontent.com/1814174/95117231-3c766880-0716-11eb-9069-039253bcebda.PNG" alt/></p><p>If <span>$\Delta t$</span> is ever too large, it will cause the equation to overshoot zero, which then causes oscillations that spiral out to infinity.</p><p><img src="https://user-images.githubusercontent.com/1814174/95132604-0d6bf100-072e-11eb-8af5-663512a0db14.PNG" alt/></p><p><img src="https://user-images.githubusercontent.com/1814174/95132963-9125dd80-072e-11eb-878e-61f77a20d03e.gif" alt/></p><p>Thus the stability condition places a hard constraint on the allowed <span>$\Delta t$</span> which will result in a realistic simulation.</p><p>For reference, the stability regions of the 2nd and 4th order Runge-Kutta methods that we discussed are as follows:</p><p><img src="https://user-images.githubusercontent.com/1814174/95117286-56b04680-0716-11eb-9c6a-07fc4d190a09.PNG" alt/></p><h3 id="Interpretation-of-the-Linear-Stability-Condition"><a class="docs-heading-anchor" href="#Interpretation-of-the-Linear-Stability-Condition">Interpretation of the Linear Stability Condition</a><a id="Interpretation-of-the-Linear-Stability-Condition-1"></a><a class="docs-heading-anchor-permalink" href="#Interpretation-of-the-Linear-Stability-Condition" title="Permalink"></a></h3><p>To interpret the linear stability condition, recall that the linearization of a system interprets the dynamics as locally being due to the Jacobian of the system. Thus</p><p class="math-container">\[u&#39; = f(u,p,t)\]</p><p>is locally equivalent to</p><p class="math-container">\[u&#39; = \frac{df}{du}u\]</p><p>You can understand the local behavior through diagonalizing this matrix. Therefore, the scalar for the linear stability analysis is performing an analysis on the eigenvalues of the Jacobian. The method will be stable if the largest eigenvalues of df/du are all within the stability limit. This means that stability effects are different throughout the solution of a nonlinear equation and are generally understood locally (though different more comprehensive stability conditions exist!).</p><h3 id="Implicit-Methods"><a class="docs-heading-anchor" href="#Implicit-Methods">Implicit Methods</a><a id="Implicit-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Implicit-Methods" title="Permalink"></a></h3><p>If instead of the Euler method we defined <span>$f$</span> to be evaluated at the future point, we would receive a method like:</p><p class="math-container">\[u_{n+1} = u_n + \Delta t f(u_{n+1},p,t+\Delta t)\]</p><p>in which case, for the stability calculation we would have that</p><p class="math-container">\[u_{n+1} = u_n + \Delta t \alpha u_n\]</p><p>or</p><p class="math-container">\[(1-z) u_{n+1} = u_n\]</p><p>which means that</p><p class="math-container">\[u_{n+1} = \frac{1}{1-z} u_n\]</p><p>which is stable for all <span>$Re(z) &lt; 0$</span> a property which is known as A-stability. It is also stable as <span>$z \rightarrow \infty$</span>, a property known as L-stability. This means that for equations with very ill-conditioned Jacobians, this method is still able to be use reasonably large stepsizes and can thus be efficient.</p><p><img src="https://user-images.githubusercontent.com/1814174/95117191-28326b80-0716-11eb-8e17-889308bdff53.PNG" alt/></p><h2 id="Understanding-Stiffness-and-the-Relationship-to-DAEs"><a class="docs-heading-anchor" href="#Understanding-Stiffness-and-the-Relationship-to-DAEs">Understanding Stiffness and the Relationship to DAEs</a><a id="Understanding-Stiffness-and-the-Relationship-to-DAEs-1"></a><a class="docs-heading-anchor-permalink" href="#Understanding-Stiffness-and-the-Relationship-to-DAEs" title="Permalink"></a></h2><h3 id="Stiffness-and-Timescale-Separation"><a class="docs-heading-anchor" href="#Stiffness-and-Timescale-Separation">Stiffness and Timescale Separation</a><a id="Stiffness-and-Timescale-Separation-1"></a><a class="docs-heading-anchor-permalink" href="#Stiffness-and-Timescale-Separation" title="Permalink"></a></h3><p>From this we see that there is a maximal stepsize whenever the eigenvalues of the Jacobian are sufficiently large. It turns out that&#39;s not an issue if the phenomena we see are fast, since then the total integration time tends to be small. However, if we have some equations with both fast modes and slow modes, like the Robertson equation (shown below), then it is very difficult because in order to resolve the slow dynamics over a long timespan, one needs to ensure that the fast dynamics do not diverge. This is a property known as stiffness. Stiffness can thus be approximated in some sense by the condition number of the Jacobian. The condition number of a matrix is its maximal eigenvalue divided by its minimal eigenvalue and gives a rough measure of the local timescale separations. If this value is large and one wants to resolve the slow dynamics, then explicit integrators, like the explicit Runge-Kutta methods described before, have issues with stability. In this case implicit integrators (or other forms of stabilized stepping) are required in order to efficiently reach the end time step.</p><p><img src="../../img/numerical_stiffness_effect.png" alt/></p><p>In this illustrative plot, the grey is &quot;the true solution&quot;. The representative solution has a fast process and a slow process, the slow precess is an r-shaped curve. The fast process is a quasi-steady state process, i.e. it very quickly brings any purturbation from the r-shaped curve back to the main curve (and example of this is the <span>$y_2$</span> term in the Robertson equation below). The black line up top is a <strong>numerical solution</strong> with an explicit method on such an equation. It&#39;s show how for a &quot;reasonable&quot; sized <span>$h$</span> that the large derivatives of the fast process back to the stable manifold cause explicit methods to overshoot the manifold, thus requiring the <span>$h$</span> to be small enough to &quot;not overshoot too much&quot;, with this overshooting resulting in a jagged behavior.</p><p>This overshooting is exactly the behavior that causes a step size limitation, thus forcing <span>$h$</span> to be sufficiently small when there is such time-scale separation, and thus simulations of the long-scale phonomena require time steps on the scale of the short-scale phonomena. If those two time-scales are orders of magnitude different, then accurately handling this type of equations thus requires orders of magnitude more time steps, leading to the inefficiency of explicit methods.</p><p>Implicit methods on the other hand effectively smooth out the behavior of the derivative in the future to be able to account for how the process had gotten there. For example, the red dotted line shows the linear extrapolation of the derivative from <span>$t_n$</span> to <span>$t_{n+1}$</span>. But at the proposed <span>$y_{n+1}$</span> of the Euler method, the derivative would be negative, and thus implicit Euler we detect a mismatch between the proposed value of <span>$y_{n+1}$</span> and the required derivative to get to <span>$y_{n+1}$</span>. The solution of the implicit equation is thus an iterative process to remove this mismatch, which effectively smooths out the derivative issues and forces the solution onto the slow manifold.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The true solution is <strong>not</strong> the jagged black line. To be clear, the stiff solution is not generally jagged, this is not the reason for stiffness. The clean r-shaped curve is the true stiff solution. The jagged line is what is seen from an explicit numerical solver on such an equation, but the jaggedness is a numerical artifact!</p></div></div><h3 id="Stiffness-in-Biochemistry:-Robertson-Equations"><a class="docs-heading-anchor" href="#Stiffness-in-Biochemistry:-Robertson-Equations">Stiffness in Biochemistry: Robertson Equations</a><a id="Stiffness-in-Biochemistry:-Robertson-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Stiffness-in-Biochemistry:-Robertson-Equations" title="Permalink"></a></h3><p>Biochemical equations commonly display large separation of timescales which lead to a stiffness phenomena that will be investigated later. The classic &quot;hard&quot; equations for ODE integration thus tend to come from biology (not physics!) due to this property. One of the standard models is the Robertson model, which can be described as:</p><pre><code class="language-julia hljs">using DifferentialEquations, Plots
function rober(du,u,p,t)
  y₁,y₂,y₃ = u
  k₁,k₂,k₃ = p
  du[1] = -k₁*y₁+k₃*y₂*y₃
  du[2] =  k₁*y₁-k₂*y₂^2-k₃*y₂*y₃
  du[3] =  k₂*y₂^2
end
prob = ODEProblem(rober,[1.0,0.0,0.0],(0.0,1e5),(0.04,3e7,1e4))
sol = solve(prob,Rosenbrock23())
plot(sol)</code></pre><img src="a88940a3.svg" alt="Example block output"/><pre><code class="language-julia hljs">plot(sol, xscale=:log10, tspan=(1e-6, 1e5), layout=(3,1))</code></pre><img src="2e69df4c.svg" alt="Example block output"/><h3 id="Stiffness-in-Chemical-Physics:-Pollution-Models"><a class="docs-heading-anchor" href="#Stiffness-in-Chemical-Physics:-Pollution-Models">Stiffness in Chemical Physics: Pollution Models</a><a id="Stiffness-in-Chemical-Physics:-Pollution-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Stiffness-in-Chemical-Physics:-Pollution-Models" title="Permalink"></a></h3><p>Chemical reactions in physical models are also described as differential equation systems. The following is a classic model of dynamics between different species of pollutants:</p><pre><code class="language-julia hljs">k1=.35e0
k2=.266e2
k3=.123e5
k4=.86e-3
k5=.82e-3
k6=.15e5
k7=.13e-3
k8=.24e5
k9=.165e5
k10=.9e4
k11=.22e-1
k12=.12e5
k13=.188e1
k14=.163e5
k15=.48e7
k16=.35e-3
k17=.175e-1
k18=.1e9
k19=.444e12
k20=.124e4
k21=.21e1
k22=.578e1
k23=.474e-1
k24=.178e4
k25=.312e1
p = (k1,k2,k3,k4,k5,k6,k7,k8,k9,k10,k11,k12,k13,k14,k15,k16,k17,k18,k19,k20,k21,k22,k23,k24,k25)
function f(dy,y,p,t)
 k1,k2,k3,k4,k5,k6,k7,k8,k9,k10,k11,k12,k13,k14,k15,k16,k17,k18,k19,k20,k21,k22,k23,k24,k25 = p
 r1  = k1 *y[1]
 r2  = k2 *y[2]*y[4]
 r3  = k3 *y[5]*y[2]
 r4  = k4 *y[7]
 r5  = k5 *y[7]
 r6  = k6 *y[7]*y[6]
 r7  = k7 *y[9]
 r8  = k8 *y[9]*y[6]
 r9  = k9 *y[11]*y[2]
 r10 = k10*y[11]*y[1]
 r11 = k11*y[13]
 r12 = k12*y[10]*y[2]
 r13 = k13*y[14]
 r14 = k14*y[1]*y[6]
 r15 = k15*y[3]
 r16 = k16*y[4]
 r17 = k17*y[4]
 r18 = k18*y[16]
 r19 = k19*y[16]
 r20 = k20*y[17]*y[6]
 r21 = k21*y[19]
 r22 = k22*y[19]
 r23 = k23*y[1]*y[4]
 r24 = k24*y[19]*y[1]
 r25 = k25*y[20]

 dy[1]  = -r1-r10-r14-r23-r24+
          r2+r3+r9+r11+r12+r22+r25
 dy[2]  = -r2-r3-r9-r12+r1+r21
 dy[3]  = -r15+r1+r17+r19+r22
 dy[4]  = -r2-r16-r17-r23+r15
 dy[5]  = -r3+r4+r4+r6+r7+r13+r20
 dy[6]  = -r6-r8-r14-r20+r3+r18+r18
 dy[7]  = -r4-r5-r6+r13
 dy[8]  = r4+r5+r6+r7
 dy[9]  = -r7-r8
 dy[10] = -r12+r7+r9
 dy[11] = -r9-r10+r8+r11
 dy[12] = r9
 dy[13] = -r11+r10
 dy[14] = -r13+r12
 dy[15] = r14
 dy[16] = -r18-r19+r16
 dy[17] = -r20
 dy[18] = r20
 dy[19] = -r21-r22-r24+r23+r25
 dy[20] = -r25+r24
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">f (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">u0 = zeros(20)
u0[2]  = 0.2
u0[4]  = 0.04
u0[7]  = 0.1
u0[8]  = 0.3
u0[9]  = 0.01
u0[17] = 0.007
prob = ODEProblem(f,u0,(0.0,60.0),p)
sol = solve(prob,Rodas5P())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
Interpolation: specialized 4rd order &quot;free&quot; stiffness-aware interpolation
t: 30-element Vector{Float64}:
  0.0
  0.0013845590497824308
  0.003248154820240184
  0.007822056050945408
  0.015636473638329054
  0.02695092961815919
  0.04478922697244149
  0.07253076423642746
  0.10600967847261421
  0.1550976378543455
  ⋮
  4.01833703454483
  6.080137864970215
  9.234700036095719
 13.866865088960092
 20.139834368542314
 28.57562540061639
 39.68150334392996
 54.143352797090735
 60.0
u: 30-element Vector{Vector{Float64}}:
 [0.0, 0.2, 0.0, 0.04, 0.0, 0.0, 0.1, 0.3, 0.01, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.007, 0.0, 0.0, 0.0]
 [0.00029350835599164127, 0.1997064910246462, 1.6933646659442256e-10, 0.03970673366396415, 1.142760852742035e-7, 1.0934662220568216e-7, 0.09999966675482728, 0.30000033504926327, 0.009999982097053323, 5.608275186090612e-9, 6.0437672559379115e-9, 1.0053303376429798e-8, 5.95030281349918e-12, 6.2407891504614965e-9, 2.3086790312357436e-10, 3.129330571410992e-17, 0.0069999994176068725, 5.823931280628732e-10, 3.824053725159255e-10, 6.931199753689511e-14]
 [0.0006848307393263268, 0.19931516395991847, 1.9614145270676562e-10, 0.03931628333733633, 2.0845795047203617e-7, 2.527988735396753e-7, 0.0999988378095226, 0.3000011665225655, 0.009999897119251894, 2.064534412752599e-8, 1.687305270628739e-8, 8.167731332135961e-8, 1.0779517325590447e-10, 6.514505502657275e-8, 3.1173973981561673e-9, 3.0985586958414323e-17, 0.006999996431845442, 3.5681545580507224e-9, 2.07143920473889e-9, 2.061752236742482e-12]
 [0.001626673842789779, 0.19837327663367996, 2.61341517186769e-10, 0.03837837135119767, 3.499140256138006e-7, 4.640939891340906e-7, 0.0999955180524943, 0.3000044941971509, 0.009999482640907172, 4.469079614092972e-8, 3.316652483724116e-8, 4.7262219296034596e-7, 1.4018895300664164e-9, 4.360187226554445e-7, 3.646907321606834e-8, 3.0246408405940866e-17, 0.0069999816561534, 1.8343846600048992e-8, 1.1520193471079965e-8, 6.618705754098527e-11]
 [0.0031739598368824284, 0.19682578480247068, 3.6848274612582107e-10, 0.036840444265251716, 4.308058894245777e-7, 5.770922655811164e-7, 0.09998792362054168, 0.3000121120820022, 0.009998465300944014, 5.828043759889608e-8, 4.216064737085081e-8, 1.4641454855949606e-6, 8.066719707030999e-9, 1.4108149108097597e-6, 2.0286586083895822e-7, 2.9034351481624044e-17, 0.006999945226182863, 5.477381713749204e-8, 4.248810508564416e-8, 9.699806494900167e-10]
 [0.00527985593453901, 0.1947193383531825, 5.143418506781766e-10, 0.0347488996031483, 4.3093601952954417e-7, 5.646226467930153e-7, 0.09997626842071211, 0.3000238282736904, 0.009996882519830105, 5.7928612826073366e-8, 4.16241161501318e-8, 3.0144643408683243e-6, 2.636014341246327e-8, 2.9299044645063637e-6, 6.539227913561269e-7, 2.738598257429025e-17, 0.006999888501592138, 1.1149840786279859e-7, 1.1048653161793254e-7, 7.471406060555517e-9]
 [0.008303332733066323, 0.19169456572579305, 7.237922059569431e-10, 0.03174600330420883, 3.979588459244406e-7, 4.999453551109529e-7, 0.09995919302644539, 0.30004106184979734, 0.0099945852514614, 5.172437268072286e-8, 3.7108987770252254e-8, 5.250222785609308e-6, 6.920535643683605e-8, 5.060044987751721e-6, 1.7029563673086802e-6, 2.501936761224585e-17, 0.006999806222084552, 1.9377791544810596e-7, 2.393708350642762e-7, 4.500429091005969e-8]
 [0.012381216304727582, 0.18761393275867358, 1.0062796343688567e-9, 0.027695563423620763, 3.63737037857065e-7, 4.315804004432719e-7, 0.09993562728428845, 0.300065000639491, 0.009991470600090027, 4.5086072920571806e-8, 3.231183314858193e-8, 8.244514171660123e-6, 1.5832377775460823e-7, 7.760004574102389e-6, 3.869130998427598e-6, 2.1827172254836282e-17, 0.006999694805205503, 3.0519479449815307e-7, 4.0869403799383373e-7, 2.0739389231717105e-7]
 [0.016470145074437254, 0.18352084921518833, 1.289448860116361e-9, 0.023635066176169506, 3.408363434174163e-7, 3.823025203747643e-7, 0.09991026515233849, 0.3000909794121657, 0.009988177497437328, 4.0347996010672295e-8, 2.8879229651845425e-8, 1.136510631334099e-5, 2.9078873481039145e-7, 1.0355650382795339e-5, 7.062384503143422e-6, 1.8627050578125932e-17, 0.006999577163514119, 4.228364858828224e-7, 5.064584290101607e-7, 5.730393537301469e-7]
 [0.021191772350648914, 0.17879211720086433, 1.6163236315104805e-9, 0.0189497541387097, 3.233310106833691e-7, 3.4022871811801787e-7, 0.09987670742311801, 0.3001256997501773, 0.009983888194513471, 3.634759463668129e-8, 2.597408219749891e-8, 1.5366225206057014e-5, 5.18152958037098e-7, 1.332561079652248e-5, 1.2493270736175514e-5, 1.493450562624091e-17, 0.006999424135598123, 5.758644018788993e-7, 5.168278330665833e-7, 1.291098479734196e-6]
 ⋮
 [0.03909671115400585, 0.16021388214020088, 2.863393797290316e-9, 0.0031978042762335662, 3.0843925599405756e-7, 2.588368231701203e-7, 0.09791348199751557, 0.30230016229129175, 0.009735232023433897, 2.868786924051746e-8, 2.0384970968272198e-8, 0.0002330184586693148, 2.6577021690955245e-5, 2.9649704462246316e-5, 0.0006371402432266941, 2.5202240411657423e-18, 0.006990490567780576, 9.509432219422943e-6, 5.814540574029035e-7, 1.2553993409201942e-5]
 [0.04007594328989523, 0.15887797935273862, 2.9352999831810086e-9, 0.0033061459028971988, 3.0068637733707693e-7, 2.504304876371835e-7, 0.09692151124673885, 0.30340723091376903, 0.009610779514983223, 2.7692637623148513e-8, 1.9663322731706254e-8, 0.0003416805573576498, 3.977558338946253e-5, 2.840006610578639e-5, 0.0009758574296736734, 2.6056092456968673e-18, 0.006985941923970138, 1.405807602985967e-5, 6.65286868027656e-7, 1.4889528717591963e-5]
 [0.0414930713952667, 0.1569236564001045, 3.039341535694452e-9, 0.0034666133154929975, 2.898631533374969e-7, 2.387643153577775e-7, 0.09546210819138151, 0.3050336473820511, 0.009430661992494614, 2.6329882649136633e-8, 1.8675357206607864e-8, 0.0004991324605025568, 5.853821267927339e-5, 2.6647875119831033e-5, 0.0014885730747294943, 2.7320753443425123e-18, 0.006979264491790816, 2.0735508209182298e-5, 7.587613195129447e-7, 1.77010779503414e-5]
 [0.043416636083269844, 0.15422706616750667, 3.180570155809784e-9, 0.0036919031761507366, 2.7613029280705503e-7, 2.2401971337643903e-7, 0.09343238864267965, 0.3072912798514192, 0.009185840124906988, 2.4636441831344505e-8, 1.744801635899646e-8, 0.0007136662086042755, 8.322339134897651e-5, 2.4478732310215853e-5, 0.00222970741931009, 2.9096287134715613e-18, 0.006970003005636785, 2.999699436321478e-5, 8.674683665258634e-7, 2.1249735099046842e-5]
 [0.04576994195589239, 0.15085317855916136, 3.3533971788025496e-9, 0.003980365145865279, 2.6061559981020415e-7, 2.074588530091386e-7, 0.09086737982791197, 0.31013781522691053, 0.008885404597732977, 2.277372099981477e-8, 1.6098530016404735e-8, 0.000978087639936781, 0.0001118726206466993, 2.2107897700089242e-5, 0.003212277486458904, 3.1369687031137414e-18, 0.006958331427300152, 4.1668572699848246e-5, 9.995840133870664e-7, 2.586489691375637e-5]
 [0.048565491423233624, 0.14672814420651925, 3.5587955651609294e-9, 0.0043436377290348, 2.436885249154007e-7, 1.8954702477757186e-7, 0.08769384121091091, 0.3136509304063337, 0.008526637098039115, 2.0805075712340766e-8, 1.4673027610821725e-8, 0.0012960907515314885, 0.00014309518242210212, 1.9622919170204742e-5, 0.004497745363779089, 3.4232677441165217e-18, 0.006943923280400517, 5.607671959948275e-5, 1.1700945109085837e-6, 3.21768647676605e-5]
 [0.05174083432863735, 0.1418706120130952, 3.792244805244997e-9, 0.00478756515261096, 2.260144308047927e-7, 1.7108314017697025e-7, 0.08390461967970261, 0.31783475059500227, 0.00811565776886708, 1.882072909515642e-8, 1.3237032070355706e-8, 0.0016641981445851158, 0.00017396213714284656, 1.7146473896493043e-5, 0.006131731292169565, 3.773131734775514e-18, 0.006926739428155184, 7.326057184481697e-5, 1.3884790514943577e-6, 4.073587495191291e-5]
 [0.055221414196813166, 0.13630373356524159, 4.0483477151717606e-9, 0.005319807138831808, 2.080450144241726e-7, 1.5265565180019845e-7, 0.07949158728346996, 0.32269460942172196, 0.00765898912844823, 1.6873902325216683e-8, 1.1829162157896872e-8, 0.002079000018354831, 0.00020101384715833485, 1.475679301301915e-5, 0.008167859927842944, 4.192597384803209e-18, 0.006906714474258816, 9.328552574118534e-5, 1.6636577728168648e-6, 5.2157402585685636e-5]
 [0.056462553323845074, 0.13424841358635414, 4.139734221239658e-9, 0.005523140190492613, 2.0189768077835197e-7, 1.4645415660794528e-7, 0.07784249229110898, 0.3245075344177776, 0.007494013207038758, 1.622292918349514e-8, 1.1358636563258352e-8, 0.002230506106738904, 0.00020871632118130894, 1.3969187731602392e-5, 0.008964885874226987, 4.352846355938725e-18, 0.006899219697884304, 0.00010078030211569819, 1.7721447337603926e-6, 5.682937482947947e-5]</code></pre><pre><code class="language-julia hljs">plot(sol)</code></pre><img src="070f024a.svg" alt="Example block output"/><pre><code class="language-julia hljs">plot(sol, xscale=:log10, tspan=(1e-6, 60), layout=(3,1))</code></pre><img src="ed5b03d4.svg" alt="Example block output"/><h3 id="Van-Der-Pol-Equations:-Singular-Perturbation-Problems-and-DAEs"><a class="docs-heading-anchor" href="#Van-Der-Pol-Equations:-Singular-Perturbation-Problems-and-DAEs">Van Der Pol Equations: Singular Perturbation Problems and DAEs</a><a id="Van-Der-Pol-Equations:-Singular-Perturbation-Problems-and-DAEs-1"></a><a class="docs-heading-anchor-permalink" href="#Van-Der-Pol-Equations:-Singular-Perturbation-Problems-and-DAEs" title="Permalink"></a></h3><p>Next up is the Van Der Pol Equations which is a canonical example of a singular perturbation problem:</p><pre><code class="language-julia hljs">function van(du,u,p,t)
    y,x = u
    μ = p
    du[1] = μ*((1-x^2)*y - x)
    du[2] = 1*y
end

prob = ODEProblem(van,[1.0;1.0],(0.0,6.3),1e6)
sol = solve(prob, Rodas5P())
plot(sol)</code></pre><img src="f6c82c97.svg" alt="Example block output"/><p>or zooming in:</p><pre><code class="language-julia hljs">plot(sol, ylim=[-4;4])</code></pre><img src="e39b72fa.svg" alt="Example block output"/><p>A singular perturbation problem is an ODE given by the form:</p><p class="math-container">\[x&#39; = f(x,y,t)\\
\epsilon y&#39; = g(x,y,t)\]</p><p>where <span>$\epsilon$</span> is sufficiently small. Notice that the Van Der Pol equations,</p><p class="math-container">\[x&#39; = y\\
y&#39; = \mu ((1-x^2)y -x)\]</p><p>can be rewritten as:</p><p class="math-container">\[x&#39; = y\\
\epsilon y&#39; = (1-x^2)y -x\]</p><p>by making <span>$\epsilon = \frac{1}{\mu}$</span>. Thus when <span>$\mu$</span> is big, <span>$\epsilon$</span> is small. In this form it&#39;s clear that <span>$\epsilon$</span> is the time-scale difference between the changes in <span>$x$</span> and the changes in <span>$y$</span>. When this difference is large, i.e. <span>$\mu$</span> is big, then our previous discussion suggests that this should change the stiffness. Let&#39;s see this in practice:</p><pre><code class="language-julia hljs"># small mu
prob = ODEProblem(van,[1.0;1.0],(0.0,6.3),500)
# explicit RK solution
sol = solve(prob,Tsit5())
plot(sol, ylim=[-4;4])</code></pre><img src="48c4b032.svg" alt="Example block output"/><pre><code class="language-julia hljs"># big mu
prob = ODEProblem(van,[1.0;1.0],(0.0,6.3),1e6)
# explicit RK solution
sol = solve(prob,Tsit5())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: MaxIters
Interpolation: specialized 4th order &quot;free&quot; interpolation
t: 999967-element Vector{Float64}:
 0.0
 1.4142135623723879e-6
 1.5556349186096265e-5
 5.064808332629735e-5
 9.141714346641453e-5
 0.00013159621249585464
 0.0001643364000193749
 0.0001814117752651743
 0.00019048244999619597
 0.00019562813286395545
 ⋮
 1.8454390443485207
 1.8454405286737303
 1.8454420130016336
 1.8454434973322302
 1.8454449816654221
 1.8454464660012093
 1.8454479503395917
 1.845449434680766
 1.8454509190246338
u: 999967-element Vector{Vector{Float64}}:
 [1.0, 1.0]
 [-0.4142142625400887, 1.0000004142130319]
 [-14.566967050424426, 0.9998945259848284]
 [-51.181954238945295, 0.9987529979984154]
 [-109.7644012955115, 0.9955835526886252]
 [-253.72726534691068, 0.9888631462607406]
 [-834.7745679124318, 0.9739545463817227]
 [-2872.4860041203997, 0.947638008236739]
 [-10069.848884501966, 0.8988637843697357]
 [-38569.75311229706, 0.7971021527741678]
 ⋮
 [0.7758666698780496, -1.8337363813628822]
 [0.7758675699617644, -1.8337352292955171]
 [0.7758684700026367, -1.833734077224725]
 [0.7758693700006768, -1.833732925150506]
 [0.7758702700765642, -1.8337317730729359]
 [0.7758711702303155, -1.833730620992015]
 [0.7758720704619425, -1.8337294689077432]
 [0.7758729705301266, -1.833728316819968]
 [0.7758738705555462, -1.8337271647287656]</code></pre><p>We can see directly that the time scale separation forces the explicit Runge-Kutta method to exit with MaxIters, i.e. it hit its maximum iterations. The reason why it hit maximum iterations is because the time scale separation increased, and therefore the <code>dt</code> limit for stability decreased, and therefore it started requiring too many steps (default 1e5) in order to solve the equation.</p><p><strong>Notably, this shows that stiffness is a parameter-dependent phonomena</strong></p><p>If you change the parameter values, you can change whether an equation is stiff or non-stiff.</p><p>However... what happens in the limit as <span>$\mu \rightarrow \infty$</span>? In some sense, this is &quot;the limit as stiffness goes to infinity&quot;. In that limit, <span>$\epsilon \rightarrow 0$</span>, and therefore we arrive at the equation:</p><p class="math-container">\[x&#39; = y\\
0 = (1-x^2)y - x\]</p><p>This equation is a <strong>Differential-Algebraic Equation (DAE)</strong>, where <span>$x&#39; = y$</span> is a differential equation and <span>$0 = (1-x^2)y -x$</span> is a nonlinear algebraic equation. In this limit, the fast behavior is so fast that it&#39;s instant. Thinking back to our picture of stiffness, it means any perturbation from the slow manifold would instantly fall back onto the slow manifold. For these types of problem then, it&#39;s clear that handling the equation implicitly is potentially required for two reasons. For one, it&#39;s infinitely stiff, and the &quot;more stiff&quot; an equation is, the more one requires using implicit methods</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>There are explicit methods for stiff equations, such as Runge-Kutta Chebyshev methods and exponential integrators. For the purposes of this discussion we simplify and say solving stiff equations requires implicit methods, but this caveat should be noted as there are notable exceptions to this rule. However, the most generally used methods on stiff equations are undoubtably implicit methods.</p></div></div><h3 id="Representations-of-DAEs-as-Mass-Matrix-ODEs"><a class="docs-heading-anchor" href="#Representations-of-DAEs-as-Mass-Matrix-ODEs">Representations of DAEs as Mass Matrix ODEs</a><a id="Representations-of-DAEs-as-Mass-Matrix-ODEs-1"></a><a class="docs-heading-anchor-permalink" href="#Representations-of-DAEs-as-Mass-Matrix-ODEs" title="Permalink"></a></h3><p>Take Van Der Pol&#39;s Equation</p><p class="math-container">\[x&#39; = y\\
0 = (1-x^2)y - x\]</p><p>In order to more succinctly represent this to an ODE solver, notice that if we take the mass matrix <code>[1 0;0 0]</code>, then the form:</p><p class="math-container">\[Mu&#39; = f(u,t)\]</p><p>is a representation of the Van Der Pol equation. Notably, the &quot;standard&quot; ODE from before is of the same form, simply with <span>$M = I$</span>. If the mass matrix <span>$M$</span> is non-singular, then the equation is a mass matrix ODE which does not represent a DAE. However, if <span>$M$</span> is singular, then the equation is implicitly specifying an algebraic equation, like as in the Van Der Pol equation, and its in this case that a mass matrix ODE is representing a DAE.</p><h3 id="The-Three-Canonical-Representations-of-DAEs"><a class="docs-heading-anchor" href="#The-Three-Canonical-Representations-of-DAEs">The Three Canonical Representations of DAEs</a><a id="The-Three-Canonical-Representations-of-DAEs-1"></a><a class="docs-heading-anchor-permalink" href="#The-Three-Canonical-Representations-of-DAEs" title="Permalink"></a></h3><p>This shows the three canonical ways that DAEs can be represented. The first is the semi-explicit ODE in the split function form:</p><p class="math-container">\[x&#39; = f(x,y,t)\\
0 = g(x,y,t)\]</p><p>where <span>$x$</span> are the differential variables (generally a vector) and <span>$y$</span> is a vector of algebraic variables. The second form is the mass matrix ODE form:</p><p class="math-container">\[Mu&#39; = f(u,t)\]</p><p>where the mass matrix <span>$M$</span> is singular. In this form, the algebraic equations can be sometimes easily understood via a constant zero row in the mass matrix <span>$M$</span>, with the differential variables being the values for which the derivative appears in the equation and the other variables being the algebraic variables. Note that this description is purposefully vague as we will see that not all equations can be cleanly separated like this in the more general forms.</p><p>Finally, the most general form is simply the implicit ODE form:</p><p class="math-container">\[0 = f(u&#39;,u,t)\]</p><p>This form is slightly more general since one can consider the mass matrix form as requiring that <span>$f(u&#39;,u,t)$</span> has a linear partial derivative with respect to the <span>$u&#39;$</span> term, with <span>$-M$</span> being that derivative. Thus it allows for example <span>$u_1&#39;^2$</span>.</p><p>Though note that this the mass matrix and the implicit ODE definitions are not a substantial difference as via a variable definition <span>$u_i = u_1^3$</span> and other tricks you can rewrite a term with nonlinear derivatives into one with linear derivative relationships, and thus arrive at a mass matrix form (with a larger set of equations). The semi-explicit ODE however is distinctly a subset of the possible DAEs, which will be explored in the symbolic sections in more detail.</p><h2 id="The-Steps-of-an-Implicit-Solver"><a class="docs-heading-anchor" href="#The-Steps-of-an-Implicit-Solver">The Steps of an Implicit Solver</a><a id="The-Steps-of-an-Implicit-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#The-Steps-of-an-Implicit-Solver" title="Permalink"></a></h2><h3 id="Newton&#39;s-Method-and-Jacobians"><a class="docs-heading-anchor" href="#Newton&#39;s-Method-and-Jacobians">Newton&#39;s Method and Jacobians</a><a id="Newton&#39;s-Method-and-Jacobians-1"></a><a class="docs-heading-anchor-permalink" href="#Newton&#39;s-Method-and-Jacobians" title="Permalink"></a></h3><p>Recall that the implicit Euler method is the following:</p><p class="math-container">\[u_{n+1} = u_n + \Delta t f(u_{n+1},p,t + \Delta t)\]</p><p>If we wanted to use this method, we would need to find out how to get the value <span>$u_{n+1}$</span> when only knowing the value <span>$u_n$</span>. To do so, we can move everything to one side:</p><p class="math-container">\[u_{n+1} - \Delta t f(u_{n+1},p,t + \Delta t) - u_n = 0\]</p><p>and now we have a problem</p><p class="math-container">\[g(u_{n+1}) = 0\]</p><p>This is the classic rootfinding problem <span>$g(x)=0$</span>, find <span>$x$</span>. The way that we solve the rootfinding problem is, once again, by replacing this problem about a continuous function <span>$g$</span> with a discrete dynamical system whose steady state is the solution to the <span>$g(x)=0$</span>. There are many methods for this, but some choices of the rootfinding method effect the stability of the ODE solver itself since we need to make sure that the steady state solution is a stable steady state of the iteration process, otherwise the rootfinding method will diverge (will be explored in the homework).</p><p>Thus for example, fixed point iteration is not appropriate for stiff differential equations. Methods which are used in the stiff case are either Anderson Acceleration or Newton&#39;s method. Newton&#39;s is by far the most common (and generally performs the best), so we can go down this route.</p><p>Let&#39;s use the syntax <span>$g(x)=0$</span>. Here we need some starting value <span>$x_0$</span> as our first guess for <span>$u_{n+1}$</span>. The easiest guess is <span>$u_{n}$</span>, though additional information about the equation can be used to compute a better starting value (known as a <em>step predictor</em>). Once we have a starting value, we run the iteration:</p><p class="math-container">\[x_{k+1} = x_k - J(x_k)^{-1}g(x_k)\]</p><p>where <span>$J(x_k)$</span> is the Jacobian of <span>$g$</span> at the point <span>$x_k$</span>. However, the mathematical formulation is never the syntax that you should use for the actual application! Instead, numerically this is two stages:</p><ul><li>Solve <span>$Ja=g(x_k)$</span> for <span>$a$</span></li><li>Update <span>$x_{k+1} = x_k - a$</span></li></ul><p>By doing this, we can turn the matrix inversion into a problem of a linear solve and then an update. The reason this is done is manyfold, but one major reason is because the inverse of a sparse matrix can be dense, and this Jacobian is in many cases (PDEs) a large and dense matrix.</p><p>Now let&#39;s break this down step by step.</p><h2 id="Some-Quick-Notes"><a class="docs-heading-anchor" href="#Some-Quick-Notes">Some Quick Notes</a><a id="Some-Quick-Notes-1"></a><a class="docs-heading-anchor-permalink" href="#Some-Quick-Notes" title="Permalink"></a></h2><p>The Jacobian of <span>$g$</span> can also be written as <span>$J = I - \gamma \frac{df}{du}$</span> for the ODE <span>$u&#39; = f(u,p,t)$</span>, where <span>$\gamma = \Delta t$</span> for the implicit Euler method. This general form holds for all other (SDIRK) implicit methods, changing the value of <span>$\gamma$</span>. Additionally, the class of Rosenbrock methods solves a linear system with exactly the same <span>$J$</span>, meaning that essentially all implicit and semi-implicit ODE solvers have to do the same Newton iteration process on the same structure. This is the portion of the code that is generally the bottleneck.</p><p>Additionally, if one is solving a mass matrix ODE: <span>$Mu&#39; = f(u,p,t)$</span>, exactly the same treatment can be had with <span>$J = M - \gamma \frac{df}{du}$</span>. This works even if <span>$M$</span> is singular, a case known as a <em>differential-algebraic equation</em> or a DAE. A DAE for example can be an ODE with constraint equations, and these structures can be represented as an ODE where these constraints lead to a singularity in the mass matrix (a row of all zeros is a term that is only the right hand side equals zero!).</p><h2 id="Generation-of-the-Jacobian"><a class="docs-heading-anchor" href="#Generation-of-the-Jacobian">Generation of the Jacobian</a><a id="Generation-of-the-Jacobian-1"></a><a class="docs-heading-anchor-permalink" href="#Generation-of-the-Jacobian" title="Permalink"></a></h2><h3 id="Dense-Finite-Differences-and-Forward-Mode-AD"><a class="docs-heading-anchor" href="#Dense-Finite-Differences-and-Forward-Mode-AD">Dense Finite Differences and Forward-Mode AD</a><a id="Dense-Finite-Differences-and-Forward-Mode-AD-1"></a><a class="docs-heading-anchor-permalink" href="#Dense-Finite-Differences-and-Forward-Mode-AD" title="Permalink"></a></h3><p>Recall that the Jacobian is the matrix of <span>$\frac{df_i}{dx_j}$</span> for <span>$f$</span> a vector-valued function. The simplest way to generate the Jacobian is through finite differences. For each <span>$h_j = h e_j$</span> for <span>$e_j$</span> the basis vector of the <span>$j$</span>th axis and some sufficiently small <span>$h$</span>, then we can compute column <span>$j$</span> of the Jacobian by:</p><p class="math-container">\[\frac{f(x+h_j)-f(x)}{h}\]</p><p>Thus <span>$m+1$</span> applications of <span>$f$</span> are required to compute the full Jacobian.</p><p>This can be improved by using forward-mode automatic differentiation. Recall that we can formulate a multidimensional duel number of the form</p><p class="math-container">\[d = x + v_1 \epsilon_1 + \ldots + v_m \epsilon_m\]</p><p>We can then seed the vectors <span>$v_j = h_j$</span> so that the differentiation directions are along the basis vectors, and then the output dual is the result:</p><p class="math-container">\[f(d) = f(x) + J_1 \epsilon_1 + \ldots + J_m \epsilon_m\]</p><p>where <span>$J_j$</span> is the <span>$j$</span>th column of the Jacobian. And thus with one calculation of the <em>primal</em> (f(x)) we have calculated the entire Jacobian.</p><h3 id="Sparse-Differentiation-and-Matrix-Coloring"><a class="docs-heading-anchor" href="#Sparse-Differentiation-and-Matrix-Coloring">Sparse Differentiation and Matrix Coloring</a><a id="Sparse-Differentiation-and-Matrix-Coloring-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-Differentiation-and-Matrix-Coloring" title="Permalink"></a></h3><p>However, when the Jacobian is sparse we can compute it much faster. We can understand this by looking at the following system:</p><p class="math-container">\[f(x)=\left[\begin{array}{c}
x_{1}+x_{3}\\
x_{2}x_{3}\\
x_{1}
\end{array}\right]\]</p><p>Notice that in 3 differencing steps we can calculate:</p><p class="math-container">\[f(x+\epsilon e_{1})=\left[\begin{array}{c}
x_{1}+x_{3}+\epsilon\\
x_{2}x_{3}\\
x_{1}+\epsilon
\end{array}\right]\]</p><p class="math-container">\[f(x+\epsilon e_{2})=\left[\begin{array}{c}
x_{1}+x_{3}\\
x_{2}x_{3}+\epsilon x_{3}\\
x_{1}
\end{array}\right]\]</p><p class="math-container">\[f(x+\epsilon e_{3})=\left[\begin{array}{c}
x_{1}+x_{3}+\epsilon\\
x_{2}x_{3}+\epsilon x_{2}\\
x_{1}
\end{array}\right]\]</p><p>and thus:</p><p class="math-container">\[\frac{f(x+\epsilon e_{1})-f(x)}{\epsilon}=\left[\begin{array}{c}
1\\
0\\
1
\end{array}\right]\]</p><p class="math-container">\[\frac{f(x+\epsilon e_{2})-f(x)}{\epsilon}=\left[\begin{array}{c}
0\\
x_{3}\\
0
\end{array}\right]\]</p><p class="math-container">\[\frac{f(x+\epsilon e_{3})-f(x)}{\epsilon}=\left[\begin{array}{c}
1\\
x_{2}\\
0
\end{array}\right]\]</p><p>But notice that the calculation of <span>$e_1$</span> and <span>$e_2$</span> do not interact. If we had done:</p><p class="math-container">\[\frac{f(x+\epsilon e_{1}+\epsilon e_{2})-f(x)}{\epsilon}=\left[\begin{array}{c}
1\\
x_{3}\\
1
\end{array}\right]\]</p><p>we would still get the correct value for every row because the <span>$\epsilon$</span> terms do not collide (a situation known as <em>perturbation confusion</em>). If we knew the sparsity pattern of the Jacobian included a 0 at (2,1), (1,2), and (3,2), then we would know that the vectors would have to be <span>$[1 0 1]$</span> and <span>$[0 x_3 0]$</span>, meaning that columns 1 and 2 can be computed simultaneously and decompressed. This is the key to sparse differentiation.</p><p><img src="https://user-images.githubusercontent.com/1814174/66027457-efd7cc00-e4c8-11e9-8346-accf468541fb.PNG" alt/></p><p>With forward-mode automatic differentiation, recall that we calculate multiple dimensions simultaneously by using a multidimensional dual number seeded by the vectors of the differentiation directions, that is:</p><p class="math-container">\[d = x + v_1 \epsilon_1 + \ldots + v_m \epsilon_m\]</p><p>Instead of using the primitive differentiation directions <span>$e_j$</span>, we can instead replace this with the mixed values. For example, the Jacobian of the example function can be computed in one function call to <span>$f$</span> with the dual number input:</p><p class="math-container">\[d = x + (e_1 + e_2) \epsilon_1 + e_3 \epsilon_2\]</p><p>and performing the decompression via the sparsity pattern. Thus the sparsity pattern gives a direct way to optimize the construction of the Jacobian.</p><p>This idea of independent directions can be formalized as a <em>matrix coloring</em>. Take <span>$S_{ij}$</span> the sparsity pattern of some Jacobian matrix <span>$J_{ij}$</span>. Define a graph on the nodes 1 through m where there is an edge between <span>$i$</span> and <span>$j$</span> if there is a row where <span>$i$</span> and <span>$j$</span> are non-zero. This graph is the column connectivity graph of the Jacobian. What we wish to do is find the smallest set of differentiation directions such that differentiating in the direction of <span>$e_i$</span> does not collide with differentiation in the direction of <span>$e_j$</span>. The connectivity graph is setup so that way this cannot be done if the two nodes are adjacent. If we let the subset of nodes differentiated together be a <em>color</em>, the question is, what is the smallest number of colors s.t. no adjacent nodes are the same color. This is the classic <em>distance-1 coloring problem</em> from graph theory. It is well-known that the problem of finding the <em>chromatic number</em>, the minimal number of colors for a graph, is generally NP-complete. However, there are heuristic methods for performing a distance-1 coloring quite quickly. For example, a greedy algorithm is as follows:</p><ul><li>Pick a node at random to be color 1.</li><li>Make all nodes adjacent to that be the lowest color that they can be (in this step that will be 2).</li><li>Now look at all nodes adjacent to that. Make all nodes be the lowest color that they can be (either 1 or 3).</li><li>Repeat by looking at the next set of adjacent nodes and color as conservatively as possible.</li></ul><p>This can be visualized as follows:</p><p><img src="https://user-images.githubusercontent.com/1814174/66027433-e189b000-e4c8-11e9-8c2e-3999954cda28.PNG" alt/></p><p>The result will color the entire connected component. While not giving an optimal result, it will still give a result that is a sufficient reduction in the number of differentiation directions (without solving an NP-complete problem) and thus can lead to a large computational saving.</p><p>At the end, let <span>$c_i$</span> be the vector of 1&#39;s and 0&#39;s, where it&#39;s 1 for every node that is color <span>$i$</span> and 0 otherwise. Sparse automatic differentiation of the Jacobian is then computed with:</p><p class="math-container">\[d = x + c_1 \epsilon_1 + \ldots + c_k \epsilon_k\]</p><p>that is, the full Jacobian is computed with one dual number which consists of the primal calculation along with <span>$k$</span> dual dimensions, where <span>$k$</span> is the computed chromatic number of the connectivity graph on the Jacobian. Once this calculation is complete, the colored columns can be decompressed into the full Jacobian using the sparsity information, generating the original quantity that we wanted to compute.</p><p>For more information on the graph coloring aspects, find the paper titled &quot;What Color Is Your Jacobian? Graph Coloring for Computing Derivatives&quot; by Gebremedhin.</p><h4 id="Note-on-Sparse-Reverse-Mode-AD"><a class="docs-heading-anchor" href="#Note-on-Sparse-Reverse-Mode-AD">Note on Sparse Reverse-Mode AD</a><a id="Note-on-Sparse-Reverse-Mode-AD-1"></a><a class="docs-heading-anchor-permalink" href="#Note-on-Sparse-Reverse-Mode-AD" title="Permalink"></a></h4><p>Reverse-mode automatic differentiation can be though of as a method for computing one row of a Jacobian per seed, as opposed to one column per seed given by forward-mode AD. Thus sparse reverse-mode automatic differentiation can be done by looking at the connectivity graph of the column and using the resulting color vectors to seed the reverse accumulation process.</p><h2 id="Linear-Solving"><a class="docs-heading-anchor" href="#Linear-Solving">Linear Solving</a><a id="Linear-Solving-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Solving" title="Permalink"></a></h2><p>After the Jacobian has been computed, we need to solve a linear equation <span>$Ja=b$</span>. While mathematically you can solve this by computing the inverse <span>$J^{-1}$</span>, this is not a good way to perform the calculation because even if <span>$J$</span> is sparse, then <span>$J^{-1}$</span> is in general dense and thus may not fit into memory (remember, this is <span>$N^2$</span> as many terms, where <span>$N$</span> is the size of the ordinary differential equation that is being solved, so if it&#39;s a large equation it is very feasible and common that the ODE is representable but its full Jacobian is not able to fit into RAM). Note that some may say that this is done for numerical stability reasons: that is incorrect. In fact, under reasonable assumptions for how the inverse is computed, it will be as numerically stable as other techniques we will mention.</p><p>Thus instead of generating the inverse, we can instead perform a <em>matrix factorization</em>. A matrix factorization is a transformation of the matrix into a form that is more amenable to certain analyses. For our purposes, a general Jacobian within a Newton iteration can be transformed via the <em>LU-factorization</em> or (<em>LU-decomposition</em>), i.e.</p><p class="math-container">\[J = LU\]</p><p>where <span>$L$</span> is lower triangular and <span>$U$</span> is upper triangular. If we write the linear equation in this form:</p><p class="math-container">\[LUa = b\]</p><p>then we see that we can solve it by first solving <span>$L(Ua) = b$</span>. Since <span>$L$</span> is lower triangular, this is done by the backsubstitution algorithm. That is, in a lower triangular form, we can solve for the first value since we have:</p><p class="math-container">\[L_{11} a_1 = b_1\]</p><p>and thus by dividing we solve. For the next term, we have that</p><p class="math-container">\[L_{21} a_1 + L_{22} a_2 = b_2\]</p><p>and thus we plug in the solution to <span>$a_1$</span> and solve to get <span>$a_2$</span>. The lower triangular form allows this to continue. This occurs in 1+2+3+...+n operations, and is thus O(n^2). Next, we solve <span>$Ua = b$</span>, which once again is done by a backsubstitution algorithm but in the reverse direction. Together those two operations are O(n^2) and complete the inversion of <span>$LU$</span>.</p><p>So is this an O(n^2) algorithm for computing the solution of a linear system? No, because the computation of <span>$LU$</span> itself is an O(n^3) calculation, and thus the true complexity of solving a linear system is still O(n^3). However, if we have already factorized <span>$J$</span>, then we can repeatedly use the same <span>$LU$</span> factors to solve additional linear problems <span>$Jv = u$</span> with different vectors. We can exploit this to accelerate the Newton method. Instead of doing the calculation:</p><p class="math-container">\[x_{k+1} = x_k - J(x_k)^{-1}g(x_k)\]</p><p>we can instead do:</p><p class="math-container">\[x_{k+1} = x_k - J(x_0)^{-1}g(x_k)\]</p><p>so that all of the Jacobians are the same. This means that a single O(n^3) factorization can be done, with multiple O(n^2) calculations using the same factorization. This is known as a Quasi-Newton method. While this makes the Newton method no longer quadratically convergent, it minimizes the large constant factor on the computational cost while retaining the same dynamical properties, i.e. the same steady state and thus the same overall solution. This makes sense for sufficiently large <span>$n$</span>, but requires sufficiently large <span>$n$</span> because the loss of quadratic convergence means that it will take more steps to converge than before, and thus more <span>$O(n^2)$</span> backsolves are required, meaning that the difference between factorizations and backsolves needs to be large enough in order to offset the cost of extra steps.</p><h4 id="Note-on-Sparse-Factorization"><a class="docs-heading-anchor" href="#Note-on-Sparse-Factorization">Note on Sparse Factorization</a><a id="Note-on-Sparse-Factorization-1"></a><a class="docs-heading-anchor-permalink" href="#Note-on-Sparse-Factorization" title="Permalink"></a></h4><p>Note that LU-factorization, and other factorizations, have generalizations to sparse matrices where a <em>symbolic factorization</em> is utilized to compute a sparse storage of the values which then allow for a fast backsubstitution. More details are outside the scope of this course, but note that Julia and MATLAB will both use the library SuiteSparse in the background when <code>lu</code> is called on a sparse matrix.</p><h3 id="Jacobian-Free-Newton-Krylov-(JFNK)"><a class="docs-heading-anchor" href="#Jacobian-Free-Newton-Krylov-(JFNK)">Jacobian-Free Newton Krylov (JFNK)</a><a id="Jacobian-Free-Newton-Krylov-(JFNK)-1"></a><a class="docs-heading-anchor-permalink" href="#Jacobian-Free-Newton-Krylov-(JFNK)" title="Permalink"></a></h3><p>An alternative method for solving the linear system is the Jacobian-Free Newton Krylov technique. This technique is broken into two pieces: the <em>jvp</em> calculation and the Krylov subspace iterative linear solver.</p><h3 id="Jacobian-Vector-Products-as-Directional-Derivatives"><a class="docs-heading-anchor" href="#Jacobian-Vector-Products-as-Directional-Derivatives">Jacobian-Vector Products as Directional Derivatives</a><a id="Jacobian-Vector-Products-as-Directional-Derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Jacobian-Vector-Products-as-Directional-Derivatives" title="Permalink"></a></h3><p>We don&#39;t actually need to compute <span>$J$</span> itself, since all that we actually need is the <code>v = J*w</code>. Is it possible to compute the <em>Jacobian-Vector Product</em>, or the jvp, without producing the Jacobian?</p><p>To see how this is done let&#39;s take a look at what is actually calculated. Written out in the standard basis, we have that:</p><p class="math-container">\[w_i = \sum_{j}^{m} J_{ij} v_{j}\]</p><p>Now write out what <span>$J$</span> means and we see that:</p><p class="math-container">\[w_i = \sum_j^{m} \frac{df_i}{dx_j} v_j = \nabla f_i(x) \cdot v\]</p><p>that is, the <span>$i$</span>th component of <span>$Jv$</span> is the directional derivative of <span>$f_i$</span> in the direction <span>$v$</span>. This means that in general, the jvp <span>$Jv$</span> is actually just the directional derivative in the direction of <span>$v$</span>, that is:</p><p class="math-container">\[Jv = \nabla f \cdot v\]</p><p>and therefore it has another mathematical representation, that is:</p><p class="math-container">\[Jv = \lim_{\epsilon \rightarrow 0} \frac{f(x+v \epsilon) - f(x)}{\epsilon}\]</p><p>From this alternative form it is clear that <strong>we can always compute a jvp with a single computation</strong>. Using finite differences, a simple approximation is the following:</p><p class="math-container">\[Jv \approx \frac{f(x+v \epsilon) - f(x)}{\epsilon}\]</p><p>for non-zero <span>$\epsilon$</span>. Similarly, recall that in forward-mode automatic differentiation we can choose directions by seeding the dual part. Therefore, using the dual number with one partial component:</p><p class="math-container">\[d = x + v \epsilon\]</p><p>we get that</p><p class="math-container">\[f(d) = f(x) + Jv \epsilon\]</p><p>and thus a single application with a single partial gives the jvp.</p><h4 id="Note-on-Reverse-Mode-Automatic-Differentiation"><a class="docs-heading-anchor" href="#Note-on-Reverse-Mode-Automatic-Differentiation">Note on Reverse-Mode Automatic Differentiation</a><a id="Note-on-Reverse-Mode-Automatic-Differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Note-on-Reverse-Mode-Automatic-Differentiation" title="Permalink"></a></h4><p>As noted earlier, reverse-mode automatic differentiation has its primitives compute rows of the Jacobian in the seeded direction. This means that the seeded reverse-mode call with the vector <span>$v$</span> computes <span>$v^T J$</span>, that is the <em>vector (transpose) Jacobian transpose</em>, or <em>vjp</em> for short. When discussing parameter estimation and adjoints, this shorthand will be introduced as a way for using a traditionally machine learning tool to accelerate traditionally scientific computing tasks.</p><h3 id="Krylov-Subspace-Methods-For-Solving-Linear-Systems"><a class="docs-heading-anchor" href="#Krylov-Subspace-Methods-For-Solving-Linear-Systems">Krylov Subspace Methods For Solving Linear Systems</a><a id="Krylov-Subspace-Methods-For-Solving-Linear-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Krylov-Subspace-Methods-For-Solving-Linear-Systems" title="Permalink"></a></h3><h4 id="Basic-Iterative-Solver-Methods"><a class="docs-heading-anchor" href="#Basic-Iterative-Solver-Methods">Basic Iterative Solver Methods</a><a id="Basic-Iterative-Solver-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Iterative-Solver-Methods" title="Permalink"></a></h4><p>Now that we have direct access to quick calculations of <span>$Jv$</span>, how would we use this to solve the linear system <span>$Jw = v$</span> quickly? This is done through <em>iterative linear solvers</em>. These methods replace the process of solving for a factorization with, you may have guessed it, a discrete dynamical system whose solution is <span>$w$</span>. To do this, what we want is some iterative process so that</p><p class="math-container">\[Jw - b = 0\]</p><p>So now let&#39;s split <span>$J = A - B$</span>, then if we are iterating the vectors <span>$w_k$</span> such that <span>$w_k \rightarrow w$</span>, then if we plug this into the previous (residual) equation we get</p><p class="math-container">\[A w_{k+1} = Bw_k + b\]</p><p>since when we plug in <span>$w$</span> we get zero (the sequence must be Cauchy so the difference <span>$w_{k+1} - w_k \rightarrow 0$</span>). Thus if we can split our matrix <span>$J$</span> into a component <span>$A$</span> which is easy to invert and a part <span>$B$</span> that is just everything else, then we would have a bunch of easy linear systems to solve. There are many different choices that we can do. If we let <span>$J = L + D + U$</span>, where <span>$L$</span> is the lower portion of <span>$J$</span>, <span>$D$</span> is the diagonal, and <span>$U$</span> is the upper portion, then the following are well-known methods:</p><ul><li>Richardson: <span>$A = \omega I$</span> for some <span>$\omega$</span></li><li>Jacobi: <span>$A = D$</span></li><li>Damped Jacobi: <span>$A = \omega D$</span></li><li>Gauss-Seidel: <span>$A = D-L$</span></li><li>Successive Over Relaxation: <span>$A = \omega D - L$</span></li><li>Symmetric Successive Over Relaxation: <span>$A = \frac{1}{\omega (2 - \omega)}(D-\omega L)D^{-1}(D-\omega U)$</span></li></ul><p>These decompositions are chosen since a diagonal matrix is easy to invert (it&#39;s just the inversion of the scalars of the diagonal) and it&#39;s easy to solve an upper or lower triangular linear system (once again, it&#39;s backsubstitution).</p><p>Since these methods give a a linear dynamical system, we know that there is a unique steady state solution, which happens to be <span>$Aw - Bw = Jw = b$</span>. Thus we will converge to it as long as the steady state is stable. To see if it&#39;s stable, take the update equation</p><p class="math-container">\[w_{k+1} = A^{-1}(Bw_k + b)\]</p><p>and check the eigenvalues of the system: if they are within the unit circle then you have stability. Notice that this can always occur by bringing the eigenvalues of <span>$A^{-1}$</span> closer to zero, which can be done by multiplying <span>$A$</span> by a significantly large value, hence the <span>$\omega$</span> quantities. While that always works, this essentially amounts to decreasing the stepsize of the iterative process and thus requiring more steps, thus making it take more computations. Thus the game is to pick the largest stepsize (<span>$\omega$</span>) for which the steady state is stable. We will leave that as outside the topic of this course.</p><h4 id="Krylov-Subspace-Methods"><a class="docs-heading-anchor" href="#Krylov-Subspace-Methods">Krylov Subspace Methods</a><a id="Krylov-Subspace-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Krylov-Subspace-Methods" title="Permalink"></a></h4><p>While the classical iterative solver methods give the background for understanding an alternative to direct inversion or factorization of a matrix, the problem with that approach is that it requires the ability to split the matrix <span>$J$</span>, which we would like to avoid computing. Instead, we would like to develop an iterative solver technique which instead just uses the solution to <span>$Jv$</span>. Indeed there are such methods, and these are the Krylov subspace methods. A Krylov subspace is the space spanned by:</p><p class="math-container">\[\mathcal{K}_k = \text{span} \{v,Jv,J^2 v, \ldots, J^k v\}\]</p><p>There are a few nice properties about Krylov subspaces that can be exploited. For one, it is known that there is a finite maximum dimension of the Krylov subspace, that is there is a value <span>$r$</span> such that <span>$J^{r+1} v \in \mathcal{K}_r$</span>, which means that the complete Krylov subspace can be computed in finitely many jvp, since <span>$J^2 v$</span> is just the jvp where the vector is the jvp. Indeed, one can show that <span>$J^i v$</span> is linearly independent for each <span>$i$</span>, and thus that maximal value is <span>$m$</span>, the dimension of the Jacobian. Therefore in <span>$m$</span> jvps the solution is guaranteed to live in the Krylov subspace, giving a maximal computational cost and a proof of convergence if the vector in there is the &quot;optimal in the space&quot;.</p><p>The most common method in the Krylov subspace family of methods is the GMRES method. Essentially, in step <span>$i$</span> one computes <span>$\mathcal{K}_i$</span>, and finds the <span>$x$</span> that is the closest to the Krylov subspace, i.e. finds the <span>$x \in \mathcal{K}_i$</span> such that <span>$\Vert Jx-v \Vert$</span> is minimized. At each step, it adds the new vector to the Krylov subspace after orthogonalizing it against the other vectors via Arnoldi iterations, leading to an orthogonal basis of <span>$\mathcal{K}_i$</span> which makes it easy to express <span>$x$</span>.</p><p>While one has a guaranteed bound on the number of possible jvps in GMRES which is simply the number of ODEs (since that is what determines the size of the Jacobian and thus the total dimension of the problem), that bound is not necessarily a good one. For a large sparse matrix, it may be computationally impractical to ever compute 100,000 jvps. Thus one does not typically run the algorithm to conclusion, and instead stops when <span>$\Vert Jx-v \Vert$</span> is sufficiently below some user-defined error tolerance.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lecture3/">« Solvers for Non-Stiff Ordinary Differential Equations</a><a class="docs-footer-nextpage" href="../lecture6/">Debugging difficult stiff ODE/DAE models »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Tuesday 7 May 2024 17:26">Tuesday 7 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
