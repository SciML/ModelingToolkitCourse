<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Debugging difficult stiff ODE/DAE models · ModelingToolkit Course</title><meta name="title" content="Debugging difficult stiff ODE/DAE models · ModelingToolkit Course"/><meta property="og:title" content="Debugging difficult stiff ODE/DAE models · ModelingToolkit Course"/><meta property="twitter:title" content="Debugging difficult stiff ODE/DAE models · ModelingToolkit Course"/><meta name="description" content="Documentation for ModelingToolkit Course."/><meta property="og:description" content="Documentation for ModelingToolkit Course."/><meta property="twitter:description" content="Documentation for ModelingToolkit Course."/><meta property="og:url" content="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture6/"/><meta property="twitter:url" content="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture6/"/><link rel="canonical" href="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture6/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelingToolkit Course</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../lecture1/">Introduction to acausal modeling for physical systems with ModelingToolkit.jl</a></li><li><a class="tocitem" href="../lecture2/">Developing high-fidelity models of hydraulic systems</a></li><li><a class="tocitem" href="../lecture3/">Solvers for Non-Stiff Ordinary Differential Equations</a></li><li><a class="tocitem" href="../lecture4/">Numerical Methods for Stiff ODEs and Differential-Algebraic Equations</a></li><li class="is-active"><a class="tocitem" href>Debugging difficult stiff ODE/DAE models</a><ul class="internal"><li><a class="tocitem" href="#Best-Practices"><span>Best Practices</span></a></li><li><a class="tocitem" href="#Debugging-Strategies"><span>Debugging Strategies</span></a></li></ul></li><li><a class="tocitem" href="../lecture7/">Numerical and Structural Characterizations for DAEs</a></li><li><a class="tocitem" href="../lecture8/">Dummy Derivatives and Reordering of Equations</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Debugging difficult stiff ODE/DAE models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Debugging difficult stiff ODE/DAE models</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkitCourse" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkitCourse/blob/main/docs/src/lectures/lecture6.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Debugging-difficult-stiff-ODE/DAE-models"><a class="docs-heading-anchor" href="#Debugging-difficult-stiff-ODE/DAE-models">Debugging difficult stiff ODE/DAE models</a><a id="Debugging-difficult-stiff-ODE/DAE-models-1"></a><a class="docs-heading-anchor-permalink" href="#Debugging-difficult-stiff-ODE/DAE-models" title="Permalink"></a></h1><p>Below is a list of best practices to help avoid problems in model development and strategies that can be used to debug a problematic model.</p><h2 id="Best-Practices"><a class="docs-heading-anchor" href="#Best-Practices">Best Practices</a><a id="Best-Practices-1"></a><a class="docs-heading-anchor-permalink" href="#Best-Practices" title="Permalink"></a></h2><p>In the world of programming, debugging a model has got to be the most challenging because all equations must be solved together.  If any equation is wrong then not only will the model not solve, but there is very little that can be done to identify which equation is problematic.  Therefore the best that we can do is implement best practices to ensure the model is correct from the beginning. </p><h3 id="Use-acausal-modeling-(i.e.-ModelingToolkit.jl)"><a class="docs-heading-anchor" href="#Use-acausal-modeling-(i.e.-ModelingToolkit.jl)">Use acausal modeling (i.e. ModelingToolkit.jl)</a><a id="Use-acausal-modeling-(i.e.-ModelingToolkit.jl)-1"></a><a class="docs-heading-anchor-permalink" href="#Use-acausal-modeling-(i.e.-ModelingToolkit.jl)" title="Permalink"></a></h3><p>As has been shown ModelingToolkit.jl will help in many ways with model definition.  One of the first programming practices that it enables is the DRY (Don&#39;t Repeat Yourself) principle.  By defining components once and reusing them, this helps reduce the chance of human error.  For example, when discovering a component level bug, it will be fixed at one source of truth and the fix will automatically propagate throughout.  </p><h3 id="Start-small-and-verify-components"><a class="docs-heading-anchor" href="#Start-small-and-verify-components">Start small and verify components</a><a id="Start-small-and-verify-components-1"></a><a class="docs-heading-anchor-permalink" href="#Start-small-and-verify-components" title="Permalink"></a></h3><p>In using acausal modeling, the main focus for ensuring well defined models lies mainly at the component level.  Make sure to implement the rules of thumb discussed previously for number of equations and sign conventions.   Each component should have a well defined unit test.  When building your model start with the smallest subsystem possible and build from there.  Attempting to build a full system model before checking the pieces is doomed to fail, leaving little to no insight into what went wrong.  When a model fails to run, the error message will rarely give enough information to pinpoint the problem.  The best tool for debugging is taking small incremental steps which allows one to identify which change caused the problem.  </p><h3 id="Make-sure-equations-match-states"><a class="docs-heading-anchor" href="#Make-sure-equations-match-states">Make sure equations match states</a><a id="Make-sure-equations-match-states-1"></a><a class="docs-heading-anchor-permalink" href="#Make-sure-equations-match-states" title="Permalink"></a></h3><p>It is not always the case, but for most models, the unsimplified system should give a match of equations and states.  Let&#39;s take the pendulum problem for example</p><pre><code class="language-julia hljs">using ModelingToolkit, DifferentialEquations, Plots
using ModelingToolkit: t_nounits as t, D_nounits as D

pars = @parameters m = 1 g = 1 L = 1 Φ=0

vars = @variables begin
    x(t)=+L*cos(Φ)
    y(t)=-L*sin(Φ)
    dx(t)=0
    dy(t)=0
    λ(t) = 0
end

eqs = [
    D(x) ~ dx
    D(y) ~ dy

    m*D(dx) ~ -λ*(x/L)
    m*D(dy) ~ -λ*(y/L) - m*g

    x^2 + y^2 ~ L^2 # algebraic constraint
]

@named pendulum = ODESystem(eqs, t, vars, pars)</code></pre><p>When we view the <code>ODESystem</code> we can see it has matching equations and states</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; pendulum</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">Model pendulum with 5 equations</span>
<span class="sgr1">Unknowns (5):</span>
  x(t) [defaults to L*cos(Φ)]
  y(t) [defaults to -L*sin(Φ)]
  dx(t) [defaults to 0]
  dy(t) [defaults to 0]
⋮
<span class="sgr1">Parameters (4):</span>
  m [defaults to 1]
  g [defaults to 1]
  L [defaults to 1]
  Φ [defaults to 0]</code></pre><p>Note: when using <code>@mtkbuild</code> then <code>structural_simplify</code> is automatically called and we therefore cannot see the unsimplify system.  Replace <code>@mtkbuild</code> with <code>@named</code> to generate an <code>ODESystem</code> without applying <code>structural_simplify</code>.</p><h3 id="Add-compliance"><a class="docs-heading-anchor" href="#Add-compliance">Add compliance</a><a id="Add-compliance-1"></a><a class="docs-heading-anchor-permalink" href="#Add-compliance" title="Permalink"></a></h3><p>The pendulum problem as described above is derived assuming the following:</p><ul><li>a massless perfectly stiff and rigid string/rod connected to the mass</li><li>a point mass</li><li>a frictionless mechanism</li></ul><p>If we attempt to solve this system we can see that it only solves up to the point that <code>x</code> crosses 0.</p><pre><code class="language-julia hljs">sys = complete(structural_simplify(pendulum))
prob = ODEProblem(sys, ModelingToolkit.missing_variable_defaults(sys), (0, 10))
sol = solve(prob)# gives retcode: DtLessThanMin
plot(sol; idxs=[x,y])</code></pre><img src="7bb0cfc8.svg" alt="Example block output"/><p>The problem is rooted in the algebraic constraint which has <code>x^2</code> and <code>y^2</code>.  Having exponents (squares or square roots) can often cause issues with numerical solutions.  In this case the issue is that a unique solution cannot be found, <code>x</code> could be positive or negative.  There are different solutions to this problem, however lets consider the concept of adding compliance.  In reality is it really possible to have a massless, perfectly stiff and rigid string?  No.  Therefore let&#39;s consider adjusting the problem so the string has stiffness, which means we add <code>L</code> now as a variable.</p><pre><code class="language-julia hljs">pars = @parameters m = 1 g = 1 L_0 = 1 Φ=0 k=1e6

vars = @variables begin
    L(t)=L_0
    x(t)=+L*cos(Φ)
    y(t)=-L*sin(Φ)
    dx(t)=0
    dy(t)=0
    λ(t) = 0
end

eqs = [
    D(x) ~ dx
    D(y) ~ dy

    m*D(dx) ~ -λ*(x/L)
    m*D(dy) ~ -λ*(y/L) - m*g

    x^2 + y^2 ~ L^2 # algebraic constraint

    λ ~ k*(L - L_0) # string stiffness
]

@named stiffness_pendulum = ODESystem(eqs, t, vars, pars)
sys = structural_simplify(stiffness_pendulum)
prob = ODEProblem(sys, ModelingToolkit.missing_variable_defaults(sys), (0, 10))
sol = solve(prob)# Success
plot(sol; idxs=[x,y])</code></pre><img src="f5ae4b99.svg" alt="Example block output"/><h3 id="Try-dae_index_lowering()"><a class="docs-heading-anchor" href="#Try-dae_index_lowering()">Try <code>dae_index_lowering()</code></a><a id="Try-dae_index_lowering()-1"></a><a class="docs-heading-anchor-permalink" href="#Try-dae_index_lowering()" title="Permalink"></a></h3><p>In some cases we can apply <code>dae_index_lowering()</code> to further simplify the problem.  In this case ModelingToolkit.jl finds a better form of the equations which can be solved without issue.</p><pre><code class="language-julia hljs">sys = structural_simplify(dae_index_lowering(pendulum))
prob = ODEProblem(sys, ModelingToolkit.missing_variable_defaults(sys), (0, 10))
ref = solve(prob)
plot(ref; idxs=x, label=&quot;dae_index_lowering&quot;)
plot!(sol; idxs=x, label=&quot;compliance&quot;)</code></pre><img src="c3d6c154.svg" alt="Example block output"/><h3 id="Design-components-with-variable-complexity/fidelity"><a class="docs-heading-anchor" href="#Design-components-with-variable-complexity/fidelity">Design components with variable complexity/fidelity</a><a id="Design-components-with-variable-complexity/fidelity-1"></a><a class="docs-heading-anchor-permalink" href="#Design-components-with-variable-complexity/fidelity" title="Permalink"></a></h3><p>In general this can be achieved with parameters.  For example, a <em>mass-spring-damper</em> system can easily become a <em>mass-damper</em> system by setting the spring stiffness to zero.  But in other cases we might want to <em>structurally</em> variable the complexity.  For example, the <code>ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.Tube</code> component has 2 structural parameters:</p><ul><li><code>N</code> for discretization</li><li><code>add_inertia</code> for including the wave equation</li></ul><p>Based on the inputs of these structural parameters, the number of generated equations will be different.  Therefore, to start simple, one can set <code>N=0</code> and <code>add_inertia=false</code> to generate the simplest form of the problem.  Solving this case first and ensuring the model physical behavior is correct is a good best practice before attempting to increase the fidelity of the model.  </p><h3 id="Check-values-of-parameters"><a class="docs-heading-anchor" href="#Check-values-of-parameters">Check values of parameters</a><a id="Check-values-of-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Check-values-of-parameters" title="Permalink"></a></h3><p>Another possible cause of problems in your model can come not from the equations, but from the parameters that are supplied to the equations.  As discussed previously, models are stiff not because of their equations but because of the parameters.  It&#39;s always a good idea to ensure your parameters match real life values to some degree. To ensure human error is not factoring in, it can be a good idea to use units (note ModelingToolkit v9 will be enforcing units using Uniful.jl).  If you know all of your parameters are correct but still having issues, another debugging strategy is to reduce the energy input of your system.  Rather than starting at 100%, start at 10%.  This gives the model a better chance to solve and with a model solution this gives some insight to what the root cause problem might be.  For example, if working with a hydraulic system, turn the input pressure down to 10%. </p><h3 id="Check-acausal-boundary-conditions"><a class="docs-heading-anchor" href="#Check-acausal-boundary-conditions">Check acausal boundary conditions</a><a id="Check-acausal-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Check-acausal-boundary-conditions" title="Permalink"></a></h3><p>As discussed in Lecture 1, acausal connections always have a minimum of 2 variables.  Therefore, acausal input (or boundary condition) components will need to pay attention to what should be done to both variables.  As an example, refer to the hydraulic cylinder problem from Lecture 2 and consider the case where the position <span>$x$</span> is supplied as the input boundary condition and the mass flow input <span>$\dot{m}$</span> is set to an <code>Open()</code> boundary condition, thereby solving for <span>$\dot{m}$</span> to give input <span>$x$</span>.</p><p><img src="../../img/Example.svg" alt="example"/></p><p>We can assemble the problem as</p><pre><code class="language-julia hljs">import ModelingToolkitStandardLibrary.Mechanical.Translational as T
import ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible as IC
import ModelingToolkitStandardLibrary.Blocks as B

include(&quot;volume.jl&quot;) # &lt;-- missing Volume component from MTKSL (will be released in new version)

function MassVolume(solves_force = true; name)

    pars = @parameters begin
        A = 0.01 #m²
        x₀ = 1.0 #m
        M = 10_000 #kg
        g = 9.807 #m/s²
        amp = 5e-2 #m
        f = 15 #Hz
        p_int=M*g/A
        dx=0
        drho=0
        dm=0
    end
    vars = []
    systems = @named begin
        fluid = IC.HydraulicFluid(; density = 876, bulk_modulus = 1.2e9)
        mass = T.Mass(;v=dx,m=M,g=-g)
        vol = Volume(;area=A, x=x₀, p=p_int, dx, drho, dm) # &lt;-- missing Volume component from MTKSL (will be released in new version)
        mass_flow = IC.Open(;p_int)
        position = T.Position(solves_force)
        position_input = B.TimeVaryingFunction(;f = t -&gt; amp*sin(2π*t*f) + x₀)
    end

    eqs = [
        connect(mass.flange, vol.flange, position.flange)
        connect(vol.port, mass_flow.port)
        connect(position.s, position_input.output)
    ]

    return ODESystem(eqs, t, vars, pars; systems, name)
end

@named odesys = MassVolume()</code></pre><p>If we check the number of equations and states we see a mismatch!</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; odesys</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">Model odesys with 17 (<span class="sgr35">23</span>) equations</span>
<span class="sgr1">Unknowns (24):</span>
  fluid₊dm(t) [defaults to 0]
  mass₊v(t) [defaults to dx]
  mass₊f(t) [defaults to 0]
  mass₊flange₊v(t) [defaults to mass₊dx]
⋮
<span class="sgr1">Parameters (35):</span>
  A [defaults to 0.01]
  x₀ [defaults to 1.0]
  M [defaults to 10000]
  g [defaults to 9.807]
⋮</code></pre><p>The reason for the mismatch is that the input boundary condition <code>Position()</code> needs to know what to do about the connection variable for force <code>f</code>.  In this problem, do we need a force introduced to the system to make the mass move as set by <code>Position()</code>?  The answer is no, the force causing the mass to move is already given by the hydraulic pressure and gravity.  If we look at the documentation for <code>Position()</code> we can see that it has a structural parameter <code>solves_force</code> which is defaulted to <code>true</code>.  Therefore, to assemble the proper system we set this to <code>false</code> and now have a properly defined system</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @named odesys = MassVolume(false)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">Model odesys with 18 (<span class="sgr35">24</span>) equations</span>
<span class="sgr1">Unknowns (24):</span>
  fluid₊dm(t) [defaults to 0]
  mass₊v(t) [defaults to dx]
  mass₊f(t) [defaults to 0]
  mass₊flange₊v(t) [defaults to mass₊dx]
⋮
<span class="sgr1">Parameters (35):</span>
  A [defaults to 0.01]
  x₀ [defaults to 1.0]
  M [defaults to 10000]
  g [defaults to 9.807]
⋮</code></pre><h2 id="Debugging-Strategies"><a class="docs-heading-anchor" href="#Debugging-Strategies">Debugging Strategies</a><a id="Debugging-Strategies-1"></a><a class="docs-heading-anchor-permalink" href="#Debugging-Strategies" title="Permalink"></a></h2><p>It&#39;s very difficult to identify what is wrong with a model if it&#39;s not outputting any data.  This section discusses ways to force a model solution.  It&#39;s still possible that something with the model is wrong, but the best way to know that is to see what the equations are outputting.  For example if the model is simulating negative pressure, but negative pressure is impossible, then this is a good clue of what is wrong with the model!  The strategies for forcing a model solve will come from a simple hydraulic system that is attempting to start a hydraulic cylinder at a high pressure differential.  See <a href="https://github.com/bradcarman/ModelingToolkitWebinar">ModelingToolkit Industrial Example</a> for more information about the model.</p><pre><code class="language-julia hljs">@mtkmodel System begin
    @parameters begin
        res₁₊Cₒ = 2.7
        res₁₊Aₒ = 0.00094
        res₁₊ρ₀ = 1000
        res₁₊p′ = 3.0e7
        res₂₊Cₒ = 2.7
        res₂₊Aₒ = 0.00094
        res₂₊ρ₀ = 1000
        res₂₊p′ = 0
        act₊p₁′ = 3.0e7
        act₊p₂′ = 0
        act₊vol₁₊A = 0.1
        act₊vol₁₊ρ₀ = 1000
        act₊vol₁₊β = 2.0e9
        act₊vol₁₊direction = -1
        act₊vol₁₊p′ = act₊p₁′
        act₊vol₁₊x′ = 0.5
        act₊vol₂₊A = 0.1
        act₊vol₂₊ρ₀ = 1000
        act₊vol₂₊β = 2.0e9
        act₊vol₂₊direction = 1
        act₊vol₂₊p′ = act₊p₂′
        act₊vol₂₊x′ = 0.5
        act₊mass₊m = 100
        act₊mass₊f′ = 0.1(-act₊p₁′ + act₊p₂′)
        src₊p′ = 3.0e7
        snk₊p′ = 0
        dmp₊c = 1000
    end
    @variables begin
        res₁₊ṁ(t) = 0
        res₁₊p₁(t) = res₁₊p′
        res₁₊p₂(t) = res₁₊p′
        res₁₊port₁₊p(t) = res₁₊p′
        res₁₊port₁₊ṁ(t) = 0
        res₁₊port₂₊p(t) = res₁₊p′
        res₁₊port₂₊ṁ(t) = 0
        res₂₊ṁ(t) = 0
        res₂₊p₁(t) = res₂₊p′
        res₂₊p₂(t) = res₂₊p′
        res₂₊port₁₊p(t) = res₂₊p′
        res₂₊port₁₊ṁ(t) = 0
        res₂₊port₂₊p(t) = res₂₊p′
        res₂₊port₂₊ṁ(t) = 0
        act₊port₁₊p(t) = act₊p₁′
        act₊port₁₊ṁ(t) = 0
        act₊port₂₊p(t) = act₊p₂′
        act₊port₂₊ṁ(t) = 0
        act₊vol₁₊p(t) = act₊vol₁₊p′
        act₊vol₁₊x(t) = act₊vol₁₊x′
        act₊vol₁₊ṁ(t) = 0
        act₊vol₁₊f(t) = act₊vol₁₊A * act₊vol₁₊p′
        act₊vol₁₊ẋ(t) = 0
        act₊vol₁₊r(t) = act₊vol₁₊ρ₀ * (1 + act₊vol₁₊p′ / act₊vol₁₊β)
        act₊vol₁₊ṙ(t) = 0
        act₊vol₁₊port₊p(t) = act₊vol₁₊p′
        act₊vol₁₊port₊ṁ(t) = 0
        act₊vol₁₊flange₊ẋ(t) = 0
        act₊vol₁₊flange₊f(t) = -act₊vol₁₊A * act₊vol₁₊direction * act₊vol₁₊p′
        act₊vol₂₊p(t) = act₊vol₂₊p′
        act₊vol₂₊x(t) = act₊vol₂₊x′
        act₊vol₂₊ṁ(t) = 0
        act₊vol₂₊f(t) = act₊vol₂₊A * act₊vol₂₊p′
        act₊vol₂₊ẋ(t) = 0
        act₊vol₂₊r(t) = act₊vol₂₊ρ₀ * (1 + act₊vol₂₊p′ / act₊vol₂₊β)
        act₊vol₂₊ṙ(t) = 0
        act₊vol₂₊port₊p(t) = act₊vol₂₊p′
        act₊vol₂₊port₊ṁ(t) = 0
        act₊vol₂₊flange₊ẋ(t) = 0
        act₊vol₂₊flange₊f(t) = -act₊vol₂₊A * act₊vol₂₊direction * act₊vol₂₊p′
        act₊mass₊f(t) = act₊mass₊f′
        act₊mass₊x(t) = 0
        act₊mass₊ẋ(t) = 0
        act₊mass₊ẍ(t) = act₊mass₊f′ / act₊mass₊m
        act₊mass₊flange₊ẋ(t) = 0
        act₊mass₊flange₊f(t) = act₊mass₊f′
        act₊flange₊ẋ(t) = 0
        act₊flange₊f(t) = 0
        src₊port₊p(t) = src₊p′
        src₊port₊ṁ(t) = 0
        snk₊port₊p(t) = snk₊p′
        snk₊port₊ṁ(t) = 0
        dmp₊flange₊ẋ(t) = 0
        dmp₊flange₊f(t) = 0
    end
    @equations begin
        res₁₊ṁ ~ res₁₊port₁₊ṁ
        res₁₊ṁ ~ -res₁₊port₂₊ṁ
        res₁₊p₁ ~ res₁₊port₁₊p
        res₁₊p₂ ~ res₁₊port₂₊p
        -res₁₊p₂ + res₁₊p₁ ~ 0.5res₁₊Cₒ * res₁₊ρ₀ * ((res₁₊ṁ / (res₁₊Aₒ * res₁₊ρ₀))^2)
        res₂₊ṁ ~ res₂₊port₁₊ṁ
        res₂₊ṁ ~ -res₂₊port₂₊ṁ
        res₂₊p₁ ~ res₂₊port₁₊p
        res₂₊p₂ ~ res₂₊port₂₊p
        -res₂₊p₂ + res₂₊p₁ ~ 0.5res₂₊Cₒ * res₂₊ρ₀ * ((res₂₊ṁ / (res₂₊Aₒ * res₂₊ρ₀))^2)
        D(act₊vol₁₊x) ~ act₊vol₁₊ẋ
        D(act₊vol₁₊r) ~ act₊vol₁₊ṙ
        act₊vol₁₊p ~ act₊vol₁₊port₊p
        act₊vol₁₊ṁ ~ act₊vol₁₊port₊ṁ
        act₊vol₁₊f ~ -act₊vol₁₊direction * act₊vol₁₊flange₊f
        act₊vol₁₊ẋ ~ act₊vol₁₊direction * act₊vol₁₊flange₊ẋ
        act₊vol₁₊r ~ act₊vol₁₊ρ₀ * (1 + act₊vol₁₊p / act₊vol₁₊β)
        act₊vol₁₊ṁ ~ act₊vol₁₊A * act₊vol₁₊ẋ * act₊vol₁₊r + act₊vol₁₊A * act₊vol₁₊x * act₊vol₁₊ṙ
        act₊vol₁₊f ~ act₊vol₁₊A * act₊vol₁₊p
        D(act₊vol₂₊x) ~ act₊vol₂₊ẋ
        D(act₊vol₂₊r) ~ act₊vol₂₊ṙ
        act₊vol₂₊p ~ act₊vol₂₊port₊p
        act₊vol₂₊ṁ ~ act₊vol₂₊port₊ṁ
        act₊vol₂₊f ~ -act₊vol₂₊direction * act₊vol₂₊flange₊f
        act₊vol₂₊ẋ ~ act₊vol₂₊direction * act₊vol₂₊flange₊ẋ
        act₊vol₂₊r ~ act₊vol₂₊ρ₀ * (1 + act₊vol₂₊p / act₊vol₂₊β)
        act₊vol₂₊ṁ ~ act₊vol₂₊A * act₊vol₂₊r * act₊vol₂₊ẋ + act₊vol₂₊A * act₊vol₂₊ṙ * act₊vol₂₊x
        act₊vol₂₊f ~ act₊vol₂₊A * act₊vol₂₊p
        D(act₊mass₊x) ~ act₊mass₊ẋ
        D(act₊mass₊ẋ) ~ act₊mass₊ẍ
        act₊mass₊f ~ act₊mass₊flange₊f
        act₊mass₊ẋ ~ act₊mass₊flange₊ẋ
        act₊mass₊m * act₊mass₊ẍ ~ act₊mass₊f
        src₊port₊p ~ src₊p′
        snk₊port₊p ~ snk₊p′
        dmp₊flange₊f ~ dmp₊c * dmp₊flange₊ẋ
        src₊port₊p ~ res₁₊port₁₊p
        0 ~ res₁₊port₁₊ṁ + src₊port₊ṁ
        res₁₊port₂₊p ~ act₊port₁₊p
        0 ~ act₊port₁₊ṁ + res₁₊port₂₊ṁ
        act₊port₂₊p ~ res₂₊port₁₊p
        0 ~ act₊port₂₊ṁ + res₂₊port₁₊ṁ
        res₂₊port₂₊p ~ snk₊port₊p
        0 ~ res₂₊port₂₊ṁ + snk₊port₊ṁ
        dmp₊flange₊ẋ ~ act₊flange₊ẋ
        0 ~ act₊flange₊f + dmp₊flange₊f
        act₊port₁₊p ~ act₊vol₁₊port₊p
        0 ~ act₊vol₁₊port₊ṁ - act₊port₁₊ṁ
        act₊port₂₊p ~ act₊vol₂₊port₊p
        0 ~ -act₊port₂₊ṁ + act₊vol₂₊port₊ṁ
        act₊vol₁₊flange₊ẋ ~ act₊vol₂₊flange₊ẋ
        act₊vol₁₊flange₊ẋ ~ act₊mass₊flange₊ẋ
        act₊vol₁₊flange₊ẋ ~ act₊flange₊ẋ
        0 ~ act₊vol₁₊flange₊f - act₊flange₊f + act₊vol₂₊flange₊f + act₊mass₊flange₊f
    end
end

@mtkbuild sys = System()
prob = ODEProblem(sys, [], (0, 0.1))
sol = solve(prob)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Unstable
Interpolation: specialized 4rd order &quot;free&quot; stiffness-aware interpolation
t: 1-element Vector{Float64}:
 0.0
u: 1-element Vector{Vector{Float64}}:
 [0.5, 1014.9999999999999, 0.5, 1000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]</code></pre><p>As can be seen, when attempting to solve we get an <code>Unstable</code> return code.  Let&#39;s explore strategies to fix the problem or find a forced numerical solution for debugging purposes.</p><h3 id="Initial-Conditions"><a class="docs-heading-anchor" href="#Initial-Conditions">Initial Conditions</a><a id="Initial-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-Conditions" title="Permalink"></a></h3><p>First, let&#39;s check the initial conditions to see if at time 0 we are starting with zero residual for our algebraic equations.</p><pre><code class="language-julia hljs">eqs = full_equations(sys)
defs = ModelingToolkit.defaults(sys)
residuals = Float64[]
for eq in eqs
    if !ModelingToolkit.isdifferential(eq.lhs)
        push!(residuals, ModelingToolkit.fixpoint_sub(eq.rhs, defs))
    end
end
residuals</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Float64}:
 -2.2724270820617676e-7
  0.0
  0.0
  0.0</code></pre><p>As can be seen, we have a problem with our first algebraic equation, the residual is not zero!  To solve this problem, ModelingToolkit v9 will be releasing a new feature to properly generate a non-linear system to calculate initial conditions.  We also can apply the <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/dae_solve/#Initialization-Schemes">Initialization Schemes</a> provided from DifferentialEquations.jl.  The <code>BrownFullBasicInit</code> is the default algorithm used, and this did not work for our problem, so we will move to the <code>ShampineCollocationInit</code>.</p><pre><code class="language-julia hljs">dt = 1e-7
sol = solve(prob; initializealg=ShampineCollocationInit(dt))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Unstable
Interpolation: specialized 4rd order &quot;free&quot; stiffness-aware interpolation
t: 1-element Vector{Float64}:
 0.0
u: 1-element Vector{Vector{Float64}}:
 [0.5, 1014.9999999999999, 0.5, 1000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]</code></pre><p>The <code>ShampineCollocationInit</code> solves the initial conditions by essentially taking a small step forward in time (<code>dt</code>) and then updating the initial conditions with that solve.  If this doesn&#39;t work, we can instead do this manually. </p><pre><code class="language-julia hljs">prob = ODEProblem(sys, [], (0, dt))
sol = solve(prob, ImplicitEuler(nlsolve=NLNewton(check_div=false, always_new=true, relax=4/10, max_iter=100)); dt, adaptive=false)

# update u0 with the ImplicitEuler non-adaptive step
prob′ = ODEProblem(sys, sol[2], (0, 0.1))
sol = solve(prob′);
plot(sol; idxs=sys.act₊mass₊ẋ)</code></pre><img src="b10879f1.svg" alt="Example block output"/><p>As can be seen, now we have a successful solve.  We can see the change to the initial conditions is very minimal.  As can be seen, the solver needs the derivative terms to be offset by a small amount.</p><pre><code class="language-julia hljs">println(join([&quot;$s : $(round(x; digits=3)) -&gt; $(round(y; digits=3))&quot; for (s,x,y) in zip(unknowns(sys), prob.u0, prob′.u0)],&#39;\n&#39;))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">act₊vol₁₊x(t) : 0.5 -&gt; 0.5
act₊vol₁₊r(t) : 1015.0 -&gt; 1015.0
act₊vol₂₊x(t) : 0.5 -&gt; 0.5
act₊vol₂₊r(t) : 1000.0 -&gt; 1000.0
act₊mass₊x(t) : 0.0 -&gt; -0.0
act₊mass₊ẋ(t) : 0.0 -&gt; -0.003
res₁₊ṁ(t) : 0.0 -&gt; 0.027
res₂₊ṁ(t) : 0.0 -&gt; 0.027
act₊vol₁₊ṙ(t) : 0.0 -&gt; -5.551
act₊vol₂₊ṙ(t) : 0.0 -&gt; 5.465</code></pre><p>Another strategy that can help issues with initial conditions is to offset or perturb any initial conditions from 0 by a small value.  </p><h3 id="Adjust-tolerance"><a class="docs-heading-anchor" href="#Adjust-tolerance">Adjust tolerance</a><a id="Adjust-tolerance-1"></a><a class="docs-heading-anchor-permalink" href="#Adjust-tolerance" title="Permalink"></a></h3><p>Here we get a solve by increasing the <code>abstol</code> and <code>reltol</code> to very large values.  This is therefore understood to give us a very low resolution solution that is far from the true solution, but we can now at least see if the model is calculating generally correct values, at least with the correct sign.  Here we expect the <code>act₊mass₊ẋ</code> to be around -1 and that&#39;s exactly what we get.  However, as can be seen the tolerance is too open to resolve the dynamics.  </p><pre><code class="language-julia hljs">prob = ODEProblem(sys, [], (0, 0.1))
sol = solve(prob, ImplicitEuler(); abstol=10000.0, reltol=100.0)
plot(sol; idxs=sys.act₊mass₊ẋ)</code></pre><img src="67ed83ee.svg" alt="Example block output"/><h3 id="Turn-off-adaptivity"><a class="docs-heading-anchor" href="#Turn-off-adaptivity">Turn off adaptivity</a><a id="Turn-off-adaptivity-1"></a><a class="docs-heading-anchor-permalink" href="#Turn-off-adaptivity" title="Permalink"></a></h3><p>Another strategy similar to adjusting tolerance is to turn off adaptivity.  This means we can no longer guarantee tolerance, but we can at least adjust the time step such that it&#39;s small enough to give a good solution.  A good practice is to continue to decrease <code>dt</code> until the solution converges (i.e. stops changing).  Without adaptivity this is another way to help ensure solution accuracy.  </p><pre><code class="language-julia hljs">prob = ODEProblem(sys, [], (0, 0.1))
sol = solve(prob, ImplicitEuler(nlsolve=NLNewton(check_div=false, always_new=true, relax=4/10, max_iter=100)); initializealg=NoInit(), adaptive=false, dt=1e-6)
plot(sol; idxs=sys.act₊mass₊ẋ)</code></pre><img src="18626134.svg" alt="Example block output"/><p>Note the use of keywords: </p><ul><li><code>check_div=false</code>: ensures the problem doesn&#39;t exit early because of divergence</li><li><code>always_new=true</code>: ensures Jacobian is always updated to give a more robust solve</li><li><code>relax</code>: for relaxation of Newton iterations to give a more robust solve</li><li><code>max_iter</code> to ensure enough iterations are available</li></ul><h3 id="Jacobian-generation"><a class="docs-heading-anchor" href="#Jacobian-generation">Jacobian generation</a><a id="Jacobian-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Jacobian-generation" title="Permalink"></a></h3><p>There are 3 different ways to calculate the Jacobian from ModelingToolkit:</p><ol><li>analytically, by using <code>jac=true</code> keyword given to <code>ODEProblem</code></li><li>automatically with automatic differentiation using <code>autodiff=true</code> given to the solver algorithms that use Jacobians</li><li>automatically with finite differencing using <code>autodiff=false</code></li></ol><p>Each choice offers different levels of numerical accuracy (in order from highest to lowest) and computational expense.  In some cases choosing a less numerical accurate Jacobian can actually help provide a solution for very stiff problems.  </p><h3 id="DAE-conversion-to-ODE"><a class="docs-heading-anchor" href="#DAE-conversion-to-ODE">DAE conversion to ODE</a><a id="DAE-conversion-to-ODE-1"></a><a class="docs-heading-anchor-permalink" href="#DAE-conversion-to-ODE" title="Permalink"></a></h3><p>If all else fails, one concept that may work is to convert the DAE to an ODE by implementing a small epsilon (<span>$\epsilon$</span>) term such that when <span>$\epsilon=0$</span> the problem is a DAE and when <span>$\epsilon$</span> is small the problem approximates an ODE.  For example, consider the DAE</p><p class="math-container">\[\dot{x} = y \\
0 = x + y\]</p><p>We can adjust the 2nd equation to approximate an ODE like</p><p class="math-container">\[\dot{x} = y \\
\epsilon \cdot \dot{y} = x + y\]</p><p>The below function can create such a transformation.  </p><pre><code class="language-julia hljs">using Setfield

function dae_to_ode(sys::ODESystem)

    are_vars_equal(var1, var2) = string(var1) == string(var2)

    defs = ModelingToolkit.defaults(sys)
    pars = parameters(sys)
    sts = unknowns(sys)
    eqs = equations(sys)
    iv = ModelingToolkit.independent_variable(sys)
    D = Differential(iv)

    diff_vars = []
    for eq in eqs
        eq_sts = []
        ModelingToolkit.vars!(eq_sts, eq)
        diffs = ModelingToolkit.isdifferential.(eq_sts)
        if any(diffs)
            diff = eq_sts[diffs] |&gt; first
            diff_var = ModelingToolkit.arguments(diff) |&gt; first
            push!(diff_vars, diff_var)
        end
    end

    diffs = setdiff(sts, diff_vars)

    @parameters ϵ
    j = 1
    neqs = Equation[]
    for eq in eqs
        if ModelingToolkit._iszero(eq.lhs)
            push!(neqs, D(diffs[j]) ~ eq.rhs/ϵ)
            j+=1
        else
            push!(neqs, eq)
        end
    end

    @set! sys.eqs = neqs
    @set! sys.ps = [ModelingToolkit.unwrap(ϵ); pars]
    @set! sys.defaults = Dict(ϵ =&gt; -1e-12,  pairs(defs)...)

    return sys
end</code></pre><p>Implementing this for the hydraulic system works well, giving an adaptive time solution using <code>Tsit5</code></p><pre><code class="language-julia hljs">odesys = dae_to_ode(sys)
prob = ODEProblem(odesys, [], (0,0.1))
sol = solve(prob)
plot(sol; idxs=sys.act₊mass₊ẋ)</code></pre><p>Note this problem, as we&#39;ve seen, has a lot of trouble with initialization.  Note how the first 200 steps are taken with a very small time step.  The <code>Tsit5</code> solver is able to successfully push through the model initialization and then solve the remaining steps at a reasonable time step.  </p><pre><code class="language-julia hljs">plot(diff(sol.t))</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lecture4/">« Numerical Methods for Stiff ODEs and Differential-Algebraic Equations</a><a class="docs-footer-nextpage" href="../lecture7/">Numerical and Structural Characterizations for DAEs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Wednesday 26 June 2024 16:44">Wednesday 26 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
