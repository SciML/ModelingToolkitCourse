var documenterSearchIndex = {"docs":
[{"location":"lectures/lecture3/#Solvers-for-Non-Stiff-Ordinary-Differential-Equations","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"","category":"section"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"In this lecture we will set the basis for solving ordinary differential equations (ODE). In order to build up the topic step-by-step, we will walk through the complete details of a non-stiff ODE solver, using this as a basis to then describe the more advanced techniques added to a stiff ODE solver and thus a solver for differential-algebraic equations (DAEs). This discussion will also demonstrate the close mathematical relationship between stiff ODEs and DAEs, the similarities but also the differences.","category":"page"},{"location":"lectures/lecture3/#Euler's-Method-for-ODEs","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Euler's Method for ODEs","text":"","category":"section"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"As a starting point, let's do a full analysis of solving ODEs with Euler's method. Given an ODE of the form:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"u = f(upt)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"where u(t_0) = u_0 is known, to solve this equation on a time span from t in t_0 t_f is known as the Initial Value Problem (IVP). The most basic method for handling this type of equation is known as Euler's method, which is given by the linear approximation of the derivative. Let u_n be the numerical approximation to u(t_0 + nh) at time t_n = t_0 + nh where h is the time discretization size, then can approximate via a Taylor Series expansion:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"u(t+(n+1)h) = u(t+nh) + h u(t+nh) + frac12h^2 u(t) + mathcalO(h^3)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"which motivates the approximation by dropping the higher order terms:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"u_n+1 = u_n + h f(u_npt_n)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"which is Euler's method.","category":"page"},{"location":"lectures/lecture3/#Linear-Stability-of-Euler's-Method","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Linear Stability of Euler's Method","text":"","category":"section"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"The linear stability of a numerical method for ODEs is the maximum h such that the solution of u = lambda u converges t rightarrow 0. For the true equation, u = lambda u implies that u(t) = u_0 exp(lambda t) and thus the solution converges to 0 iff lambda  0.","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Now let's see if Euler's method has similar behavior. To calculate this, plug in the test equation into Euler's method:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"u_n+1 = u_n + h f(u_n p t_n)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"u_n+1 = u_n + h lambda u_n","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"u_n+1 = (1+hlambda) u_n","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"If we let z = h lambda, then we have the difference equation:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"u_n+1 = (1+z) u_n","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"u_n+1 = (1+z)^n u_0","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Therefore this equation converges to zero if and only if Vert 1+z Vert  1. In the complex plane, this corresponds to the unit circle centered around 1. Importantly, for any equation with lambda  0 such that Vert 1 + h lambda Vert  1, we have that the numerical diverges to infinity while the true solution converges to zero!","category":"page"},{"location":"lectures/lecture3/#Measures-of-Error-in-Euler's-Method:-Local-Truncation-Error","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Measures of Error in Euler's Method: Local Truncation Error","text":"","category":"section"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"The local truncation error, i.e. the largest error term in each given step, is one of the most important aspects of a numerical ODE solver. To calculate this, assume that u_n is exact. Then the LTE is the difference between the true solution u(t+(n+1)h) and u_n+1. To calculate this, we can simply refer back to the Taylor series expansion:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"u(t+(n+1)h) = u(t+nh) + h u(t+nh) + mathcalO(h^2)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"LTE = u(t+(n+1)h) - u_n+1","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"LTE = (u(t+nh) + h u(t+nh) + mathcalO(h^2)) - (u_n + h f(u_npt_n))","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"LTE = (u(t+nh) + h u(t+nh) + frac12h^2 u(t) + mathcalO(h^3)) - (u(t+nh) + h u(t+nh))","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"LTE = frac12h^2 u(t) + mathcalO(h^3)","category":"page"},{"location":"lectures/lecture3/#Global-Truncation-Error-in-Euler's-Method","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Global Truncation Error in Euler's Method","text":"","category":"section"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"The global truncation error is the error in a full integration. Abusing notation a bit and letting u(t+nh) be the true solution at time t+nh, we can calculate this as:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"E_n+1 = u(t+(n+1)h) - u_n+1","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"E_n+1 = u(t+(n+1)h) - (u_n + h f(u_npt_n))","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"E_n+1 = (u(t+nh)-u_n) + (u(t+(n+1)h) - u(t+nh) - hf(u(t+nh)pt_n)) + (hf(u(t+nh)pt_n) - h f(u_npt_n))","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Notice that the first term is the global error at time step n while the second term is simply the LTE at time step n, and thus we can simplify:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"E_n+1 = E_n + LTE_n + (hf(u(t+nh)pt_n) - h f(u_npt_n))","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"If we assume that the derivatives are bounded, in particular: ","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"u(t) leq A","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"over the domain of interest, then by the Taylor Series Remainder Theorem:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"(Image: )","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"We can bound the error in the rest of the LTE terms using the maximum of the second derivative, and thus:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"LTE_n leq frac12 A h^2","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"For the final term, we use the mean-value theorem:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"f(u(t+nh)pt_n) - f(u_npt_n) = fracpartial f(u^ast p t_n)partial u u(t+nh)-u_n","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"We use assume the first partial derivative is bounded over the domain of interest:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"fracpartial f(u^ast p t_n)partial u leq B","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"and thus","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"f(u(t+nh)pt_n) - f(u_npt_n) leq B E_n","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Substituting all of this together we get:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"E_n+1 leq E_n + frac12 A h^2 + h B E_n","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"E_n+1 leq (1+Bh)E_n + frac12 A h^2","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Some manipulations later...","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"(Image: )","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"You get that E_n is bounded by a geometric series and use the analytical solution to a geometric series to get:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"E_n leq fracA2B(1+Bh)^n - 1h","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Finally, notice:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"1+Bh leq 1 + Bh + frac12 (Bh)^2 + frac13 (Bh)^3 + ldots = e^Bh","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"and therefore:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"E_n leq fracA2Be^Bhn - 1h","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"From this we can see that E_n rightarrow 0 as h rightarrow 0.","category":"page"},{"location":"lectures/lecture3/#General-Points-About-the-Global-Truncation-Error","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"General Points About the Global Truncation Error","text":"","category":"section"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"The key factor is that while the leading term of the local truncation error has a nice and clean formula and the global error is related to this LTE, the global error requires propagation of each LTE into the next stage and thus has a compounding factor. Even with that, we can still bound the global error to ensure convergence as h rightarrow 0, but only if:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Derivatives one order beyond the order of the method are bounded.\nThe local truncation error converges to zero\nThe partials of f are bounded.","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"While this proof can be relaxed to remove some of the required bounding, these are general points to note which are exploited by most solvers. You need the derivatives defined in order for the solvers to work well, and the higher order method you use the higher derivatives you need bounds for. ","category":"page"},{"location":"lectures/lecture3/#Going-Beyond-Euler's-Method","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Going Beyond Euler's Method","text":"","category":"section"},{"location":"lectures/lecture3/#The-Midpoint-Method","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"The Midpoint Method","text":"","category":"section"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"We can use this analysis to extend our methods to higher order approximation by simply matching the Taylor series to a higher order. Intuitively, when we developed the Euler method we had to make a choice:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"u_n+1 = u_n + h f(upt)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"where do we evaluate f? One may think that the best derivative approximation my come from the middle of the interval, in which case we might want to evaluate it at t + frach2. To do so, we can use the Euler method to approximate the value at t + frach2 and then use that value to approximate the derivative at t + frach2. This looks like:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"k_1 = f(u_npt)\nk_2 = f(u_n + frach2 k_1pt + frach2)\nu_n+1 = u_n + h k_2","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"which we can also write as:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"u_n+1 = u_n + h f(u_n + frach2 f_npt + frach2)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"where f_n = f(u_npt). If we do the two-dimensional Taylor expansion we get:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"u_n+1 = u_n + h f_n + frach^22(f_t + f_u f)(u_npt)\n+ frach^36 (f_tt + 2f_tuf + f_uuf^2)(u_npt)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"which when we compare against the true Taylor series:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"u(t+h) = u_n + h f(u_npt) + frach^22(f_t + f_u f)(u_npt)\n+ frach^36(f_tt + 2f_tu + f_uuf^2 + f_t f_u + f_u^2 f)(u_npt)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"and thus we see that","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"u(t + h) - u_n = mathcalO(h^3)","category":"page"},{"location":"lectures/lecture3/#General-Runge-Kutta-Methods","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"General Runge-Kutta Methods","text":"","category":"section"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"However, this idea gives rise to a more general scheme for approximating ODEs. The general form is to use previous derivative information to construct an approximation to some value u(t+ch), then using this new value to approximate a new derivative, and thus construct a better approximation u(t+c_2 h), and so on. Then using each of these sub-interval approximations we can approximate the final time point.","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"In mathematical terms, this type of scheme can be written as:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"k_1 = f(u_npt_n)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"k_2 = f(u_n + h a_11 k_1pt_n + c_2 h)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"k_3 = f(u_n + h a_21 k_1 + a_22 k_2 p t_n + c_3 h)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"vdots","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"u_n+1 = u_n + h(b_1 k_1 + b_2 k_2 + ldots + b_s k_s)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"where s is the number of stages. In this schema, the Euler method is simply the one-stage method, while the Midpoint method is the schema with c_1 = 0, c_2 = frac12, a_11 = frac12, and b_1 = 0, b_2 = 1. ","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"This class of methods is known as the Runge-Kutta methods and the set of coefficients (a_ij b_i c_i) is known as the tableau. Normally these tableaus are represented in a table:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"(Image: )","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"The order of the Runge-Kutta method is simply the number of terms in the Taylor series that ends up being matched by the resulting expansion. For example, for the 4th order you can expand out and see that the following equations need to be satisfied:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"(Image: )","category":"page"},{"location":"lectures/lecture3/#Note-about-Order-Conditions","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Note about Order Conditions","text":"","category":"section"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Since the number of terms in the Taylor series grows exponentially with each increase in the order, this is fairly difficult to write down and thus most people use tricks in order to represent the order conditions. We refer to Hairer I for more information on this process.","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"(Image: )","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"You basically make rooted trees and then they represent conditions.","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"(Image: )","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"It's complicated and not necessarily for understanding how the resulting methods are used.","category":"page"},{"location":"lectures/lecture3/#Note-about-stages-and-order","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Note about stages and order","text":"","category":"section"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"1st order (i.e. matching the first term of the Taylor series) can be achieved by Euler's method which is one stage. Second order can be achieved by the Midpoint method which is two stages. \"The Runge-Kutta method\", which is also known as the classic Runge-Kutta method is simply RK4 is a 4th order method which  uses 4 stages:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"k_1 = f(u_npt)\nk_2 = f(u_n + frach2 k_1pt + frach2)\nk_3 = f(u_n + frach2 k_2pt + frach2)\nk_4 = f(u_n + h k_3pt + h)\nu_n+1 = u_n + frach6(k_1 + 2 k_2 + 2 k_3 + k_4)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"It may seem wise to thus extrapolate that one can gain an order per f evaluation, but that is not the case. It turns out that the number of stages required starts to grow more than linearly after 4! With p being the order, here's a table of known minimum orders:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"(Image: )","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Given the number of terms in the Taylor series expansion grows exponentially after the first order, this calculation is hard to do but is guaranteed to be larger than linear. However, as we will see later, the effect of better order is exponential, so this does not mean that fourth order is optimal!","category":"page"},{"location":"lectures/lecture3/#The-Fundamental-Tension-in-ODE-Solvers","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"The Fundamental Tension in ODE Solvers","text":"","category":"section"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"The fundamental tension in ODE solvers is a simple fact:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"The theoretical performance of ODE solvers is well-understood as h rightarrow 0, but the purpose of a good ODE solver is to choose an h as large as possible in order to achieve a given error tolerance.","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Let's disect this a bit. The goal of an efficient code for solving ODEs is to approximate the solution to u = f(upt) \"as fast as possible\". But since it's an approximation, an error tolerance always needs to be known, i.e. \"Approximate the solution to u = f(upt) as fast as possible under the constraint that the solution is within TOL of the true solution\". ","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"This statement has a major caveat. In order to know if we are within TOL of the true solution, we would need some measure of the error. As we saw in the discussion on Euler's method, even for the simplest of numerical methods for ODEs a complete formula for the error of the full solution is seemingly unobtainable. Thus in general the field has relaxed this constraint to instead be written as \"Approximate the solution to u = f(upt) as fast as possible under the constraint that the solution the error of any given step is below TOL\". In other words, we wish to build efficient numerical solvers where LTE leq TOL. ","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"In order to achieve \"efficient\", we thus wish to choose as large of an h as possible such that LTE approx TOL, since the larger h is, the less total steps are required to solve the equation. This brings up two questions:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"What kinds of methods take the least amount of \"work\" for the smallest LTE?\nHow can we find h such that LTE leq TOL?","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"note: Note\nThere are ways to build ODE solvers that control the global truncation error, but there is no open source software (nor widely used closed source software) which does this with Runge-Kutta methods for IVPs. This is a potential final project.","category":"page"},{"location":"lectures/lecture3/#A-Bit-of-Mental-Math-Around-Solver-Work-Calculations-And-Optimal-Order","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"A Bit of Mental Math Around Solver Work Calculations And Optimal Order","text":"","category":"section"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Note that for efficiency of (non-stiff) ODE solvers, we simplify the calculation of work to simply assume that the internals of the ODE solver are effectively free compute, and thus the cost of running the ODE solver can be approximated by the number of times f(upt) is computed. For Runge-Kutta methods, the number of times f is computed in a step is the stage of the method. Thus as we increase the stage of the method, there is more compute required for a given stage, but in theory the error should be less, therefore allowing h to be larger and potentially requiring fewer steps.","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"To understand this balance a bit better, we note that order has an exponential effect on the error with respect to h. For example, if a method is 4th order, then the LTE is mathcalO(h^5), and thus if we change h to frach2, we end up decreasing the error by a factor of frac12^5 = frac132. Thus, if going to a higher order does not require an exponential increase in the number of stages required (which it does not), in terms of efficiency then it may seem best to always use the highest order method that we can.","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"However, this fact must be balanced around two facts. The first is that this error estimate only holds as h rightarrow 0. As h grows, the other terms in the LTE approximation become non-negligible, and thus it becomes no longer guaranteed that a higher order method has a lower error than a lower order method! Secondly, the methods themselves have a maximum step size which is allowed due to the stability requirement on the ODE solver. Thus the ODE solver should have a high enough order in order to make use of the efficiency gains, but if the order is too high then the h will need to be artificially decreased in order to ensure stability and accurate error approximations, and therefore there is a \"sweet spot\" where the order is high but not too high.","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"In practice, this has empirically been found to be between 3-9, though this can be very dependent on two things. For one, it's dependent on the type of problem being solved since the larger the eigenvalues of the Jacobian, i.e. the approximation of the linear stability lambda, the smaller h which is allowed. Therefore, equations with larger eigenvalues in the Jacobain tend to be optimal with lower order methods. And the second point, the optimality is dependent on the choice of TOL, since the smaller the error tolerance the smaller h will be, and thus the higher order that will be efficient.","category":"page"},{"location":"lectures/lecture3/#LTE-Optimal-Runge-Kutta-Methods-via-Tableau-Optimization","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"LTE-Optimal Runge-Kutta Methods via Tableau Optimization","text":"","category":"section"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Let's take for granted that a two-stage Runge-Kutta method can at most be second order, i.e. can match only the second derivative term of the Taylor Series expansion exactly. This means that for any second order method with two-stages,","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"k_1 = f(u_npt_n)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"k_2 = f(u_n + h a_11 k_1pt_n + c_2 h)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"u_n+1 = u_n + h(b_1 k_1 + b_2 k_2)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"we would have that:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"LTE = C h^3 u(t) + mathcalO(h^4)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"for some value of C(a_11 c_2 b_1 b_2). Thus we can consider a LTE-Optimal second order two-stage Runge-Kutta method as the tableau choice that minimizes C(a_11 c_2 b_1 b_2).","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Similarly, for any number of stages s and order o, the LTE-Optimal s-stage oth order method is the choice of tableau coefficients (a_ij b_i c_i) which minimizes:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"LTE = C h^o+1 u^(o+1)(t) + mathcalO(h^(o+2))","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"An equivalent statement to this problem is the following:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Find the tableau coefficients (a_ij b_i c_i) such that the order conditions for order o-1 are satisfied exactly, and the divergence from the order constraints o is minimal","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"This is equivalent because \"the order conditions for order o-1 are satisfied exactly\" is equivalent to stating that the method satisfies that the Taylor series expansion exactly calculates the oth derivative term in the Taylor series expansion, and as the divergence of the order conditions shrinks then so does C which is a linear combination of the divergences of the order conditions. In this formulation, the optimal Runge-Kutta tableau is thus the solution to a (generally high dimensional) nonlinear constrained optimization problem!","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"However, similar to how the order conditions can quickly become intractible concisely state or compute by hand, and thus many of the methods used in practice used a mixture of hand-optimization mixed with a numerical optimization process. The most famous method is the Dormand-Prince method, which is the tableau behind popular software such as dopri5, ode45, DP5, and other implementations. It is thus given by the tabeleau:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"(Image: )","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"It is a 5th order method with 7 stages. Its optimization process looks like:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"(Image: )","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"There are a few peculiarities to address with this method. ","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"The method being 5th order with 7 stages is not \"stage optimal\" since there exist methods with 6 stages which are 5th order. In theory, a method with 6 stages evaluates f only 6 times instead of 7, and so therefore wouldn't that be more optimal? It turns out that while the order conditions can be achieved, the leading terms of the next order LTE are so large that in fact it's more optimal to take another f evaluation per stage.\nThis method was derived by hand in 1980 and made the assumption that some of the terms were zero in order to simplify the optimization process. This means it's not necessarily optimal.\nThe last stage of the step exactly matches the update equation. This is a property known as \"first same as last\" (FSAL), and thus while the method technically requires 7 evaluations per stage, after the first step we can cache the value of the k_7 and reuse it as k_1 in the next evaluation, and therefore this method effectively takes 6 steps per stage!","category":"page"},{"location":"lectures/lecture3/#Note:-Further-Optimizations-Beyond-Dormand-Prince","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Note: Further Optimizations Beyond Dormand-Prince","text":"","category":"section"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"You may then ask the question of whether anyone has fixed (2) to derive a 5th order 7-stage method with FSAL which does not make the extra zero column assumptions. If you were thinking this, then you're right in 2011 someone went back to this problem and used numerical optimization tools in order to derive a method that is approximately 20% more efficient and this is the tableau used in the Tsit5() method of DifferentialEquations.jl.","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Its optimization process was mostly numerical:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"(Image: )","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Giving the following tableau:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"(Image: )","category":"page"},{"location":"lectures/lecture3/#Choosing-the-Optimal-h:-Adaptivity","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Choosing the Optimal h: Adaptivity","text":"","category":"section"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Recall the two fundamental questions for an optimal ODE solver:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"What kinds of methods take the least amount of \"work\" for the smallest LTE?\nHow can we find h such that LTE leq TOL?","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"We have addressed 1 by exploring LTE-optimal Runge-Kutta methods which minimize the number of f evaluations in order to achieve a given accuracy for \"non-zero h\". However, what is the value of h we should use at each time step? This is the question that is addressed through adaptivity.","category":"page"},{"location":"lectures/lecture3/#A-Priori-Error-Estimators","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"A Priori Error Estimators","text":"","category":"section"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"In order to approximate the LTE, let's look at the Euler method. We know in this case that ","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"LTE = frac12h^2 u(t) + mathcalO(h^3)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"and therefore if h is sufficiently small, we could simply use:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"u = fracpartialpartial t f(upt) = f_u(upt)u + f_t(upt)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"where f_x = fracpartial fpartial x. Using the fact that we approximated u = fracu_n+1 - u_nh, we can approximate:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"LTE approx frac12 f_u(u_npt_n) (u_n+1 - u_n) h + frac12 f_t(u_npt_n) h^2","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"This type of estimate is known an a priori error estimator since we are using a prior-derived equation in order to directly predict the error. However, since this method requires computing the partial derivatives of the function f, which you may not have in an ODE solver software if the user only supplies f, this type of estimate can be (a) difficult to derive for higher order methods, and (b) can be costly. ","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Other a priori error estimators seek to approximate u(t) more directly. Note that implicit Euler has the same error term as explicit Euler, and in old SPICE circuit simulators the following scheme was derived:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"# Code pulled from OrdinaryDiffEq.jl\n\n# local truncation error (LTE) bound by dt^2/2*max|y''(t)|\n# use 2nd divided differences (DD) a la SPICE and Shampine\n\n# TODO: check numerical stability\nuprev2 = integrator.uprev2\ntprev = integrator.tprev\n\ndt1 = dt * (t + dt - tprev)\ndt2 = (t - tprev) * (t + dt - tprev)\nc = 7 / 12 # default correction factor in SPICE (LTE overestimated by DD)\nr = c * dt^2 # by mean value theorem 2nd DD equals y''(s)/2 for some s\n\n@.. E =r * integrator.opts.internalnorm((u - uprev) / dt1 - (uprev - uprev2) / dt2, t)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"which uses the 2nd order divided differences formula in order to approximate u(t) using the current step and the previous step. ","category":"page"},{"location":"lectures/lecture3/#A-Posteriori-Error-Estimators","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"A Posteriori Error Estimators","text":"","category":"section"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"However, a much more common form of error estimator is the a posteriori error estimator. The basis for these error estimators comes from a simple observation. If we use the Euler method, then we have the LTE:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"LTE = frac12h^2 u(t) + mathcalO(h^3)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Now, we we instead calculate with a 3rd order method, we have:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"LTE = C h^3 u(t) + mathcalO(h^4)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"In other words, the third order method must exactly compute that missing term in the Taylor series frac12h^2 u(t) since that is required by definition to be 3rd order. Thus if we compute a step with both Euler's method u_n+1 and a step with the 3rd order method hatu_n+1, then we have that:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"u_n+1 - hatu_n+1 = frac12h^2 u(t) + mathcalO(h^3)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"While the higher order terms in this case are different from that of the LTE (since they are influenced by the higher order LTE terms of the third order method), as h rightarrow 0 then we have that u_n+1 - hatu_n+1 rightarrow LTE for the Euler method!","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"More generally, if we have a first method u_n+1 which is order o_1 and a second method hatu_n+1 which is order o_2, where o_1  o_2, then:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"u_n+1 - hatu_n+1 = LTE + C^ast mathcalO(h^o_1 + 1)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"and thus the difference between two ODE solvers with different orders serves as a method to estimate the local truncation error.","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"note: Note\nIf you have computed the steps for the o_1 method and the o_2 method, then under the assumption that h is sufficiently small, then the LTE of the o_2 method should be smaller than the LTE of the o_1 method. Thus while the error estimate is of the o_1 method, we can take the steps using the o_2 method. This is known as the local extrapolation trick and is common in adaptive time stepping software.","category":"page"},{"location":"lectures/lecture3/#Reassessing-Dormand-Prince,-i.e.-\"ode45\",-With-Adaptivity","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Reassessing Dormand-Prince, i.e. \"ode45\", With Adaptivity","text":"","category":"section"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Let's look back at the canonical tableau for the Dormand-Prince method:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"(Image: )","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Notice that there are two lines for the b_i coefficients. It turns out that this method is designed so that with the same set of k_i, there are two methods that are calculated. The first method is a 7-stage 5th order method, and the second method is a 7-stage 4th order method. Their difference is thus an approximation to the LTE, notably with 0 extra f evaluations. This is known as an embedded error estimate.","category":"page"},{"location":"lectures/lecture3/#Choosing-h-and-Rejection-Sampling","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Choosing h and Rejection Sampling","text":"","category":"section"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"The simplest way to choose h is to make it proportional to the current error. If we have a local truncation error estimate LTE and have a tolerance target of TOL, then we can define the update factor:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"q = fracLTETOL","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"If q  1, then TOL  LTE and therefore we should not accept this step as doing so will make a step beyond the user's tolerance. And note that this would void our warrenty on the global error being bounded, since we need the LTE is \"bounded\" (at least approximately) at every step to then have any statement about the global error. Thus the calculation with the current h is rejected, the h is changed to qh and the step is recomputed with this smaller time step.\nIf q geq 1, then TOL leq LTE and thus the step is good. Therefore we accept the step and grow h, for example making the new h equal to qh.","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Importantly, this means that rejection is way more expensive than acceptance, and therefore it's always good to be a little conservative with step growth. Thus generally the changes are done with a factor, Cqh, where this C = 09 or 0.8 or similar.","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"This is effectively an integral controller on the error term. More advanced schemes are discussed in detail in the DifferentialEquations.jl timestepping documentation.","category":"page"},{"location":"lectures/lecture3/#Dense-Output-And-Saving-Approximations","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Dense Output And Saving Approximations","text":"","category":"section"},{"location":"lectures/lecture3/#Constructing-General-Dense-Output-Schemes","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Constructing General Dense Output Schemes","text":"","category":"section"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"All of the schemes above only describe the solution at approximation time points u_n approx u(t+nh), but of course the true solution is a continuous object. How could one construct a continuous approximation over the full interval t in (t_0 t_f)? The simplest idea is to use the points u_n in order to construct an interpolating polynomial tildeu(t). For example, using a linear polynomial, we can approximate any value u(t+(n+theta)h) by:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"u(t+(n+theta)h) approx theta u_n + (1-theta) u_n+1","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"for any theta in 01. Similarly, quadratic, cubic, and further splines can be constructed. However, these approximations can be quite unstable at higher order and it does not make use of information that is already computed. For all of the Runge-Kutta methods, we have that k_1 = f(u_npt_n) approx u(t_n), and thus we not only have approximations to u(t+nh) but also have \"free\" (already computed) approximations to u(t+nh) as well. Using this information, we can approximate any value u(t+(n+theta)h) by the Hermite polynoimal:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"(1 - Θ) u(t_n) + Θ u(t_n+1) + (Θ (Θ - 1) ((1 - 2Θ) (u(t_n+1) - u(t_n)) + (Θ - 1) h u(t_n) + Θ h u(t_n+1))","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"However, this train of thought indicates that we are still missing information since each k_i in the Runge-Kutta method is an approximation to some u(t+(n+c)h)! Therefore, what if we constructed an approximation using all of the k_i derivative approximation?","category":"page"},{"location":"lectures/lecture3/#Method-Specific-Dense-Output-Schemes","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Method-Specific Dense Output Schemes","text":"","category":"section"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Each Runge-Kutta method computes k_i estimates within each step, which are all derivative estimates. Using these k_i we construct the output using the update equation:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"u_n+1 = u_n + h(b_1 k_1 + b_2 k_2 + ldots + b_s k_s)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"The update equation has b_i chosen such that the final solution u_n+1 is of the desired order. However, we can generalize this process a bit to the following. Assuming we we can calculate the solution at u_n+theta for any theta in 01, we can instead construct the following update equation:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"u_n+theta = u_n + h(b_1(theta) k_1 + b_2(theta) k_2 + ldots + b_s(theta) k_s)","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"where the b_i(theta) are parameterized polynomial equations. We then simply require that b_i(1) = b_i, and with to find the parameters r_ij of the polynomials, i.e. ","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"b_i(theta) = r_i0 + r_i1 theta + ldots + r_is theta^s","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"with respect to theta such that u_n+theta is an o-th order approximation to the solution. This  o is generally found to be strictly less than the order of the method. For example, further work by Shampine found a set of coefficients r_ij for the Dormand-Prince method which gives a 4th order dense approximation, which is thus the commonly used densification for the ode45 or dopri5 scheme.","category":"page"},{"location":"lectures/lecture3/#Decoupling-Stepping-From-Saving-in-Adaptive-Schemes","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Decoupling Stepping From Saving in Adaptive Schemes","text":"","category":"section"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Now why is dense output important? When we were using a non-adaptive scheme, we could know where our step points would be. For example, if we wanted values of the solution output at {1/2, 1, 3/2, ...}, we could simply set h=12 and receive these values. If the error was too high, we could simply re-compute the solution with h=14, or any other integer divisor of our desired outputs.","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"However, once we move to an adaptive scheme, we cannot guarantee to the user that the method will step to specific points. We can either do two things:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Always take the minimum of the desired h and the distance to the next saving point. Since decreasing h decreases the error, this thus enforces that the TOL is satisfied, though it may be overly conservative in many situations.\nWe take steps using the desired h and at the end of each step, use the embedded dense output scheme in order to compute the values at save points desired by the user.","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"The scheme 2 uses our developed machinery to be as fast as possible, while achieving the goals of the user (TOL goals and save point goals). However given this saving behavior is generally of a lower order than the true steps of the solver, the saved points tend to be approximated to a lower order than the solver itself. ","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"note: Note\nBecause the Dormand-Prince method has a 4th order dense output, it's commonly misstated the ode45/dopri5 method is 4th order, since empirical studies which do not carefully control the stepping to match the saving will see 4th order convergence!","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"note: Note\node45 has a default where when no save points are given, it will return values given by the adaptivity scheme. However, it's not only the values the method steps to, but also 4 evenly spaced points in the interval, computed using the dense output!","category":"page"},{"location":"lectures/lecture3/#Diving-into-the-Simplest-Tsit5","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Diving into the Simplest Tsit5","text":"","category":"section"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Using this background, we can dive into the simplest implementation of the Tsit5 explicit Runge-Kutta method and understand all of the details:","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Link to SimpleDiffEq.jl GPUATsit5 Code","category":"page"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"Link to Tsit5 Tableau","category":"page"},{"location":"lectures/lecture3/#Conclusion","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Conclusion","text":"","category":"section"},{"location":"lectures/lecture3/","page":"Solvers for Non-Stiff Ordinary Differential Equations","title":"Solvers for Non-Stiff Ordinary Differential Equations","text":"This is the most basic ODE solver, a non-stiff Runge-Kutta method. There's a surprising amount of machinery involved, and there's still more research being done on this topic. But we will continue to the next type of methods using what we have discussed here as now the building block for the more complex implicit methods used for stiff ODEs and DAEs.","category":"page"},{"location":"lectures/lecture6/#Debugging-difficult-stiff-ODE/DAE-models","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"","category":"section"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"Below is a list of best practices to help avoid problems in model development and strategies that can be used to debug a problematic model.","category":"page"},{"location":"lectures/lecture6/#Best-Practices","page":"Debugging difficult stiff ODE/DAE models","title":"Best Practices","text":"","category":"section"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"In the world of programming, debugging a model has got to be the most challenging because all equations must be solved together.  If any equation is wrong then not only will the model not solve, but there is very little that can be done to identify which equation is problematic.  Therefore the best that we can do is implement best practices to ensure the model is correct from the beginning. ","category":"page"},{"location":"lectures/lecture6/#Use-acausal-modeling-(i.e.-ModelingToolkit.jl)","page":"Debugging difficult stiff ODE/DAE models","title":"Use acausal modeling (i.e. ModelingToolkit.jl)","text":"","category":"section"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"As has been shown ModelingToolkit.jl will help in many ways with model definition.  One of the first programming practices that it enables is the DRY (Don't Repeat Yourself) principle.  By defining components once and reusing them, this helps reduce the chance of human error.  For example, when discovering a component level bug, it will be fixed at one source of truth and the fix will automatically propagate throughout.  ","category":"page"},{"location":"lectures/lecture6/#Start-small-and-verify-components","page":"Debugging difficult stiff ODE/DAE models","title":"Start small and verify components","text":"","category":"section"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"In using acausal modeling, the main focus for ensuring well defined models lies mainly at the component level.  Make sure to implement the rules of thumb discussed previously for number of equations and sign conventions.   Each component should have a well defined unit test.  When building your model start with the smallest subsystem possible and build from there.  Attempting to build a full system model before checking the pieces is doomed to fail, leaving little to no insight into what went wrong.  When a model fails to run, the error message will rarely give enough information to pinpoint the problem.  The best tool for debugging is taking small incremental steps which allows one to identify which change caused the problem.  ","category":"page"},{"location":"lectures/lecture6/#Make-sure-equations-match-states","page":"Debugging difficult stiff ODE/DAE models","title":"Make sure equations match states","text":"","category":"section"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"It is not always the case, but for most models, the unsimplified system should give a match of equations and states.  Let's take the pendulum problem for example","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"using ModelingToolkit, DifferentialEquations, Plots\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\npars = @parameters m = 1 g = 1 L = 1 Φ=0\n\nvars = @variables begin\n    x(t)=+L*cos(Φ)\n    y(t)=-L*sin(Φ)\n    dx(t)=0\n    dy(t)=0\n    λ(t) = 0\nend\n\neqs = [\n    D(x) ~ dx   \n    D(y) ~ dy\n\n    m*D(dx) ~ -λ*(x/L)\n    m*D(dy) ~ -λ*(y/L) - m*g\n\n    x^2 + y^2 ~ L^2 # algebraic constraint\n]\n\n@named pendulum = ODESystem(eqs, t, vars, pars)\nnothing # hide","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"When we view the ODESystem we can see it has matching equations and states","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"pendulum","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"Note: when using @mtkbuild then structural_simplify is automatically called and we therefore cannot see the unsimplify system.  Replace @mtkbuild with @named to generate an ODESystem without applying structural_simplify.","category":"page"},{"location":"lectures/lecture6/#Add-compliance","page":"Debugging difficult stiff ODE/DAE models","title":"Add compliance","text":"","category":"section"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"The pendulum problem as described above is derived assuming the following:","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"a massless perfectly stiff and rigid string/rod connected to the mass\na point mass\na frictionless mechanism","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"If we attempt to solve this system we can see that it only solves up to the point that x crosses 0.","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"sys = complete(structural_simplify(pendulum))\nprob = ODEProblem(sys, ModelingToolkit.missing_variable_defaults(sys), (0, 10))\nsol = solve(prob)# gives retcode: DtLessThanMin\nplot(sol; idxs=[x,y])","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"The problem is rooted in the algebraic constraint which has x^2 and y^2.  Having exponents (squares or square roots) can often cause issues with numerical solutions.  In this case the issue is that a unique solution cannot be found, x could be positive or negative.  There are different solutions to this problem, however lets consider the concept of adding compliance.  In reality is it really possible to have a massless, perfectly stiff and rigid string?  No.  Therefore let's consider adjusting the problem so the string has stiffness, which means we add L now as a variable.","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"pars = @parameters m = 1 g = 1 L_0 = 1 Φ=0 k=1e6\n\nvars = @variables begin\n    L(t)=L_0\n    x(t)=+L*cos(Φ)\n    y(t)=-L*sin(Φ)\n    dx(t)=0\n    dy(t)=0\n    λ(t) = 0\nend\n\neqs = [\n    D(x) ~ dx   \n    D(y) ~ dy\n\n    m*D(dx) ~ -λ*(x/L)\n    m*D(dy) ~ -λ*(y/L) - m*g\n\n    x^2 + y^2 ~ L^2 # algebraic constraint\n\n    λ ~ k*(L - L_0) # string stiffness\n]\n\n@named stiffness_pendulum = ODESystem(eqs, t, vars, pars)\nsys = structural_simplify(stiffness_pendulum)\nprob = ODEProblem(sys, ModelingToolkit.missing_variable_defaults(sys), (0, 10))\nsol = solve(prob)# Success\nplot(sol; idxs=[x,y])","category":"page"},{"location":"lectures/lecture6/#Try-dae_index_lowering()","page":"Debugging difficult stiff ODE/DAE models","title":"Try dae_index_lowering()","text":"","category":"section"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"In some cases we can apply dae_index_lowering() to further simplify the problem.  In this case ModelingToolkit.jl finds a better form of the equations which can be solved without issue.","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"sys = structural_simplify(dae_index_lowering(pendulum))\nprob = ODEProblem(sys, ModelingToolkit.missing_variable_defaults(sys), (0, 10))\nref = solve(prob)\nplot(ref; idxs=x, label=\"dae_index_lowering\")\nplot!(sol; idxs=x, label=\"compliance\")","category":"page"},{"location":"lectures/lecture6/#Design-components-with-variable-complexity/fidelity","page":"Debugging difficult stiff ODE/DAE models","title":"Design components with variable complexity/fidelity","text":"","category":"section"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"In general this can be achieved with parameters.  For example, a mass-spring-damper system can easily become a mass-damper system by setting the spring stiffness to zero.  But in other cases we might want to structurally variable the complexity.  For example, the ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.Tube component has 2 structural parameters:","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"N for discretization\nadd_inertia for including the wave equation","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"Based on the inputs of these structural parameters, the number of generated equations will be different.  Therefore, to start simple, one can set N=0 and add_inertia=false to generate the simplest form of the problem.  Solving this case first and ensuring the model physical behavior is correct is a good best practice before attempting to increase the fidelity of the model.  ","category":"page"},{"location":"lectures/lecture6/#Check-values-of-parameters","page":"Debugging difficult stiff ODE/DAE models","title":"Check values of parameters","text":"","category":"section"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"Another possible cause of problems in your model can come not from the equations, but from the parameters that are supplied to the equations.  As discussed previously, models are stiff not because of their equations but because of the parameters.  It's always a good idea to ensure your parameters match real life values to some degree. To ensure human error is not factoring in, it can be a good idea to use units (note ModelingToolkit v9 will be enforcing units using Uniful.jl).  If you know all of your parameters are correct but still having issues, another debugging strategy is to reduce the energy input of your system.  Rather than starting at 100%, start at 10%.  This gives the model a better chance to solve and with a model solution this gives some insight to what the root cause problem might be.  For example, if working with a hydraulic system, turn the input pressure down to 10%. ","category":"page"},{"location":"lectures/lecture6/#Check-acausal-boundary-conditions","page":"Debugging difficult stiff ODE/DAE models","title":"Check acausal boundary conditions","text":"","category":"section"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"As discussed in Lecture 1, acausal connections always have a minimum of 2 variables.  Therefore, acausal input (or boundary condition) components will need to pay attention to what should be done to both variables.  As an example, refer to the hydraulic cylinder problem from Lecture 2 and consider the case where the position x is supplied as the input boundary condition and the mass flow input dotm is set to an Open() boundary condition, thereby solving for dotm to give input x.","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"(Image: example)","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"We can assemble the problem as","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"import ModelingToolkitStandardLibrary.Mechanical.Translational as T\nimport ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible as IC\nimport ModelingToolkitStandardLibrary.Blocks as B\n\ninclude(\"volume.jl\") # <-- missing Volume component from MTKSL (will be released in new version)\n\nfunction MassVolume(solves_force = true; name)\n\n    pars = @parameters begin\n        A = 0.01 #m²\n        x₀ = 1.0 #m\n        M = 10_000 #kg\n        g = 9.807 #m/s²\n        amp = 5e-2 #m\n        f = 15 #Hz\n        p_int=M*g/A\n        dx=0\n        drho=0\n        dm=0\n    end\n    vars = []\n    systems = @named begin\n        fluid = IC.HydraulicFluid(; density = 876, bulk_modulus = 1.2e9)\n        mass = T.Mass(;v=dx,m=M,g=-g)\n        vol = Volume(;area=A, x=x₀, p=p_int, dx, drho, dm) # <-- missing Volume component from MTKSL (will be released in new version)\n        mass_flow = IC.Open(;p_int)\n        position = T.Position(solves_force)\n        position_input = B.TimeVaryingFunction(;f = t -> amp*sin(2π*t*f) + x₀)\n    end\n\n    eqs = [\n        connect(mass.flange, vol.flange, position.flange)\n        connect(vol.port, mass_flow.port)\n        connect(position.s, position_input.output)\n    ]\n\n    return ODESystem(eqs, t, vars, pars; systems, name)\nend\n\n@named odesys = MassVolume()\nnothing # hide","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"If we check the number of equations and states we see a mismatch!","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"odesys","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"The reason for the mismatch is that the input boundary condition Position() needs to know what to do about the connection variable for force f.  In this problem, do we need a force introduced to the system to make the mass move as set by Position()?  The answer is no, the force causing the mass to move is already given by the hydraulic pressure and gravity.  If we look at the documentation for Position() we can see that it has a structural parameter solves_force which is defaulted to true.  Therefore, to assemble the proper system we set this to false and now have a properly defined system","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"@named odesys = MassVolume(false)","category":"page"},{"location":"lectures/lecture6/#Debugging-Strategies","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging Strategies","text":"","category":"section"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"It's very difficult to identify what is wrong with a model if it's not outputting any data.  This section discusses ways to force a model solution.  It's still possible that something with the model is wrong, but the best way to know that is to see what the equations are outputting.  For example if the model is simulating negative pressure, but negative pressure is impossible, then this is a good clue of what is wrong with the model!  The strategies for forcing a model solve will come from a simple hydraulic system that is attempting to start a hydraulic cylinder at a high pressure differential.  See ModelingToolkit Industrial Example for more information about the model.","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"@mtkmodel System begin\n    @parameters begin\n        res₁₊Cₒ = 2.7\n        res₁₊Aₒ = 0.00094\n        res₁₊ρ₀ = 1000\n        res₁₊p′ = 3.0e7\n        res₂₊Cₒ = 2.7\n        res₂₊Aₒ = 0.00094\n        res₂₊ρ₀ = 1000\n        res₂₊p′ = 0\n        act₊p₁′ = 3.0e7\n        act₊p₂′ = 0\n        act₊vol₁₊A = 0.1\n        act₊vol₁₊ρ₀ = 1000\n        act₊vol₁₊β = 2.0e9\n        act₊vol₁₊direction = -1\n        act₊vol₁₊p′ = act₊p₁′\n        act₊vol₁₊x′ = 0.5\n        act₊vol₂₊A = 0.1\n        act₊vol₂₊ρ₀ = 1000\n        act₊vol₂₊β = 2.0e9\n        act₊vol₂₊direction = 1\n        act₊vol₂₊p′ = act₊p₂′\n        act₊vol₂₊x′ = 0.5\n        act₊mass₊m = 100\n        act₊mass₊f′ = 0.1(-act₊p₁′ + act₊p₂′)\n        src₊p′ = 3.0e7\n        snk₊p′ = 0\n        dmp₊c = 1000\n    end\n    @variables begin\n        res₁₊ṁ(t) = 0\n        res₁₊p₁(t) = res₁₊p′\n        res₁₊p₂(t) = res₁₊p′\n        res₁₊port₁₊p(t) = res₁₊p′\n        res₁₊port₁₊ṁ(t) = 0\n        res₁₊port₂₊p(t) = res₁₊p′\n        res₁₊port₂₊ṁ(t) = 0\n        res₂₊ṁ(t) = 0\n        res₂₊p₁(t) = res₂₊p′\n        res₂₊p₂(t) = res₂₊p′\n        res₂₊port₁₊p(t) = res₂₊p′\n        res₂₊port₁₊ṁ(t) = 0\n        res₂₊port₂₊p(t) = res₂₊p′\n        res₂₊port₂₊ṁ(t) = 0\n        act₊port₁₊p(t) = act₊p₁′\n        act₊port₁₊ṁ(t) = 0\n        act₊port₂₊p(t) = act₊p₂′\n        act₊port₂₊ṁ(t) = 0\n        act₊vol₁₊p(t) = act₊vol₁₊p′\n        act₊vol₁₊x(t) = act₊vol₁₊x′\n        act₊vol₁₊ṁ(t) = 0\n        act₊vol₁₊f(t) = act₊vol₁₊A * act₊vol₁₊p′\n        act₊vol₁₊ẋ(t) = 0\n        act₊vol₁₊r(t) = act₊vol₁₊ρ₀ * (1 + act₊vol₁₊p′ / act₊vol₁₊β)\n        act₊vol₁₊ṙ(t) = 0\n        act₊vol₁₊port₊p(t) = act₊vol₁₊p′\n        act₊vol₁₊port₊ṁ(t) = 0\n        act₊vol₁₊flange₊ẋ(t) = 0\n        act₊vol₁₊flange₊f(t) = -act₊vol₁₊A * act₊vol₁₊direction * act₊vol₁₊p′\n        act₊vol₂₊p(t) = act₊vol₂₊p′\n        act₊vol₂₊x(t) = act₊vol₂₊x′\n        act₊vol₂₊ṁ(t) = 0\n        act₊vol₂₊f(t) = act₊vol₂₊A * act₊vol₂₊p′\n        act₊vol₂₊ẋ(t) = 0\n        act₊vol₂₊r(t) = act₊vol₂₊ρ₀ * (1 + act₊vol₂₊p′ / act₊vol₂₊β)\n        act₊vol₂₊ṙ(t) = 0\n        act₊vol₂₊port₊p(t) = act₊vol₂₊p′\n        act₊vol₂₊port₊ṁ(t) = 0\n        act₊vol₂₊flange₊ẋ(t) = 0\n        act₊vol₂₊flange₊f(t) = -act₊vol₂₊A * act₊vol₂₊direction * act₊vol₂₊p′\n        act₊mass₊f(t) = act₊mass₊f′\n        act₊mass₊x(t) = 0\n        act₊mass₊ẋ(t) = 0\n        act₊mass₊ẍ(t) = act₊mass₊f′ / act₊mass₊m\n        act₊mass₊flange₊ẋ(t) = 0\n        act₊mass₊flange₊f(t) = act₊mass₊f′\n        act₊flange₊ẋ(t) = 0\n        act₊flange₊f(t) = 0\n        src₊port₊p(t) = src₊p′\n        src₊port₊ṁ(t) = 0\n        snk₊port₊p(t) = snk₊p′\n        snk₊port₊ṁ(t) = 0\n        dmp₊flange₊ẋ(t) = 0\n        dmp₊flange₊f(t) = 0\n    end\n    @equations begin\n        res₁₊ṁ ~ res₁₊port₁₊ṁ\n        res₁₊ṁ ~ -res₁₊port₂₊ṁ\n        res₁₊p₁ ~ res₁₊port₁₊p\n        res₁₊p₂ ~ res₁₊port₂₊p\n        -res₁₊p₂ + res₁₊p₁ ~ 0.5res₁₊Cₒ * res₁₊ρ₀ * ((res₁₊ṁ / (res₁₊Aₒ * res₁₊ρ₀))^2)\n        res₂₊ṁ ~ res₂₊port₁₊ṁ\n        res₂₊ṁ ~ -res₂₊port₂₊ṁ\n        res₂₊p₁ ~ res₂₊port₁₊p\n        res₂₊p₂ ~ res₂₊port₂₊p\n        -res₂₊p₂ + res₂₊p₁ ~ 0.5res₂₊Cₒ * res₂₊ρ₀ * ((res₂₊ṁ / (res₂₊Aₒ * res₂₊ρ₀))^2)\n        D(act₊vol₁₊x) ~ act₊vol₁₊ẋ\n        D(act₊vol₁₊r) ~ act₊vol₁₊ṙ\n        act₊vol₁₊p ~ act₊vol₁₊port₊p\n        act₊vol₁₊ṁ ~ act₊vol₁₊port₊ṁ\n        act₊vol₁₊f ~ -act₊vol₁₊direction * act₊vol₁₊flange₊f\n        act₊vol₁₊ẋ ~ act₊vol₁₊direction * act₊vol₁₊flange₊ẋ\n        act₊vol₁₊r ~ act₊vol₁₊ρ₀ * (1 + act₊vol₁₊p / act₊vol₁₊β)\n        act₊vol₁₊ṁ ~ act₊vol₁₊A * act₊vol₁₊ẋ * act₊vol₁₊r + act₊vol₁₊A * act₊vol₁₊x * act₊vol₁₊ṙ\n        act₊vol₁₊f ~ act₊vol₁₊A * act₊vol₁₊p\n        D(act₊vol₂₊x) ~ act₊vol₂₊ẋ\n        D(act₊vol₂₊r) ~ act₊vol₂₊ṙ\n        act₊vol₂₊p ~ act₊vol₂₊port₊p\n        act₊vol₂₊ṁ ~ act₊vol₂₊port₊ṁ\n        act₊vol₂₊f ~ -act₊vol₂₊direction * act₊vol₂₊flange₊f\n        act₊vol₂₊ẋ ~ act₊vol₂₊direction * act₊vol₂₊flange₊ẋ\n        act₊vol₂₊r ~ act₊vol₂₊ρ₀ * (1 + act₊vol₂₊p / act₊vol₂₊β)\n        act₊vol₂₊ṁ ~ act₊vol₂₊A * act₊vol₂₊r * act₊vol₂₊ẋ + act₊vol₂₊A * act₊vol₂₊ṙ * act₊vol₂₊x\n        act₊vol₂₊f ~ act₊vol₂₊A * act₊vol₂₊p\n        D(act₊mass₊x) ~ act₊mass₊ẋ\n        D(act₊mass₊ẋ) ~ act₊mass₊ẍ\n        act₊mass₊f ~ act₊mass₊flange₊f\n        act₊mass₊ẋ ~ act₊mass₊flange₊ẋ\n        act₊mass₊m * act₊mass₊ẍ ~ act₊mass₊f\n        src₊port₊p ~ src₊p′\n        snk₊port₊p ~ snk₊p′\n        dmp₊flange₊f ~ dmp₊c * dmp₊flange₊ẋ\n        src₊port₊p ~ res₁₊port₁₊p\n        0 ~ res₁₊port₁₊ṁ + src₊port₊ṁ\n        res₁₊port₂₊p ~ act₊port₁₊p\n        0 ~ act₊port₁₊ṁ + res₁₊port₂₊ṁ\n        act₊port₂₊p ~ res₂₊port₁₊p\n        0 ~ act₊port₂₊ṁ + res₂₊port₁₊ṁ\n        res₂₊port₂₊p ~ snk₊port₊p\n        0 ~ res₂₊port₂₊ṁ + snk₊port₊ṁ\n        dmp₊flange₊ẋ ~ act₊flange₊ẋ\n        0 ~ act₊flange₊f + dmp₊flange₊f\n        act₊port₁₊p ~ act₊vol₁₊port₊p\n        0 ~ act₊vol₁₊port₊ṁ - act₊port₁₊ṁ\n        act₊port₂₊p ~ act₊vol₂₊port₊p\n        0 ~ -act₊port₂₊ṁ + act₊vol₂₊port₊ṁ\n        act₊vol₁₊flange₊ẋ ~ act₊vol₂₊flange₊ẋ\n        act₊vol₁₊flange₊ẋ ~ act₊mass₊flange₊ẋ\n        act₊vol₁₊flange₊ẋ ~ act₊flange₊ẋ\n        0 ~ act₊vol₁₊flange₊f - act₊flange₊f + act₊vol₂₊flange₊f + act₊mass₊flange₊f\n    end\nend\n\n@mtkbuild sys = System()\nprob = ODEProblem(sys, [], (0, 0.1))\nsol = solve(prob)","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"As can be seen, when attempting to solve we get an Unstable return code.  Let's explore strategies to fix the problem or find a forced numerical solution for debugging purposes.","category":"page"},{"location":"lectures/lecture6/#Initial-Conditions","page":"Debugging difficult stiff ODE/DAE models","title":"Initial Conditions","text":"","category":"section"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"First, let's check the initial conditions to see if at time 0 we are starting with zero residual for our algebraic equations.","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"eqs = full_equations(sys)\ndefs = ModelingToolkit.defaults(sys)\nresiduals = Float64[]\nfor eq in eqs\n    if !ModelingToolkit.isdifferential(eq.lhs)\n        push!(residuals, ModelingToolkit.fixpoint_sub(eq.rhs, defs))\n    end\nend\nresiduals","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"As can be seen, we have a problem with our first algebraic equation, the residual is not zero!  To solve this problem, ModelingToolkit v9 will be releasing a new feature to properly generate a non-linear system to calculate initial conditions.  We also can apply the Initialization Schemes provided from DifferentialEquations.jl.  The BrownFullBasicInit is the default algorithm used, and this did not work for our problem, so we will move to the ShampineCollocationInit.","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"dt = 1e-7\nsol = solve(prob; initializealg=ShampineCollocationInit(dt))","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"The ShampineCollocationInit solves the initial conditions by essentially taking a small step forward in time (dt) and then updating the initial conditions with that solve.  If this doesn't work, we can instead do this manually. ","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"prob = ODEProblem(sys, [], (0, dt))\nsol = solve(prob, ImplicitEuler(nlsolve=NLNewton(check_div=false, always_new=true, relax=4/10, max_iter=100)); dt, adaptive=false)\n\n# update u0 with the ImplicitEuler non-adaptive step\nprob′ = ODEProblem(sys, sol[2], (0, 0.1))\nsol = solve(prob′);\nplot(sol; idxs=sys.act₊mass₊ẋ)","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"As can be seen, now we have a successful solve.  We can see the change to the initial conditions is very minimal.  As can be seen, the solver needs the derivative terms to be offset by a small amount.","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"println(join([\"$s : $(round(x; digits=3)) -> $(round(y; digits=3))\" for (s,x,y) in zip(unknowns(sys), prob.u0, prob′.u0)],'\\n'))","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"Another strategy that can help issues with initial conditions is to offset or perturb any initial conditions from 0 by a small value.  ","category":"page"},{"location":"lectures/lecture6/#Adjust-tolerance","page":"Debugging difficult stiff ODE/DAE models","title":"Adjust tolerance","text":"","category":"section"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"Here we get a solve by increasing the abstol and reltol to very large values.  This is therefore understood to give us a very low resolution solution that is far from the true solution, but we can now at least see if the model is calculating generally correct values, at least with the correct sign.  Here we expect the act₊mass₊ẋ to be around -1 and that's exactly what we get.  However, as can be seen the tolerance is too open to resolve the dynamics.  ","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"prob = ODEProblem(sys, [], (0, 0.1))\nsol = solve(prob, ImplicitEuler(); abstol=10000.0, reltol=100.0)\nplot(sol; idxs=sys.act₊mass₊ẋ)","category":"page"},{"location":"lectures/lecture6/#Turn-off-adaptivity","page":"Debugging difficult stiff ODE/DAE models","title":"Turn off adaptivity","text":"","category":"section"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"Another strategy similar to adjusting tolerance is to turn off adaptivity.  This means we can no longer guarantee tolerance, but we can at least adjust the time step such that it's small enough to give a good solution.  A good practice is to continue to decrease dt until the solution converges (i.e. stops changing).  Without adaptivity this is another way to help ensure solution accuracy.  ","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"prob = ODEProblem(sys, [], (0, 0.1))\nsol = solve(prob, ImplicitEuler(nlsolve=NLNewton(check_div=false, always_new=true, relax=4/10, max_iter=100)); initializealg=NoInit(), adaptive=false, dt=1e-6)\nplot(sol; idxs=sys.act₊mass₊ẋ)","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"Note the use of keywords: ","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"check_div=false: ensures the problem doesn't exit early because of divergence\nalways_new=true: ensures Jacobian is always updated to give a more robust solve\nrelax: for relaxation of Newton iterations to give a more robust solve\nmax_iter to ensure enough iterations are available","category":"page"},{"location":"lectures/lecture6/#Jacobian-generation","page":"Debugging difficult stiff ODE/DAE models","title":"Jacobian generation","text":"","category":"section"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"There are 3 different ways to calculate the Jacobian from ModelingToolkit:","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"analytically, by using jac=true keyword given to ODEProblem\nautomatically with automatic differentiation using autodiff=true given to the solver algorithms that use Jacobians\nautomatically with finite differencing using autodiff=false","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"Each choice offers different levels of numerical accuracy (in order from highest to lowest) and computational expense.  In some cases choosing a less numerical accurate Jacobian can actually help provide a solution for very stiff problems.  ","category":"page"},{"location":"lectures/lecture6/#DAE-conversion-to-ODE","page":"Debugging difficult stiff ODE/DAE models","title":"DAE conversion to ODE","text":"","category":"section"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"If all else fails, one concept that may work is to convert the DAE to an ODE by implementing a small epsilon (epsilon) term such that when epsilon=0 the problem is a DAE and when epsilon is small the problem approximates an ODE.  For example, consider the DAE","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"dotx = y \n0 = x + y","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"We can adjust the 2nd equation to approximate an ODE like","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"dotx = y \nepsilon cdot doty = x + y","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"The below function can create such a transformation.  ","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"using Setfield\n\nfunction dae_to_ode(sys::ODESystem)\n\n    are_vars_equal(var1, var2) = string(var1) == string(var2)\n\n    defs = ModelingToolkit.defaults(sys)\n    pars = parameters(sys)\n    sts = unknowns(sys)\n    eqs = equations(sys)\n    iv = ModelingToolkit.independent_variable(sys)   \n    D = Differential(iv)\n\n    diff_vars = []\n    for eq in eqs\n        eq_sts = []\n        ModelingToolkit.vars!(eq_sts, eq)\n        diffs = ModelingToolkit.isdifferential.(eq_sts) \n        if any(diffs)\n            diff = eq_sts[diffs] |> first\n            diff_var = ModelingToolkit.arguments(diff) |> first\n            push!(diff_vars, diff_var)\n        end\n    end\n   \n    diffs = setdiff(sts, diff_vars)\n\n    @parameters ϵ\n    j = 1\n    neqs = Equation[]\n    for eq in eqs\n        if ModelingToolkit._iszero(eq.lhs)\n            push!(neqs, D(diffs[j]) ~ eq.rhs/ϵ)\n            j+=1\n        else\n            push!(neqs, eq)\n        end\n    end\n\n    @set! sys.eqs = neqs\n    @set! sys.ps = [ModelingToolkit.unwrap(ϵ); pars]\n    @set! sys.defaults = Dict(ϵ => -1e-12,  pairs(defs)...)\n\n    return sys\nend\nnothing # hide","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"Implementing this for the hydraulic system works well, giving an adaptive time solution using Tsit5","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"odesys = dae_to_ode(sys)\nprob = ODEProblem(odesys, [], (0,0.1))\nsol = solve(prob)\nplot(sol; idxs=sys.act₊mass₊ẋ)","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"Note this problem, as we've seen, has a lot of trouble with initialization.  Note how the first 200 steps are taken with a very small time step.  The Tsit5 solver is able to successfully push through the model initialization and then solve the remaining steps at a reasonable time step.  ","category":"page"},{"location":"lectures/lecture6/","page":"Debugging difficult stiff ODE/DAE models","title":"Debugging difficult stiff ODE/DAE models","text":"plot(diff(sol.t))","category":"page"},{"location":"lectures/lecture7/#Numerical-and-Structural-Characterizations-for-DAEs","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"","category":"section"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"Numerical solvers cannot solve all DAEs. Consider the DAE system","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"F(x y z x y z t) = beginpmatrix\n    x + y - sin(t) \n    z - sin(t) \n    z - cos(t)\nendpmatrix = 0","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"Note that the second equation and the third equation are equivalent, and there are not enough constraints to uniquely determine x and y. Let's see how numerical solvers and ModelingToolkit behave.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"using DifferentialEquations, Sundials, ModelingToolkit, Plots, LinearAlgebra\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\nfunction f!(out, du, u, p, t)\n    # u[1]: x, du[1]: x'\n    # u[2]: y, du[2]: y'\n    # u[3]: z, du[3]: z'\n    out[1] = u[1] + u[2] - sin(t)\n    out[2] = u[3] - sin(t)\n    out[3] = du[3] - cos(t)\nend\nprob = DAEProblem(f!, [0.0, 0.0, 1.0], [0.0, 0.0, 0.0], (0, 100.0), differential_vars=[false, false, true])\nsol1 = solve(prob, IDA())\nsol2 = solve(prob, DFBDF())\nprintln(sol1.retcode, \"\\t\", sol2.retcode)","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"As expected, numerical solvers exit early and they cannot take more than one step. We call such systems non-integrable or singular. Let's try to use ModelingToolkit to analyze this problem.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"@variables x(t) y(t) z(t)\n\neqs = [\n    x + y ~ sin(t)\n    z ~ sin(t)\n    D(z) ~ cos(t)\n]\n@named sys = ODESystem(eqs, t)\nsys = complete(sys);\ntry structural_simplify(sys) catch e println(e) end","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"We can see that ModelingToolkit also errors, correctly identifying that the system is singular.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"Let's consider another DAE system","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"F(x y x y t) = beginpmatrix\n    x - sin(t) \n    x - y\nendpmatrix = 0","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"If we plug the first equation into the second equation, we have","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"y(t) = (sin(t)) = cos(t)","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"Superficially, we can have the initial condition","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"x(0) = x(0) = y(0) = y(0) = 0","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"However, if we differentiate the first equation once, we get the hidden constraint","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"x(t) - cos(t) = 0","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"Thus, the true consistent initial condition is","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"x(0) = y(0) = 1 x(0) = y(0) = 0","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"Let's try to solve this simple DAE using a numerical solver.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"function f!(out, du, u, p, t)\n    # u[1]: x, du[1]: x'\n    # u[2]: y, du[2]: y'\n    out[1] = u[1] - sin(t)\n    out[2] = du[1] - u[2]\nend\nprob = DAEProblem(f!, [1, 0.0], [0.0, 1.0], (0, 100pi), differential_vars=[true, false])\nsol1 = solve(prob, IDA())\nsol2 = solve(prob, DFBDF())\nprintln(\"[sol1: \", sol1.retcode, \"]\",\n\"\\n\", \"[sol2 \", sol2.retcode, \": y(100pi)=\", sol2[2, end], \" steps: \", length(sol2.t), \"]\")","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"To better understand the numerical behavior, let's analyze the variable step size behavior of the implicit Euler method of the original system. The local truncation error for y is","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"beginalign\ntextlte = fracfracy(t_n) - y(t_n-1)h_n - fracy(t_n-1) - y(t_n-2)h_n-1\nh_n + h_n-1 (h_n + h_n-1) h_n \n= left(fracy(t_n) - y(t_n-1)h_n - fracy(t_n-1) - y(t_n-2)h_n-1right) h_n\n\n= h_nleft(fracfracsin(t_n) - sin(t_n-1)h_n - fracsin(t_n-1) - sin(t_n-2)h_n-1h_n -\nfracfracsin(t_n-1) - sin(t_n-2)h_n-1 - fracsin(t_n-2) - sin(t_n-3)h_n-2h_n-1right)\n\n=\nfracsin(t_n) - sin(t_n-1)h_n - fracsin(t_n-1) - sin(t_n-2)h_n-1 -\nh_n\nfracfracsin(t_n-1) - sin(t_n-2)h_n-1 - fracsin(t_n-2) - sin(t_n-3)h_n-2h_n-1\nendalign","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"Note that when h_n to 0, the local truncation error becomes","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"lim_h_nto 0 textlte = fracsin(t_n) - sin(t_n-1)h_n - fracsin(t_n-1) - sin(t_n-2)h_n-1\n= cos(t_n) - fracsin(t_n-1) - sin(t_n-2)h_n-1","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"Note that this in general does not converge to 0. Thus, numerical solvers could have difficulties in solving this system. Let's also confirm this numerical behavior by setting the maximum order to 1.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"solve(prob, DFBDF(max_order=Val(1)))","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"Let's replace the first equation with the differentiated equation and solve it numerically,","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"function g!(out, du, u, p, t)\n    # u[1]: x, du[1]: x'\n    # u[2]: y, du[2]: y'\n    out[1] = du[1] - cos(t)\n    out[2] = du[1] - u[2]\nend\nprob = DAEProblem(g!, [1, 0.0], [0.0, 1.0], (0, 100pi), differential_vars=[true, false])\nsol1_diff = solve(prob, IDA())\nsol2_diff = solve(prob, DFBDF())\nprintln(\"[sol1_diff: \", sol1_diff.retcode, \": y(100pi)=\", sol1_diff[2, end], \" steps: \", length(sol1_diff.t), \"]\",\n\"\\n\", \"[sol2_diff \", sol2_diff.retcode, \": y(100pi)=\", sol2_diff[2, end], \" steps: \", length(sol2_diff.t), \"]\")","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"We can see that it takes far fewer iterations to solve the system, and the numerical solution is much closer to the analytical solution y(100pi) = 1. If we check the residual of the original constraint, we get","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"plot(sol1_diff.t, sol1_diff[1, :] - sin.(sol1_diff.t), lab = \"IDA\")\nplot!(sol2_diff.t, sol2_diff[1, :] - sin.(sol2_diff.t), lab = \"DFBDF\")","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"We see a significant numerical drift from the original constraint for both DAE solvers. Again, let's see how ModelingToolkit does.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"@variables x(t) y(t)\neqs = [\n    x ~ sin(t)\n    D(x) ~ y\n]\n@named sys = ODESystem(eqs, t)\nsys = complete(sys)\nmodel = structural_simplify(sys)\nprob = ODEProblem(model, [x=>0.0, y=>1.0, D(x)=>0.0, D(y)=>1.0], (0, 100pi))\nsol = solve(prob, Rodas5P())\nprintln(\"[sol: \", sol.retcode, \": y(100pi)=\", sol[y, end], \" steps: \", length(sol.t), \"]\")","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"norm(sol[x, :] - sin.(sol.t))","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"We can see that ModelingToolkit handles this DAE system perfectly. y(t) is completely accurate, the original constraints are satisfied without drift, and the numerical solver needs to take minimal steps. In my following lectures, we will study how ModelingToolkit handles this example system.","category":"page"},{"location":"lectures/lecture7/#Numerical-Integrability-Criterion-for-DAEs","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical Integrability Criterion for DAEs","text":"","category":"section"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"There are both differential equations and algebraic equations in acausal models. Thus, a generic acausal model is a system of differential-algebraic equations (DAEs). In general, additional processing steps are required to simulate DAEs. To see this more clearly, we will analyze the implicit Euler algorithm which is the most basic form of both Runge-Kutta and linear multistep methods for DAEs.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"Given the DAE of the form","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"beginequation\n0 = F(u(t) u(t) p t)\nendequation","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"where F (mathbbR^n mathbbR^n mathbbR^m mathbbR) rightarrow mathbbR^n. The implicit Euler solves for u(t+h) from","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"beginequation\n0 = Fleft(frachatu(t+h) - u(t)h hatu(t+h) p t+hright)\nendequation","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"with fixed t h p, and u(t).","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"Numerically, we use Newton's method to solve potentially nonlinear equations by iteratively solving the best approximating linear equations (i.e., the Jacobian of the nonlinear function with respect to the unknowns) to refine an initial guess. By the chain rule, we have","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"beginequation\nfracpartial Fpartial u = frac1hF_u + F_u\nendequation","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"The Newton iteration is then","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"beginalign\nfracpartial Fpartial u Delta^i = Fleft(frachatu^i(t+h) - u(t)h hatu^i(t+h) p t+hright) \nhatu^i+1 = hatu^i - Delta^i\nendalign","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"where cdot^i denotes the iteration variable at the i-th iteration. Thus, for the implicit Euler algorithm to work, lambda F_u + F_u has to be non-singular for sufficiently small lambdainmathbbR. In fact, this conclusion holds for all linear multistep methods and Runge-Kutta methods, that is, they all need to solve an iteration matrix of the form lambda F_u + F_u. Curious readers can check this development documentation on how the Newton iteration is set up for all the other cases. Formally, the numerical integrability criterion is","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"beginequation\nforall u u exists lambda  0 det(lambda F_u + F_u) ne 0\nendequation","category":"page"},{"location":"lectures/lecture7/#Structural-Analysis","page":"Numerical and Structural Characterizations for DAEs","title":"Structural Analysis","text":"","category":"section"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"The above criterion is too hard to verify at compile time, since we do not yet know the exact values to solve the DAE. To make it computationally easier to check, we can change the forall to exists, which is","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"beginequation\nexists u u lambda  0 det(lambda F_u + F_u) ne 0\nendequation","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"so that we only need to validate a single instance. To make the criterion even easier to check, we introduce the following definitions.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"definition: Sparse Matrix\nA sparse matrix is a matrix that could contain structural zeros. Structural zeros are entries that are zero by construction denoted by hat0. We call an entry structural nonzero if it is not a structural zero. We also define mathbbF=mathbbRcuphat0.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"definition: Incidence Matrix\nA incidence matrix of the symbolically defined function f mathbbR^n to mathbbR^m with respect to the indexed set of variables x_j  is a sparse matrix MinmathbbF^m times n defined bybeginequation\nM_ij = begincases\n1  textif  x_j text appears in the expression for computing the\ni-th output of f ie  f(x_j)_i \nhat0  textelse\nendcases\nendequationWe use mathfrakI(f x_j) = M to denote the incidence matrix of f with respect to x_j.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"note: Structural Zeros\nFor convenience, we will simply use 0 and mathbbR when structural zeros are obvious in context.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"definition: Structurally Non-singular\nA sparse matrix A is structurally non-singular if and only if there exists a set of real numbers when it replaces all the structural nonzero entries, the new matrix mathfrakN(A) is numerically non-singular.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"example: Structurally Non-singular\nA = beginpmatrix 1  1  1  1 endpmatrix is structurally non-singular but numerically singular because we can replace a nonzero such that we get mathfrakN(A) = beginpmatrix 1  10  1  1 endpmatrix which is numerically non-singular.\nA = beginpmatrix 1  2  3 4  5  6  7  8  9 endpmatrix is structurally non-singular but numerically singular because we can replace nonzeros such that we get mathfrakN(A) = beginpmatrix 10  2  3 4  5  6  7  8  10 endpmatrix which is numerically non-singular.\nbeginpmatrix 1  1  hat0  hat0 endpmatrix is structurally singular because beginpmatrix a  b  0  0 endpmatrix is numerically singular for all real a and b.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"Although structurally non-singular is a strictly weaker condition than numerically non-singular, checking it seems to be more difficult on the surface because we need to come up with an example that is numerically non-singular. However, the following powerful theorem gives us a dramatically simpler way of checking if a sparse matrix is structurally non-singular.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"info: Structurally Non-singularity Theorem\nA square sparse matrix A is structurally non-singular if and only if there exist permutation matrices P and Q such that all the diagonal entries of PA and AQ are structural nonzeros.Proof:Leftarrow: Suppose A is a square sparse matrix such that all diagonal entries of PA and AQ are structural nonzeros, where P and Q are permutation matrices. Let mathfrakN(A) = P^-1I or mathfrakN(A) = IQ^-1 which are numerically non-singular. Thus, A is structurally non-singular.\nRightarrow: Suppose hatAinmathbbR^ntimes n is a square sparse matrix that is structurally non-singular. Let A = mathfrakN (hatA), we have det(A) ne 0. Expanding the definition of the determinant, we have\nbeginequation\ndet(A)=sum_sigma in S_noperatornamesgn(sigma)prod_i = 1^n\na_isigma(i) ne 0\nendequation\nwhere S_n denotes the set of all permutations of the set 1 2  n (the symmetric group of order n). For det(A)ne 0, there must exist one sigmain S_n such that prod_i = 1^n a_isigma (i) ne 0. Note that we also have prod_i = 1^n a_isigma (i) = prod_i = 1^n a_sigma^-1(i) i. Thus, the desired Q is the permutation matrix corresponding to sigma, and the desired P is Q^-1. blacksquare","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"The above condition is equivalent with checking the existence of a perfect matching on the induced bipartite graph of the incidence matrix, and it can be efficiently solved by using the augmenting path algorithm to find the maximum cardinality matching.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"definition: Induced Bipartite Graph\nGiven an incidence matrix AinmathbbR^mtimes n the induced bipartite graph (U V E) is a tuple of a set of source vertices U = 1 2  m, a set of destination vertices Vin 1 2  n, and edges between them E subseteq Utimes V defined bybeginequation\nE = (i j) A_ij ne 0\nendequationSimilarly, the induced bipartite graph of a sparse matrix is the induced bipartite graph of its induced incidence matrix.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"definition: Bipartite Matching\nA matching of a bipartite graph (U V E) is a set M subseteq E where every vertex in U and V can appear at most once in M. A matching M is perfect if M = U = V. We call an edge in a matching matched, otherwise, free. It is often more convenient to interpret matching as the function M U to (V cup emptyset) defined asbeginequation\nm(i) = begincases\n    j  textif  (i j) in E \n    emptyset  textelse\nendcases\nendequation","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"info: Structural Non-singularity and Perfect Matching Equivalence Theorem\nA sparse matrix AinmathbbR^mtimes n is structurally non-singular if and only if its induced bipartite graph has a perfect matching.Proof:Leftarrow: Suppose AinmathbbR^mtimes n is a structurally non-singular sparse matrix, then m=n and there exists a row permutation sigmain S_n such that forall iin1  n A_sigma(i) i ne 0. Note that sigma is a perfect matching.\nRightarrow: Suppose the induced bipartite graph (U V E) of AinmathbbR^mtimes n has a perfect bipartite matching sigma, then U = V = sigma = m = n and sigmain S_n. In particular, forall iin1  n A_sigma(i) i ne 0. Hence, A is structurally non-singular. blacksquare","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"definition: Augmenting Path\nGiven a particular matching, an alternating path is a sequence of adjacent edges that alternate between being matched and free. In particular, an augmenting path is a alternating path that starts and ends with free vertices.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"info: Bipartite Graph Maximum Cardinality Matching Theorem\nA matching M of a bipartite graph has maximum cardinality matching if and only if there is no augmenting path with respect to M.Proof:Rightarrow: We will show this using proof by contrapositive. Suppose a bipartite graph has a matching M and an augmenting path A. Let hatM = M bigtriangleup A = (M setminus A)cup (Asetminus M), then hatM is a matching and hatM = M + 1. Thus, M is not a maximum cardinality matching.\nLeftarrow: We will should this using proof by contrapositive, again. Suppose a bipartite graph (U V E) has a non-maximum cardinality matching B, we want to seek an augmenting path. Let A be a maximum cardinality matching. We claim P = Abigtriangleup B contains at least one augmenting path by the following arguments\nSince all edges of P come from two matchings, by the definition of a matching, each vertex can have at most two edges. Therefore, P contains either paths or cycles, and such segments are alternating between A and B.\nPcap A  Pcap B. Note that Pcap A = ((Asetminus B) cup (Bsetminus A)) cap A = ((Asetminus B)cap A)cup ((Bsetminus A) cap A) = (Asetminus B), and similarly Pcap B = Bsetminus A. Thus, Pcap A = A - A cap B and Pcap B = B - A cap B. By the maximality of A, we know AB. Therefore, Pcap A  Pcap B.\nBy the previous argument, there must be at least one connected component such that it contains more edges in A than B. Since all cycles in P must be even length and alternating, such segment can only be a path, and in particular, an augmenting path with respect to B.\nblacksquare","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"info: Augmenting Path Algorithm\nInput: bipartite graph g = (U V E), a vertex textvsrc in U, and a partial matching.Output: return a boolean indicating the existence of an augmenting path, and if one is present, use the augmenting path to increase the cardinality of the partial matching by exactly one.In ModelingToolkit, there are the 𝑠neighbors(g, i) function that returns a sorted list containing j (i j) in E, and the 𝑑neighbors(g, j) function that returns a sorted list containing i (i j) in E. ModelingToolkit also encodes matching M using the m::Matching structure, let j = m[i], it holds that j::Int if and only if (i j) in M and j::Unassigned if and only if (i j) notin M. It following code comes directly from ModelingToolkit.function construct_augmenting_path!(matching::Matching, g::BipartiteGraph, vsrc, dstfilter,\n        dcolor = falses(ndsts(g)), scolor = nothing)\n    scolor === nothing || (scolor[vsrc] = true)\n\n    # if a `vdst` is unassigned and the edge `vsrc <=> vdst` exists\n    for vdst in 𝑠neighbors(g, vsrc)\n        if dstfilter(vdst) && matching[vdst] === unassigned\n            matching[vdst] = vsrc\n            return true\n        end\n    end\n\n    # for every `vsrc` such that edge `vsrc <=> vdst` exists and `vdst` is uncolored\n    for vdst in 𝑠neighbors(g, vsrc)\n        (dstfilter(vdst) && !dcolor[vdst]) || continue\n        dcolor[vdst] = true\n        if construct_augmenting_path!(matching, g, matching[vdst], dstfilter, dcolor,\n            scolor)\n            matching[vdst] = vsrc\n            return true\n        end\n    end\n    return false\nendNote that the augmenting path algorithm never removes any matched vertices in U.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"info: Augmenting Path Algorithm for Finding a Maximum Cardinality Matching\nInput: bipartite graph g = (U V E).Output: matching M.The following code comes directly from ModelingToolkit. Note that 𝑠vertices(g) returns 1:n where n=U.function maximal_matching(g::BipartiteGraph, srcfilter = vsrc -> true,\n        dstfilter = vdst -> true, ::Type{U} = Unassigned) where {U}\n    matching = Matching{U}(ndsts(g))\n    foreach(Iterators.filter(srcfilter, 𝑠vertices(g))) do vsrc\n        construct_augmenting_path!(matching, g, vsrc, dstfilter)\n    end\n    return matching\nendGiven that the augmenting path algorithm never removes any matched vertices in U, and if no augmenting path starts in vertex iin U, then i will never be matched using the augmenting path algorithm. It is sufficient to run the augmenting path algorithm for all vertices in U by the Bipartite Graph Maximum Cardinality Matching Theorem.","category":"page"},{"location":"lectures/lecture7/#Structural-Integrability-Criterion-for-DAEs","page":"Numerical and Structural Characterizations for DAEs","title":"Structural Integrability Criterion for DAEs","text":"","category":"section"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"To utilize the structural analysis framework, we need weaken the integrability criterion further from","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"beginequation\nexists u u lambda  0 det(lambda F_u + F_u) ne 0\nendequation","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"to the structural integrability criterion","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"beginequation\nmathfrakI(mathfrakI(F u_i) + mathfrakI(F u_i)) text is\nstructurally non-singular\nendequation","category":"page"},{"location":"lectures/lecture7/#Consistency-Solvability-Criterion-for-DAEs","page":"Numerical and Structural Characterizations for DAEs","title":"Consistency Solvability Criterion for DAEs","text":"","category":"section"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"Consider the DAE system","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"beginequation\nF(x y x y t) =\nbeginpmatrix\nf_1(x t) \nf_2(x y t)\nendpmatrix = 0\nendequation","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"where f_1 and f_2 are some arbitrary smooth functions. We have","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"beginequation\nmathfrakI(F x y) = beginpmatrix\n0  0 \n1  1\nendpmatrixquad\nmathfrakI(F x y) = beginpmatrix\n1  0 \n0  0\nendpmatrix\nendequation","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"Thus,","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"beginequation\nmathfrakI(mathfrakI(F u_i) + mathfrakI(F u_i)) =\nbeginpmatrix\n1  0 \n1  1\nendpmatrix\nendequation","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"is structurally non-singular, which means that the DAE system is structurally integrable.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"However, solving for a consistent initial condition u(t_0) and u(t_0) is not as simple as simply solving for F(u(t_0) u(t_0) t_0) = 0. Because given a general DAE in the form of F(u u p t) = 0, all its total time derivatives are also valid constraints, i.e.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"beginalign\nF(u u p t) = 0 \nF(u u u p t) = 0  \nF(u u u u p t) = 0 \n    vdots nonumber\nendalign","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"For the above example, we can differentiate the f_1 equation once and get","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"beginequation\nbeginpmatrix\nf_1(x t) \nf_2(x y t)\nendpmatrix = 0\nendequation","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"Note that differentiating f_1 and f_2 further is not necessary because we will not get additional constraints for the states (u(t) and u(t)) of the DAE system.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"We need a more systematic way of knowing when differentiating F does not add new \"information\" into the system. First, let's develop a characterization on the variables. Let z=z_i be the set of the highest order derivative variables, and let lambda = lambda_i contain the rest of the variables. Note that z and lambda must be disjoint. Therefore, DAEs can then be written as","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"0 = F(z lambda p t) ","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"Differentiating the above equation gives us","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"F_z z + F_lambda lambda + F_t = 0","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"Note that z = z_i contains all the new terms generated by the differentiation, as it contains variables with higher order derivatives than before. Rearranging terms, we get","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"F_z z = -F_lambda lambda - F_t","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"When F_z is non-singular, we can use old terms to explicitly solve for z, so we don't generate genuinely new equations, and this is the numerical consistency solvability criterion. Therefore, we only add new equations to the system if and only if F_z is singular. It's wasteful to differentiate the entire system until the matrix is invertible; we can differentiate a minimal subset of equations to make F_z non-singular.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"Similarly, the structural consistency solvability criterion is then","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"mathfrakI(F z) text is structurally non-singular","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"For the above system, the differentiated system has","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"mathfrakI(F x y) = beginpmatrix\n1  0 \n1  1\nendpmatrix","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"which is structurally non-singular. Thus, the differentiated system satisfies the structural consistency solvability criterion.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"Note that the sparsity pattern of mathfrakI(mathfrakI(F u_i) + mathfrakI(F u_i)) is always a subset of mathfrakI(F z) for arbitrary systems.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"info: Structural Consistency Solvability Theorem\nStructural consistency solvability implies structural integrability. Moreover, if a DAE system is not integrable, then structural consistency solvability cannot be achieved by differentiating any equation any number of times. [2]","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"[2]: Curious readers can read the original Pantelides paper for ideas to prove this.","category":"page"},{"location":"lectures/lecture7/#Pantelides-Algorithm","page":"Numerical and Structural Characterizations for DAEs","title":"Pantelides Algorithm","text":"","category":"section"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"We can use the Pantelides algorithm [Pantelides1988] to efficiently convert a DAE system that has structural integrability to a system with structural consistency solvability, even if it initially lacks this property.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"The gist of the Pantelides algorithm is that, we can try to find an augmenting path for all equation (source) vertices on the sub-graph that only contains highest differentiated variable (destination) vertices, and if there is no augmenting path starting at an equation vertex, then we can differentiate all the equations and variables reached in the augmenting path search until there is an augmenting path starting at the differentiated equation vertex. Note that if we differentiate an equation in the form of f(x y ) we get","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"fracddtf(x y ) = fracpartial fpartial xx + fracpartial fpartial yy + ","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"Thus, the incidence of the differentiated equation is trivial to compute.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"The following code comes directly from ModelingToolkit.","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"function pantelides!(state::TransformationState; finalize = true, maxiters = 8000)\n    @unpack graph, solvable_graph, var_to_diff, eq_to_diff = state.structure\n    neqs = nsrcs(graph)\n    nvars = nv(var_to_diff)\n    vcolor = falses(nvars)\n    ecolor = falses(neqs)\n    var_eq_matching = Matching(nvars)\n    neqs′ = neqs\n    nnonemptyeqs = count(eq -> !isempty(𝑠neighbors(graph, eq)) && eq_to_diff[eq] === nothing,\n        1:neqs′)\n\n    varwhitelist = computed_highest_diff_variables(state.structure)\n\n    if nnonemptyeqs > count(varwhitelist)\n        throw(InvalidSystemException(\"System is structurally singular\"))\n    end\n\n    for k in 1:neqs′\n        eq′ = k\n        eq_to_diff[eq′] === nothing || continue\n        isempty(𝑠neighbors(graph, eq′)) && continue\n        pathfound = false\n        # In practice, `maxiters=8000` should never be reached, otherwise, the\n        # index would be on the order of thousands.\n        for iii in 1:maxiters\n            # run matching on (dx, y) variables\n            #\n            # the derivatives and algebraic variables are zeros in the variable\n            # association list\n            resize!(vcolor, nvars)\n            fill!(vcolor, false)\n            resize!(ecolor, neqs)\n            fill!(ecolor, false)\n            pathfound = construct_augmenting_path!(var_eq_matching, graph, eq′,\n                v -> varwhitelist[v], vcolor, ecolor)\n            pathfound && break # terminating condition\n            if is_only_discrete(state.structure)\n                error(\"The discrete system has high structural index. This is not supported.\")\n            end\n            for var in eachindex(vcolor)\n                vcolor[var] || continue\n                if var_to_diff[var] === nothing\n                    # introduce a new variable\n                    nvars += 1\n                    var_diff = var_derivative!(state, var)\n                    push!(var_eq_matching, unassigned)\n                    push!(varwhitelist, false)\n                    @assert length(var_eq_matching) == var_diff\n                end\n                varwhitelist[var] = false\n                varwhitelist[var_to_diff[var]] = true\n            end\n\n            for eq in eachindex(ecolor)\n                ecolor[eq] || continue\n                # introduce a new equation\n                neqs += 1\n                eq_derivative!(state, eq)\n            end\n\n            for var in eachindex(vcolor)\n                vcolor[var] || continue\n                # the newly introduced `var`s and `eq`s have the inherits\n                # assignment\n                var_eq_matching[var_to_diff[var]] = eq_to_diff[var_eq_matching[var]]\n            end\n            eq′ = eq_to_diff[eq′]\n        end # for _ in 1:maxiters\n        pathfound ||\n            error(\"maxiters=$maxiters reached! File a bug report if your system has a reasonable index (<100), and you are using the default `maxiters`. Try to increase the maxiters by `pantelides(sys::ODESystem; maxiters=1_000_000)` if your system has an incredibly high index and it is truly extremely large.\")\n    end # for k in 1:neqs′\n\n    finalize && for var in 1:ndsts(graph)\n        varwhitelist[var] && continue\n        var_eq_matching[var] = unassigned\n    end\n    return var_eq_matching\nend","category":"page"},{"location":"lectures/lecture7/","page":"Numerical and Structural Characterizations for DAEs","title":"Numerical and Structural Characterizations for DAEs","text":"[Pantelides1988]: Pantelides, Constantinos C. \"The consistent initialization of differential-algebraic systems.\" SIAM Journal on scientific and statistical computing 9.2 (1988): 213-231.","category":"page"},{"location":"lectures/lecture4/#Numerical-Methods-for-Stiff-ODEs-and-Differential-Algebraic-Equations","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"","category":"section"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Before jumping into this lecture, I want to start by mentioning that DAEs are not ODEs. There are substantial differences that must be addressed. The abstract is rather clear:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"This paper outlines a number of difficulties which can arise when numerical methods are used to solve systems of differential/algebraic equations of the form. Problems which can be written in this general form include standard ODE systems as well as problems which are substantially different from standard ODE’S. Some of the differential/algebraic systems can be solved using numerical methods which are commonly used for solving stiff systems of ordinary differential equations. Other problems can be solved using codes based on the stiff methods, but only after extensive modifications to the error estimates and other strategies in the code. A further class of problems cannot be solved at all with such codes, because changing the stepsize causes large errors in the solution. We describe in detail the causes of these difficulties and indicate solutions in some cases.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"However, a good portion of those issues can be mitigated by symbolic tooling which will be covered in later lectures. Other aspects will be highlighted on an as-needed basis. If you want more details, refer to that classic article.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"That said, we will be using stiff ODEs to introduce the numerical methods for DAEs since, while they are distinctly not the same, many of the methods for DAEs are derived as extensions to those for stiff ODEs. Thus we will start by introducing the methods for stiff ODEs, see how they can be extended to DAEs, and point out some of the caveats. Fully handling all of these caveats is a deep research topic that is beyond the scope of this course.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"A good resource on this topic is Hairer's Solving Ordinary Differential Equations II","category":"page"},{"location":"lectures/lecture4/#A-Deeper-Look-into-the-Stability-of-Numerical-Methods","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"A Deeper Look into the Stability of Numerical Methods","text":"","category":"section"},{"location":"lectures/lecture4/#Stability-of-a-Method","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Stability of a Method","text":"","category":"section"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Simply having an order on the truncation error does not imply convergence of the method. The disconnect is that the errors at a given time point may not dissipate. What also needs to be checked is the asymptotic behavior of a disturbance. To see this, one can utilize the linear test problem:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"u = alpha u","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"and ask the question, does the discrete dynamical system defined by the discretized ODE end up going to zero? You would hope that the discretized dynamical system and the continuous dynamical system have the same properties in this simple case, and this is known as linear stability analysis of the method.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"As an example, take a look at the Euler method. Recall that the Euler method was given by:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"u_n+1 = u_n + Delta t f(u_npt)","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"When we plug in the linear test equation, we get that","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"u_n+1 = u_n + Delta t alpha u_n","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"If we let z = Delta t alpha, then we get the following:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"u_n+1 = u_n + z u_n = (1+z)u_n","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"which is stable when z is in the shifted unit circle. This means that, as a necessary condition, the step size Delta t needs to be small enough that z satisfies this condition, placing a stepsize limit on the method.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"(Image: )","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"If Delta t is ever too large, it will cause the equation to overshoot zero, which then causes oscillations that spiral out to infinity.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"(Image: )","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"(Image: )","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Thus the stability condition places a hard constraint on the allowed Delta t which will result in a realistic simulation.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"For reference, the stability regions of the 2nd and 4th order Runge-Kutta methods that we discussed are as follows:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"(Image: )","category":"page"},{"location":"lectures/lecture4/#Interpretation-of-the-Linear-Stability-Condition","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Interpretation of the Linear Stability Condition","text":"","category":"section"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"To interpret the linear stability condition, recall that the linearization of a system interprets the dynamics as locally being due to the Jacobian of the system. Thus","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"u = f(upt)","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"is locally equivalent to","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"u = fracdfduu","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"You can understand the local behavior through diagonalizing this matrix. Therefore, the scalar for the linear stability analysis is performing an analysis on the eigenvalues of the Jacobian. The method will be stable if the largest eigenvalues of df/du are all within the stability limit. This means that stability effects are different throughout the solution of a nonlinear equation and are generally understood locally (though different more comprehensive stability conditions exist!).","category":"page"},{"location":"lectures/lecture4/#Implicit-Methods","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Implicit Methods","text":"","category":"section"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"If instead of the Euler method we defined f to be evaluated at the future point, we would receive a method like:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"u_n+1 = u_n + Delta t f(u_n+1pt+Delta t)","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"in which case, for the stability calculation we would have that","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"u_n+1 = u_n + Delta t alpha u_n","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"or","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"(1-z) u_n+1 = u_n","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"which means that","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"u_n+1 = frac11-z u_n","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"which is stable for all Re(z)  0 a property which is known as A-stability. It is also stable as z rightarrow infty, a property known as L-stability. This means that for equations with very ill-conditioned Jacobians, this method is still able to be use reasonably large stepsizes and can thus be efficient.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"(Image: )","category":"page"},{"location":"lectures/lecture4/#Understanding-Stiffness-and-the-Relationship-to-DAEs","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Understanding Stiffness and the Relationship to DAEs","text":"","category":"section"},{"location":"lectures/lecture4/#Stiffness-and-Timescale-Separation","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Stiffness and Timescale Separation","text":"","category":"section"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"From this we see that there is a maximal stepsize whenever the eigenvalues of the Jacobian are sufficiently large. It turns out that's not an issue if the phenomena we see are fast, since then the total integration time tends to be small. However, if we have some equations with both fast modes and slow modes, like the Robertson equation (shown below), then it is very difficult because in order to resolve the slow dynamics over a long timespan, one needs to ensure that the fast dynamics do not diverge. This is a property known as stiffness. Stiffness can thus be approximated in some sense by the condition number of the Jacobian. The condition number of a matrix is its maximal eigenvalue divided by its minimal eigenvalue and gives a rough measure of the local timescale separations. If this value is large and one wants to resolve the slow dynamics, then explicit integrators, like the explicit Runge-Kutta methods described before, have issues with stability. In this case implicit integrators (or other forms of stabilized stepping) are required in order to efficiently reach the end time step.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"(Image: )","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"In this illustrative plot, the grey is \"the true solution\". The representative solution has a fast process and a slow process, the slow precess is an r-shaped curve. The fast process is a quasi-steady state process, i.e. it very quickly brings any purturbation from the r-shaped curve back to the main curve (and example of this is the y_2 term in the Robertson equation below). The black line up top is a numerical solution with an explicit method on such an equation. It's show how for a \"reasonable\" sized h that the large derivatives of the fast process back to the stable manifold cause explicit methods to overshoot the manifold, thus requiring the h to be small enough to \"not overshoot too much\", with this overshooting resulting in a jagged behavior.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"This overshooting is exactly the behavior that causes a step size limitation, thus forcing h to be sufficiently small when there is such time-scale separation, and thus simulations of the long-scale phonomena require time steps on the scale of the short-scale phonomena. If those two time-scales are orders of magnitude different, then accurately handling this type of equations thus requires orders of magnitude more time steps, leading to the inefficiency of explicit methods.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Implicit methods on the other hand effectively smooth out the behavior of the derivative in the future to be able to account for how the process had gotten there. For example, the red dotted line shows the linear extrapolation of the derivative from t_n to t_n+1. But at the proposed y_n+1 of the Euler method, the derivative would be negative, and thus implicit Euler we detect a mismatch between the proposed value of y_n+1 and the required derivative to get to y_n+1. The solution of the implicit equation is thus an iterative process to remove this mismatch, which effectively smooths out the derivative issues and forces the solution onto the slow manifold.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"note: Note\nThe true solution is not the jagged black line. To be clear, the stiff solution is not generally jagged, this is not the reason for stiffness. The clean r-shaped curve is the true stiff solution. The jagged line is what is seen from an explicit numerical solver on such an equation, but the jaggedness is a numerical artifact!","category":"page"},{"location":"lectures/lecture4/#Stiffness-in-Biochemistry:-Robertson-Equations","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Stiffness in Biochemistry: Robertson Equations","text":"","category":"section"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Biochemical equations commonly display large separation of timescales which lead to a stiffness phenomena that will be investigated later. The classic \"hard\" equations for ODE integration thus tend to come from biology (not physics!) due to this property. One of the standard models is the Robertson model, which can be described as:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"using DifferentialEquations, Plots\nfunction rober(du,u,p,t)\n  y₁,y₂,y₃ = u\n  k₁,k₂,k₃ = p\n  du[1] = -k₁*y₁+k₃*y₂*y₃\n  du[2] =  k₁*y₁-k₂*y₂^2-k₃*y₂*y₃\n  du[3] =  k₂*y₂^2\nend\nprob = ODEProblem(rober,[1.0,0.0,0.0],(0.0,1e5),(0.04,3e7,1e4))\nsol = solve(prob,Rosenbrock23())\nplot(sol)","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"plot(sol, xscale=:log10, tspan=(1e-6, 1e5), layout=(3,1))","category":"page"},{"location":"lectures/lecture4/#Stiffness-in-Chemical-Physics:-Pollution-Models","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Stiffness in Chemical Physics: Pollution Models","text":"","category":"section"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Chemical reactions in physical models are also described as differential equation systems. The following is a classic model of dynamics between different species of pollutants:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"k1=.35e0\nk2=.266e2\nk3=.123e5\nk4=.86e-3\nk5=.82e-3\nk6=.15e5\nk7=.13e-3\nk8=.24e5\nk9=.165e5\nk10=.9e4\nk11=.22e-1\nk12=.12e5\nk13=.188e1\nk14=.163e5\nk15=.48e7\nk16=.35e-3\nk17=.175e-1\nk18=.1e9\nk19=.444e12\nk20=.124e4\nk21=.21e1\nk22=.578e1\nk23=.474e-1\nk24=.178e4\nk25=.312e1\np = (k1,k2,k3,k4,k5,k6,k7,k8,k9,k10,k11,k12,k13,k14,k15,k16,k17,k18,k19,k20,k21,k22,k23,k24,k25)\nfunction f(dy,y,p,t)\n k1,k2,k3,k4,k5,k6,k7,k8,k9,k10,k11,k12,k13,k14,k15,k16,k17,k18,k19,k20,k21,k22,k23,k24,k25 = p\n r1  = k1 *y[1]\n r2  = k2 *y[2]*y[4]\n r3  = k3 *y[5]*y[2]\n r4  = k4 *y[7]\n r5  = k5 *y[7]\n r6  = k6 *y[7]*y[6]\n r7  = k7 *y[9]\n r8  = k8 *y[9]*y[6]\n r9  = k9 *y[11]*y[2]\n r10 = k10*y[11]*y[1]\n r11 = k11*y[13]\n r12 = k12*y[10]*y[2]\n r13 = k13*y[14]\n r14 = k14*y[1]*y[6]\n r15 = k15*y[3]\n r16 = k16*y[4]\n r17 = k17*y[4]\n r18 = k18*y[16]\n r19 = k19*y[16]\n r20 = k20*y[17]*y[6]\n r21 = k21*y[19]\n r22 = k22*y[19]\n r23 = k23*y[1]*y[4]\n r24 = k24*y[19]*y[1]\n r25 = k25*y[20]\n\n dy[1]  = -r1-r10-r14-r23-r24+\n          r2+r3+r9+r11+r12+r22+r25\n dy[2]  = -r2-r3-r9-r12+r1+r21\n dy[3]  = -r15+r1+r17+r19+r22\n dy[4]  = -r2-r16-r17-r23+r15\n dy[5]  = -r3+r4+r4+r6+r7+r13+r20\n dy[6]  = -r6-r8-r14-r20+r3+r18+r18\n dy[7]  = -r4-r5-r6+r13\n dy[8]  = r4+r5+r6+r7\n dy[9]  = -r7-r8\n dy[10] = -r12+r7+r9\n dy[11] = -r9-r10+r8+r11\n dy[12] = r9\n dy[13] = -r11+r10\n dy[14] = -r13+r12\n dy[15] = r14\n dy[16] = -r18-r19+r16\n dy[17] = -r20\n dy[18] = r20\n dy[19] = -r21-r22-r24+r23+r25\n dy[20] = -r25+r24\nend","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"u0 = zeros(20)\nu0[2]  = 0.2\nu0[4]  = 0.04\nu0[7]  = 0.1\nu0[8]  = 0.3\nu0[9]  = 0.01\nu0[17] = 0.007\nprob = ODEProblem(f,u0,(0.0,60.0),p)\nsol = solve(prob,Rodas5P())","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"plot(sol)","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"plot(sol, xscale=:log10, tspan=(1e-6, 60), layout=(3,1))","category":"page"},{"location":"lectures/lecture4/#Van-Der-Pol-Equations:-Singular-Perturbation-Problems-and-DAEs","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Van Der Pol Equations: Singular Perturbation Problems and DAEs","text":"","category":"section"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Next up is the Van Der Pol Equations which is a canonical example of a singular perturbation problem:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"function van(du,u,p,t)\n    y,x = u\n    μ = p\n    du[1] = μ*((1-x^2)*y - x)\n    du[2] = 1*y\nend\n\nprob = ODEProblem(van,[1.0;1.0],(0.0,6.3),1e6)\nsol = solve(prob, Rodas5P())\nplot(sol)","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"or zooming in:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"plot(sol, ylim=[-4;4])","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"A singular perturbation problem is an ODE given by the form:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"x = f(xyt)\nepsilon y = g(xyt)","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"where epsilon is sufficiently small. Notice that the Van Der Pol equations,","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"x = y\ny = mu ((1-x^2)y -x)","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"can be rewritten as:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"x = y\nepsilon y = (1-x^2)y -x","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"by making epsilon = frac1mu. Thus when mu is big, epsilon is small. In this form it's clear that epsilon is the time-scale difference between the changes in x and the changes in y. When this difference is large, i.e. mu is big, then our previous discussion suggests that this should change the stiffness. Let's see this in practice:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"# small mu\nprob = ODEProblem(van,[1.0;1.0],(0.0,6.3),500)\n# explicit RK solution\nsol = solve(prob,Tsit5())\nplot(sol, ylim=[-4;4])","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"# big mu\nprob = ODEProblem(van,[1.0;1.0],(0.0,6.3),1e6)\n# explicit RK solution\nsol = solve(prob,Tsit5())","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"We can see directly that the time scale separation forces the explicit Runge-Kutta method to exit with MaxIters, i.e. it hit its maximum iterations. The reason why it hit maximum iterations is because the time scale separation increased, and therefore the dt limit for stability decreased, and therefore it started requiring too many steps (default 1e5) in order to solve the equation.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Notably, this shows that stiffness is a parameter-dependent phonomena","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"If you change the parameter values, you can change whether an equation is stiff or non-stiff.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"However... what happens in the limit as mu rightarrow infty? In some sense, this is \"the limit as stiffness goes to infinity\". In that limit, epsilon rightarrow 0, and therefore we arrive at the equation:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"x = y\n0 = (1-x^2)y - x","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"This equation is a Differential-Algebraic Equation (DAE), where x = y is a differential equation and 0 = (1-x^2)y -x is a nonlinear algebraic equation. In this limit, the fast behavior is so fast that it's instant. Thinking back to our picture of stiffness, it means any perturbation from the slow manifold would instantly fall back onto the slow manifold. For these types of problem then, it's clear that handling the equation implicitly is potentially required for two reasons. For one, it's infinitely stiff, and the \"more stiff\" an equation is, the more one requires using implicit methods","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"note: Note\nThere are explicit methods for stiff equations, such as Runge-Kutta Chebyshev methods and exponential integrators. For the purposes of this discussion we simplify and say solving stiff equations requires implicit methods, but this caveat should be noted as there are notable exceptions to this rule. However, the most generally used methods on stiff equations are undoubtably implicit methods.","category":"page"},{"location":"lectures/lecture4/#Representations-of-DAEs-as-Mass-Matrix-ODEs","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Representations of DAEs as Mass Matrix ODEs","text":"","category":"section"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Take Van Der Pol's Equation","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"x = y\n0 = (1-x^2)y - x","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"In order to more succinctly represent this to an ODE solver, notice that if we take the mass matrix [1 0;0 0], then the form:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Mu = f(ut)","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"is a representation of the Van Der Pol equation. Notably, the \"standard\" ODE from before is of the same form, simply with M = I. If the mass matrix M is non-singular, then the equation is a mass matrix ODE which does not represent a DAE. However, if M is singular, then the equation is implicitly specifying an algebraic equation, like as in the Van Der Pol equation, and its in this case that a mass matrix ODE is representing a DAE.","category":"page"},{"location":"lectures/lecture4/#The-Three-Canonical-Representations-of-DAEs","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"The Three Canonical Representations of DAEs","text":"","category":"section"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"This shows the three canonical ways that DAEs can be represented. The first is the semi-explicit ODE in the split function form:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"x = f(xyt)\n0 = g(xyt)","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"where x are the differential variables (generally a vector) and y is a vector of algebraic variables. The second form is the mass matrix ODE form:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Mu = f(ut)","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"where the mass matrix M is singular. In this form, the algebraic equations can be sometimes easily understood via a constant zero row in the mass matrix M, with the differential variables being the values for which the derivative appears in the equation and the other variables being the algebraic variables. Note that this description is purposefully vague as we will see that not all equations can be cleanly separated like this in the more general forms.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Finally, the most general form is simply the implicit ODE form:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"0 = f(uut)","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"This form is slightly more general since one can consider the mass matrix form as requiring that f(uut) has a linear partial derivative with respect to the u term, with -M being that derivative. Thus it allows for example u_1^2.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Though note that this the mass matrix and the implicit ODE definitions are not a substantial difference as via a variable definition u_i = u_1^3 and other tricks you can rewrite a term with nonlinear derivatives into one with linear derivative relationships, and thus arrive at a mass matrix form (with a larger set of equations). The semi-explicit ODE however is distinctly a subset of the possible DAEs, which will be explored in the symbolic sections in more detail.","category":"page"},{"location":"lectures/lecture4/#The-Steps-of-an-Implicit-Solver","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"The Steps of an Implicit Solver","text":"","category":"section"},{"location":"lectures/lecture4/#Newton's-Method-and-Jacobians","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Newton's Method and Jacobians","text":"","category":"section"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Recall that the implicit Euler method is the following:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"u_n+1 = u_n + Delta t f(u_n+1pt + Delta t)","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"If we wanted to use this method, we would need to find out how to get the value u_n+1 when only knowing the value u_n. To do so, we can move everything to one side:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"u_n+1 - Delta t f(u_n+1pt + Delta t) - u_n = 0","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"and now we have a problem","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"g(u_n+1) = 0","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"This is the classic rootfinding problem g(x)=0, find x. The way that we solve the rootfinding problem is, once again, by replacing this problem about a continuous function g with a discrete dynamical system whose steady state is the solution to the g(x)=0. There are many methods for this, but some choices of the rootfinding method effect the stability of the ODE solver itself since we need to make sure that the steady state solution is a stable steady state of the iteration process, otherwise the rootfinding method will diverge (will be explored in the homework).","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Thus for example, fixed point iteration is not appropriate for stiff differential equations. Methods which are used in the stiff case are either Anderson Acceleration or Newton's method. Newton's is by far the most common (and generally performs the best), so we can go down this route.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Let's use the syntax g(x)=0. Here we need some starting value x_0 as our first guess for u_n+1. The easiest guess is u_n, though additional information about the equation can be used to compute a better starting value (known as a step predictor). Once we have a starting value, we run the iteration:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"x_k+1 = x_k - J(x_k)^-1g(x_k)","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"where J(x_k) is the Jacobian of g at the point x_k. However, the mathematical formulation is never the syntax that you should use for the actual application! Instead, numerically this is two stages:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Solve Ja=g(x_k) for a\nUpdate x_k+1 = x_k - a","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"By doing this, we can turn the matrix inversion into a problem of a linear solve and then an update. The reason this is done is manyfold, but one major reason is because the inverse of a sparse matrix can be dense, and this Jacobian is in many cases (PDEs) a large and dense matrix.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Now let's break this down step by step.","category":"page"},{"location":"lectures/lecture4/#Some-Quick-Notes","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Some Quick Notes","text":"","category":"section"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"The Jacobian of g can also be written as J = I - gamma fracdfdu for the ODE u = f(upt), where gamma = Delta t for the implicit Euler method. This general form holds for all other (SDIRK) implicit methods, changing the value of gamma. Additionally, the class of Rosenbrock methods solves a linear system with exactly the same J, meaning that essentially all implicit and semi-implicit ODE solvers have to do the same Newton iteration process on the same structure. This is the portion of the code that is generally the bottleneck.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Additionally, if one is solving a mass matrix ODE: Mu = f(upt), exactly the same treatment can be had with J = M - gamma fracdfdu. This works even if M is singular, a case known as a differential-algebraic equation or a DAE. A DAE for example can be an ODE with constraint equations, and these structures can be represented as an ODE where these constraints lead to a singularity in the mass matrix (a row of all zeros is a term that is only the right hand side equals zero!).","category":"page"},{"location":"lectures/lecture4/#Generation-of-the-Jacobian","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Generation of the Jacobian","text":"","category":"section"},{"location":"lectures/lecture4/#Dense-Finite-Differences-and-Forward-Mode-AD","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Dense Finite Differences and Forward-Mode AD","text":"","category":"section"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Recall that the Jacobian is the matrix of fracdf_idx_j for f a vector-valued function. The simplest way to generate the Jacobian is through finite differences. For each h_j = h e_j for e_j the basis vector of the jth axis and some sufficiently small h, then we can compute column j of the Jacobian by:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"fracf(x+h_j)-f(x)h","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Thus m+1 applications of f are required to compute the full Jacobian.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"This can be improved by using forward-mode automatic differentiation. Recall that we can formulate a multidimensional duel number of the form","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"d = x + v_1 epsilon_1 + ldots + v_m epsilon_m","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"We can then seed the vectors v_j = h_j so that the differentiation directions are along the basis vectors, and then the output dual is the result:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"f(d) = f(x) + J_1 epsilon_1 + ldots + J_m epsilon_m","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"where J_j is the jth column of the Jacobian. And thus with one calculation of the primal (f(x)) we have calculated the entire Jacobian.","category":"page"},{"location":"lectures/lecture4/#Sparse-Differentiation-and-Matrix-Coloring","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Sparse Differentiation and Matrix Coloring","text":"","category":"section"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"However, when the Jacobian is sparse we can compute it much faster. We can understand this by looking at the following system:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"f(x)=leftbeginarrayc\nx_1+x_3\nx_2x_3\nx_1\nendarrayright","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Notice that in 3 differencing steps we can calculate:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"f(x+epsilon e_1)=leftbeginarrayc\nx_1+x_3+epsilon\nx_2x_3\nx_1+epsilon\nendarrayright","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"f(x+epsilon e_2)=leftbeginarrayc\nx_1+x_3\nx_2x_3+epsilon x_3\nx_1\nendarrayright","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"f(x+epsilon e_3)=leftbeginarrayc\nx_1+x_3+epsilon\nx_2x_3+epsilon x_2\nx_1\nendarrayright","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"and thus:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"fracf(x+epsilon e_1)-f(x)epsilon=leftbeginarrayc\n1\n0\n1\nendarrayright","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"fracf(x+epsilon e_2)-f(x)epsilon=leftbeginarrayc\n0\nx_3\n0\nendarrayright","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"fracf(x+epsilon e_3)-f(x)epsilon=leftbeginarrayc\n1\nx_2\n0\nendarrayright","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"But notice that the calculation of e_1 and e_2 do not interact. If we had done:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"fracf(x+epsilon e_1+epsilon e_2)-f(x)epsilon=leftbeginarrayc\n1\nx_3\n1\nendarrayright","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"we would still get the correct value for every row because the epsilon terms do not collide (a situation known as perturbation confusion). If we knew the sparsity pattern of the Jacobian included a 0 at (2,1), (1,2), and (3,2), then we would know that the vectors would have to be 1 0 1 and 0 x_3 0, meaning that columns 1 and 2 can be computed simultaneously and decompressed. This is the key to sparse differentiation.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"(Image: )","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"With forward-mode automatic differentiation, recall that we calculate multiple dimensions simultaneously by using a multidimensional dual number seeded by the vectors of the differentiation directions, that is:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"d = x + v_1 epsilon_1 + ldots + v_m epsilon_m","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Instead of using the primitive differentiation directions e_j, we can instead replace this with the mixed values. For example, the Jacobian of the example function can be computed in one function call to f with the dual number input:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"d = x + (e_1 + e_2) epsilon_1 + e_3 epsilon_2","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"and performing the decompression via the sparsity pattern. Thus the sparsity pattern gives a direct way to optimize the construction of the Jacobian.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"This idea of independent directions can be formalized as a matrix coloring. Take S_ij the sparsity pattern of some Jacobian matrix J_ij. Define a graph on the nodes 1 through m where there is an edge between i and j if there is a row where i and j are non-zero. This graph is the column connectivity graph of the Jacobian. What we wish to do is find the smallest set of differentiation directions such that differentiating in the direction of e_i does not collide with differentiation in the direction of e_j. The connectivity graph is setup so that way this cannot be done if the two nodes are adjacent. If we let the subset of nodes differentiated together be a color, the question is, what is the smallest number of colors s.t. no adjacent nodes are the same color. This is the classic distance-1 coloring problem from graph theory. It is well-known that the problem of finding the chromatic number, the minimal number of colors for a graph, is generally NP-complete. However, there are heuristic methods for performing a distance-1 coloring quite quickly. For example, a greedy algorithm is as follows:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Pick a node at random to be color 1.\nMake all nodes adjacent to that be the lowest color that they can be (in this step that will be 2).\nNow look at all nodes adjacent to that. Make all nodes be the lowest color that they can be (either 1 or 3).\nRepeat by looking at the next set of adjacent nodes and color as conservatively as possible.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"This can be visualized as follows:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"(Image: )","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"The result will color the entire connected component. While not giving an optimal result, it will still give a result that is a sufficient reduction in the number of differentiation directions (without solving an NP-complete problem) and thus can lead to a large computational saving.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"At the end, let c_i be the vector of 1's and 0's, where it's 1 for every node that is color i and 0 otherwise. Sparse automatic differentiation of the Jacobian is then computed with:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"d = x + c_1 epsilon_1 + ldots + c_k epsilon_k","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"that is, the full Jacobian is computed with one dual number which consists of the primal calculation along with k dual dimensions, where k is the computed chromatic number of the connectivity graph on the Jacobian. Once this calculation is complete, the colored columns can be decompressed into the full Jacobian using the sparsity information, generating the original quantity that we wanted to compute.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"For more information on the graph coloring aspects, find the paper titled \"What Color Is Your Jacobian? Graph Coloring for Computing Derivatives\" by Gebremedhin.","category":"page"},{"location":"lectures/lecture4/#Note-on-Sparse-Reverse-Mode-AD","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Note on Sparse Reverse-Mode AD","text":"","category":"section"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Reverse-mode automatic differentiation can be though of as a method for computing one row of a Jacobian per seed, as opposed to one column per seed given by forward-mode AD. Thus sparse reverse-mode automatic differentiation can be done by looking at the connectivity graph of the column and using the resulting color vectors to seed the reverse accumulation process.","category":"page"},{"location":"lectures/lecture4/#Linear-Solving","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Linear Solving","text":"","category":"section"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"After the Jacobian has been computed, we need to solve a linear equation Ja=b. While mathematically you can solve this by computing the inverse J^-1, this is not a good way to perform the calculation because even if J is sparse, then J^-1 is in general dense and thus may not fit into memory (remember, this is N^2 as many terms, where N is the size of the ordinary differential equation that is being solved, so if it's a large equation it is very feasible and common that the ODE is representable but its full Jacobian is not able to fit into RAM). Note that some may say that this is done for numerical stability reasons: that is incorrect. In fact, under reasonable assumptions for how the inverse is computed, it will be as numerically stable as other techniques we will mention.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Thus instead of generating the inverse, we can instead perform a matrix factorization. A matrix factorization is a transformation of the matrix into a form that is more amenable to certain analyses. For our purposes, a general Jacobian within a Newton iteration can be transformed via the LU-factorization or (LU-decomposition), i.e.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"J = LU","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"where L is lower triangular and U is upper triangular. If we write the linear equation in this form:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"LUa = b","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"then we see that we can solve it by first solving L(Ua) = b. Since L is lower triangular, this is done by the backsubstitution algorithm. That is, in a lower triangular form, we can solve for the first value since we have:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"L_11 a_1 = b_1","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"and thus by dividing we solve. For the next term, we have that","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"L_21 a_1 + L_22 a_2 = b_2","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"and thus we plug in the solution to a_1 and solve to get a_2. The lower triangular form allows this to continue. This occurs in 1+2+3+...+n operations, and is thus O(n^2). Next, we solve Ua = b, which once again is done by a backsubstitution algorithm but in the reverse direction. Together those two operations are O(n^2) and complete the inversion of LU.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"So is this an O(n^2) algorithm for computing the solution of a linear system? No, because the computation of LU itself is an O(n^3) calculation, and thus the true complexity of solving a linear system is still O(n^3). However, if we have already factorized J, then we can repeatedly use the same LU factors to solve additional linear problems Jv = u with different vectors. We can exploit this to accelerate the Newton method. Instead of doing the calculation:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"x_k+1 = x_k - J(x_k)^-1g(x_k)","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"we can instead do:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"x_k+1 = x_k - J(x_0)^-1g(x_k)","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"so that all of the Jacobians are the same. This means that a single O(n^3) factorization can be done, with multiple O(n^2) calculations using the same factorization. This is known as a Quasi-Newton method. While this makes the Newton method no longer quadratically convergent, it minimizes the large constant factor on the computational cost while retaining the same dynamical properties, i.e. the same steady state and thus the same overall solution. This makes sense for sufficiently large n, but requires sufficiently large n because the loss of quadratic convergence means that it will take more steps to converge than before, and thus more O(n^2) backsolves are required, meaning that the difference between factorizations and backsolves needs to be large enough in order to offset the cost of extra steps.","category":"page"},{"location":"lectures/lecture4/#Note-on-Sparse-Factorization","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Note on Sparse Factorization","text":"","category":"section"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Note that LU-factorization, and other factorizations, have generalizations to sparse matrices where a symbolic factorization is utilized to compute a sparse storage of the values which then allow for a fast backsubstitution. More details are outside the scope of this course, but note that Julia and MATLAB will both use the library SuiteSparse in the background when lu is called on a sparse matrix.","category":"page"},{"location":"lectures/lecture4/#Jacobian-Free-Newton-Krylov-(JFNK)","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Jacobian-Free Newton Krylov (JFNK)","text":"","category":"section"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"An alternative method for solving the linear system is the Jacobian-Free Newton Krylov technique. This technique is broken into two pieces: the jvp calculation and the Krylov subspace iterative linear solver.","category":"page"},{"location":"lectures/lecture4/#Jacobian-Vector-Products-as-Directional-Derivatives","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Jacobian-Vector Products as Directional Derivatives","text":"","category":"section"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"We don't actually need to compute J itself, since all that we actually need is the v = J*w. Is it possible to compute the Jacobian-Vector Product, or the jvp, without producing the Jacobian?","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"To see how this is done let's take a look at what is actually calculated. Written out in the standard basis, we have that:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"w_i = sum_j^m J_ij v_j","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Now write out what J means and we see that:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"w_i = sum_j^m fracdf_idx_j v_j = nabla f_i(x) cdot v","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"that is, the ith component of Jv is the directional derivative of f_i in the direction v. This means that in general, the jvp Jv is actually just the directional derivative in the direction of v, that is:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Jv = nabla f cdot v","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"and therefore it has another mathematical representation, that is:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Jv = lim_epsilon rightarrow 0 fracf(x+v epsilon) - f(x)epsilon","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"From this alternative form it is clear that we can always compute a jvp with a single computation. Using finite differences, a simple approximation is the following:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Jv approx fracf(x+v epsilon) - f(x)epsilon","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"for non-zero epsilon. Similarly, recall that in forward-mode automatic differentiation we can choose directions by seeding the dual part. Therefore, using the dual number with one partial component:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"d = x + v epsilon","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"we get that","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"f(d) = f(x) + Jv epsilon","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"and thus a single application with a single partial gives the jvp.","category":"page"},{"location":"lectures/lecture4/#Note-on-Reverse-Mode-Automatic-Differentiation","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Note on Reverse-Mode Automatic Differentiation","text":"","category":"section"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"As noted earlier, reverse-mode automatic differentiation has its primitives compute rows of the Jacobian in the seeded direction. This means that the seeded reverse-mode call with the vector v computes v^T J, that is the vector (transpose) Jacobian transpose, or vjp for short. When discussing parameter estimation and adjoints, this shorthand will be introduced as a way for using a traditionally machine learning tool to accelerate traditionally scientific computing tasks.","category":"page"},{"location":"lectures/lecture4/#Krylov-Subspace-Methods-For-Solving-Linear-Systems","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Krylov Subspace Methods For Solving Linear Systems","text":"","category":"section"},{"location":"lectures/lecture4/#Basic-Iterative-Solver-Methods","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Basic Iterative Solver Methods","text":"","category":"section"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Now that we have direct access to quick calculations of Jv, how would we use this to solve the linear system Jw = v quickly? This is done through iterative linear solvers. These methods replace the process of solving for a factorization with, you may have guessed it, a discrete dynamical system whose solution is w. To do this, what we want is some iterative process so that","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Jw - b = 0","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"So now let's split J = A - B, then if we are iterating the vectors w_k such that w_k rightarrow w, then if we plug this into the previous (residual) equation we get","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"A w_k+1 = Bw_k + b","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"since when we plug in w we get zero (the sequence must be Cauchy so the difference w_k+1 - w_k rightarrow 0). Thus if we can split our matrix J into a component A which is easy to invert and a part B that is just everything else, then we would have a bunch of easy linear systems to solve. There are many different choices that we can do. If we let J = L + D + U, where L is the lower portion of J, D is the diagonal, and U is the upper portion, then the following are well-known methods:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Richardson: A = omega I for some omega\nJacobi: A = D\nDamped Jacobi: A = omega D\nGauss-Seidel: A = D-L\nSuccessive Over Relaxation: A = omega D - L\nSymmetric Successive Over Relaxation: A = frac1omega (2 - omega)(D-omega L)D^-1(D-omega U)","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"These decompositions are chosen since a diagonal matrix is easy to invert (it's just the inversion of the scalars of the diagonal) and it's easy to solve an upper or lower triangular linear system (once again, it's backsubstitution).","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"Since these methods give a a linear dynamical system, we know that there is a unique steady state solution, which happens to be Aw - Bw = Jw = b. Thus we will converge to it as long as the steady state is stable. To see if it's stable, take the update equation","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"w_k+1 = A^-1(Bw_k + b)","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"and check the eigenvalues of the system: if they are within the unit circle then you have stability. Notice that this can always occur by bringing the eigenvalues of A^-1 closer to zero, which can be done by multiplying A by a significantly large value, hence the omega quantities. While that always works, this essentially amounts to decreasing the stepsize of the iterative process and thus requiring more steps, thus making it take more computations. Thus the game is to pick the largest stepsize (omega) for which the steady state is stable. We will leave that as outside the topic of this course.","category":"page"},{"location":"lectures/lecture4/#Krylov-Subspace-Methods","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Krylov Subspace Methods","text":"","category":"section"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"While the classical iterative solver methods give the background for understanding an alternative to direct inversion or factorization of a matrix, the problem with that approach is that it requires the ability to split the matrix J, which we would like to avoid computing. Instead, we would like to develop an iterative solver technique which instead just uses the solution to Jv. Indeed there are such methods, and these are the Krylov subspace methods. A Krylov subspace is the space spanned by:","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"mathcalK_k = textspan vJvJ^2 v ldots J^k v","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"There are a few nice properties about Krylov subspaces that can be exploited. For one, it is known that there is a finite maximum dimension of the Krylov subspace, that is there is a value r such that J^r+1 v in mathcalK_r, which means that the complete Krylov subspace can be computed in finitely many jvp, since J^2 v is just the jvp where the vector is the jvp. Indeed, one can show that J^i v is linearly independent for each i, and thus that maximal value is m, the dimension of the Jacobian. Therefore in m jvps the solution is guaranteed to live in the Krylov subspace, giving a maximal computational cost and a proof of convergence if the vector in there is the \"optimal in the space\".","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"The most common method in the Krylov subspace family of methods is the GMRES method. Essentially, in step i one computes mathcalK_i, and finds the x that is the closest to the Krylov subspace, i.e. finds the x in mathcalK_i such that Vert Jx-v Vert is minimized. At each step, it adds the new vector to the Krylov subspace after orthogonalizing it against the other vectors via Arnoldi iterations, leading to an orthogonal basis of mathcalK_i which makes it easy to express x.","category":"page"},{"location":"lectures/lecture4/","page":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","title":"Numerical Methods for Stiff ODEs and Differential-Algebraic Equations","text":"While one has a guaranteed bound on the number of possible jvps in GMRES which is simply the number of ODEs (since that is what determines the size of the Jacobian and thus the total dimension of the problem), that bound is not necessarily a good one. For a large sparse matrix, it may be computationally impractical to ever compute 100,000 jvps. Thus one does not typically run the algorithm to conclusion, and instead stops when Vert Jx-v Vert is sufficiently below some user-defined error tolerance.","category":"page"},{"location":"lectures/lecture2/#Developing-high-fidelity-models-of-hydraulic-systems","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"","category":"section"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"Why focus on hydraulics?  The answer is essentially hydraulic modelling is really hard (in numerical computing terms, hydraulic models are often referred to as \"stiff\" ODE's, which require more rigorous solvers from standard ODE's).  Solving the challenges of modeling hydraulics is applicable to the numerical modeling challenges of all other domains.  Let's first start with the concept of compressibility.  Often we think of a liquid as incompressible, imagine attempting to \"squeeze\" water, it can be done but takes some very high forces.  Therefore, if the model in question won't be solving a problem with high forces, it can be assumed incompressible.  However, most hydrulic industrial models will involve high forces, this is precisely the area where most hydraulic machines are used.  ","category":"page"},{"location":"lectures/lecture2/#Compressibility","page":"Developing high-fidelity models of hydraulic systems","title":"Compressibility","text":"","category":"section"},{"location":"lectures/lecture2/#Density","page":"Developing high-fidelity models of hydraulic systems","title":"Density","text":"","category":"section"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"Density is simply mass over volume","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"rho = mV","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"Given a volume and mass of liquid, if the volume were to change from V_0 to V, we know that the pressure would increase, and since the mass in this case was constant, the density will increase as well.","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"(Image: volume change)","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"The change in pressure for an isothermal compressible process is typically given as","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"Delta p = -beta fracDelta VV_0","category":"page"},{"location":"lectures/lecture2/#Calculating-Density-as-a-Function-of-Pressure","page":"Developing high-fidelity models of hydraulic systems","title":"Calculating Density as a Function of Pressure","text":"","category":"section"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"Substituting Delta p and Delta V","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"p - p_0 = -beta fracV - V_0V_0","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"substituting V = m  rho","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"p - p_0 = -beta (1 - rhorho_0)  ","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"Solving for rho","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"rho = rho_0 (1 + (p - p_0)beta)","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"Taking a known rho_0 when p_0 is 0 (at gage pressure), simplifies to","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"rho = rho_0 (1 + pbeta) ","category":"page"},{"location":"lectures/lecture2/#Change-in-Mass","page":"Developing high-fidelity models of hydraulic systems","title":"Change in Mass","text":"","category":"section"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"Conservation of mass gives us","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"m_in - m_out = m_s ","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"The stored mass of oil is simply","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"m_s = rho V ","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"Taking the derivative gives us the rate of mass change","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"dotm_in - dotm_out = fracdelta (rho V)delta t ","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"Here is where the standard hydraulic modeling often makes a simplification.  ","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"Correct Derivation (1):  ","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"fracdelta (rho V)delta t = dotrho V + rho dotV ","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"Standard Practice[1] (2):  ","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"colorred fracdelta (rho V)delta t = dotrho V + rho_0 dotV   ","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"Given dotrho = rho_0 (dotp  beta), and q = dotmrho_0 the above is often written as","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"colorred q_in - q_out = (dotp  beta) V + dotV ","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"[1]: See simscape hydraulic chamber.  Note the deprecation warning moving to isothermal liquid library which uses the correct derivation.","category":"page"},{"location":"lectures/lecture2/#Example","page":"Developing high-fidelity models of hydraulic systems","title":"Example","text":"","category":"section"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"Problem Definition - Given:","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"M = 10000 kg\nA = 001 m^2 \nrho_0 = 876 kgm^3\nbeta = 12e9 Pa\ng = 9807 ms^2","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"(Image: example)","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"Find the mass flow rate (dotm) that provides a sinusodial output of x:","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"x(t) = amp cdot sin(2πtf) + x_0","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"There are 3 fundamental equations needed to solve this problem.","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"(1) Mass balance: ","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"dotm = dotrho cdot V + rho cdot dotV","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"where V is the cylinder volume =x cdot A","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"(2) Newton's law:","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"M cdot ddotx = p cdot A - m cdot g","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"(3) Density equation:","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"rho = rho_0 (1 + pbeta) ","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"The variables of this system are x, p, rho, and dotm.  By including 1 input condition that gives 4 equations and 4 variables to be solved.  We will solve the problem 3 different ways","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"(Image: cases)","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"case 1: guess dotm, partial mass balance\ncase 2: guess dotm, complete mass balance\ncase 3: solution, solve dotm directly","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"note: mass flow guess\nWe know that mass flow rate thru a pipe is equal to dotm = rho baru Awhere baru is the average flow velocity thru cross section A.  We can assume that baru approx dotx.  Therefore we havedotm = rho cdot dotx cdot A","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"To solve this in ModelingToolkit.jl, let's start by defining our parameters and x function","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"using ModelingToolkit\nusing DifferentialEquations\nusing Symbolics\nusing Plots\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n# parameters -------\npars = @parameters begin\n    r₀ = 876 #kg/m^3\n    β = 1.2e9 #Pa\n    A = 0.01 #m²\n    x₀ = 1.0 #m\n    M = 10_000 #kg\n    g = 9.807 #m/s²\n    amp = 5e-2 #m\n    f = 15 #Hz    \nend\n\ndt = 1e-4 #s\nt_end = 0.2 #s\ntime = 0:dt:t_end\n\nx_fun(t,amp,f) = amp*sin(2π*t*f) + x₀\nnothing # hide","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"Now, to supply dotm we need an dotx function.  This can be automatically generated for us with Symbolics.jl","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"ẋ_fun = build_function(expand_derivatives(D(x_fun(t,amp,f))), t, amp, f; expression=false)","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"As can be seen, we get a cos function as expected taking the derivative of sin.  Now let's build the variables and equations of our system.  The base equations are generated in a function so we can easily compare the correct derivation of mass balance (density_type = r(t)) with the standard practice (density_type = r₀).","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"vars = @variables begin\n    x(t) = x₀\n    ẋ(t)\n    ẍ(t)\n    p(t) = M*g/A #Pa\n    ṁ(t)\n    r(t)\n    ṙ(t)\nend \n\nfunction get_base_equations(density_type) \n    \n    eqs = [\n        D(x) ~ ẋ \n        D(ẋ) ~ ẍ\n        D(r) ~ ṙ\n\n        r ~ r₀*(1 + p/β)\n\n        ṁ ~ ṙ*x*A + (density_type)*ẋ*A\n        M*ẍ ~ p*A - M*g\n    ]\n\n    return eqs\nend\nnothing # hide","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"Note: we've only specified the initial values for the known states of x and p.  We will find the additional unknown initial conditions before solving.  Now we have 7 variables defined and only 6 equations, missing the final driving input equation.  Let's build 3 different cases:","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"case 1:","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"eqs_ṁ1 = [\n    get_base_equations(r₀)...\n    ṁ ~ ẋ_fun(t,amp,f)*A*r # (4) Input - mass flow guess\n]\nnothing # hide","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"case 2:","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"eqs_ṁ2 = [\n    get_base_equations(r)...\n    ṁ ~ ẋ_fun(t,amp,f)*A*r # (4) Input - mass flow guess\n]\nnothing # hide","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"case 3:","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"eqs_x = [\n    get_base_equations(r)...\n    x ~ x_fun(t,amp,f) # (4) Input - target x \n]\nnothing # hide","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"Now we have 3 sets of equations, let's construct the systems and solve.  If we start with case 3 with the target x input, notice that the structural_simplify step outputs a system with 0 equations!","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"@mtkbuild odesys_x = ODESystem(eqs_x, t, vars, pars)\nnothing # hide","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"odesys_x","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"What this means is ModelingToolkit.jl has found that this model can be solved entirely analytically.  The full system of equations has been moved to what is called \"observables\", which can be obtained using the observed() function","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"observed(odesys_x)","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"note: dummy derivatives\nSome of the observables have a ˍt appended to the name.  These are called dummy derivatives, which are a consequence of the algorithm to reduce the system DAE index.  ","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"This system can still be \"solved\" using the same steps to generate an ODESolution which allows us to easily obtain any calculated observed state.","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"prob_x = ODEProblem(odesys_x, [], (0, t_end))\nsol_x = solve(prob_x; saveat=time)\nplot(sol_x; idxs=ṁ)","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"Now let's solve the other system and compare the results. ","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"@mtkbuild odesys_ṁ1 = ODESystem(eqs_ṁ1, t, vars, pars)\nnothing # hide","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"odesys_ṁ1","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"Notice that now, with a simple change of the system input variable, structural_simplify() outputs a system with 4 states to be solved.  We can find the initial conditions needed for these states from sol_x and solve.","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"u0 = [sol_x[s][1] for s in unknowns(odesys_ṁ1)]\nprob_ṁ1 = ODEProblem(odesys_ṁ1, u0, (0, t_end))\n@time sol_ṁ1 = solve(prob_ṁ1; initializealg=NoInit());\nnothing # hide","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"The resulting mass flow rate required to hit the target x position can be seen to be completely wrong.  This is the large impact that compressibility can have when high forces are involved.","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"plot(sol_ṁ1; idxs=ṁ, label=\"guess\", ylabel=\"ṁ\")\nplot!(sol_x; idxs=ṁ, label=\"solution\")","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"If we now solve for case 2, we can study the impact the compressibility derivation","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"@mtkbuild odesys_ṁ2 = ODESystem(eqs_ṁ2, t, vars, pars)\nprob_ṁ2 = ODEProblem(odesys_ṁ2, u0, (0, t_end))\n@time sol_ṁ2 = solve(prob_ṁ2; initializealg=NoInit());\nnothing # hide","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"As can be seen, a significant error forms between the 2 cases. Plotting first the absolute position.","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"plot(sol_x; idxs=x, label=\"solution\", ylabel=\"x\")\nplot!(sol_ṁ1; idxs=x, label=\"case 1: r₀\")\nplot!(sol_ṁ2; idxs=x, label=\"case 2: r\")","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"And now plotting the difference between case 1 and 2.","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"plot(time, (sol_ṁ1(time)[x] .- sol_ṁ2(time)[x])/1e-3, \n            label=\"x\", \n            ylabel=\"error (case 1 - case 2) [mm]\", \n            xlabel=\"t [s]\"\n        )","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"Also note the difference in computation.  ","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"sol_ṁ1.destats","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"As can be seen, including the detail of full compressibility resulted in more computation: more function evaluations, Jacobians, solves, and steps.","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"sol_ṁ2.destats","category":"page"},{"location":"lectures/lecture2/#ModelingToolkitStandardLibrary.jl","page":"Developing high-fidelity models of hydraulic systems","title":"ModelingToolkitStandardLibrary.jl","text":"","category":"section"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"Now let's re-create this example using components from the ModelingToolkitStandardLibrary.jl.  It can be shown that by connecting Mass and Volume components that the same exact result is achieved.  The important thing is to pay very close attention to the initial conditions.  ","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"import ModelingToolkitStandardLibrary.Mechanical.Translational as T\nimport ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible as IC\nimport ModelingToolkitStandardLibrary.Blocks as B\n\nusing DataInterpolations\nmass_flow_fun = LinearInterpolation(sol_x[ṁ], sol_x.t)\n\ninclude(\"volume.jl\") # <-- missing Volume component from MTKSL (will be released in new version) \n\nfunction MassVolume(; name, dx, drho, dm)\n\n    pars = @parameters begin\n        A = 0.01 #m²\n        x₀ = 1.0 #m\n        M = 10_000 #kg\n        g = 9.807 #m/s²\n        amp = 5e-2 #m\n        f = 15 #Hz   \n        p_int=M*g/A\n        dx=dx\n        drho=drho\n        dm=dm\n    end\n    vars = []\n    systems = @named begin\n        fluid = IC.HydraulicFluid(; density = 876, bulk_modulus = 1.2e9)\n        mass = T.Mass(;v=dx,m=M,g=-g)\n        vol = Volume(;area=A, x=x₀, p=p_int, dx, drho, dm) # <-- missing Volume component from MTKSL (will be released in new version) \n        mass_flow = IC.MassFlow(;p_int)\n        mass_flow_input = B.TimeVaryingFunction(;f = mass_flow_fun)\n    end\n\n    eqs = [\n        connect(mass.flange, vol.flange)\n        connect(vol.port, mass_flow.port)\n        connect(mass_flow.dm, mass_flow_input.output)\n        connect(mass_flow.port, fluid)\n    ]\n\n    return ODESystem(eqs, t, vars, pars; systems, name)\nend\n\ndx = sol_x[ẋ][1]\ndrho = sol_x[ṙ][1]\ndm = sol_x[ṁ][1]\n\n@mtkbuild odesys = MassVolume(; dx, drho, dm)\n\nprob = ODEProblem(odesys, [], (0, t_end))\nsol=solve(prob)\n\nplot(sol; idxs=odesys.vol.x, linewidth=2)\nplot!(sol_x; idxs=x)","category":"page"},{"location":"lectures/lecture2/#Momentum-Balance","page":"Developing high-fidelity models of hydraulic systems","title":"Momentum Balance","text":"","category":"section"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"The next challenging aspect of hydraulic modeling is modeling flow through a pipe, which for compressible flow requires resolving the momentum balance equation. To derive the momentum balance we can draw a control volume (cv) in a pipe with area A, as shown in the figure below, and apply Newton's second law.  Across this control volume from x_1 to x_2 the pressure will change from p_1 to p_2.  Assuming this is written for an acausal component we put nodes at p_1 to p_2 which will have equal mass flow dotm entering and exiting the cv[2].","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"[2]: The Modelica Standard Library combines the mass and momentum balance to the same base class, therefore, mass flow in and out of the cv is not equal, which introduces an additional term to the lhs of the momentum balance:  $ \\frac{\\partial \\left( \\rho u^2 A \\right) }{\\partial x}  $  ","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"Now taking the sum of forces acting on the cv we have the pressure forces at each end as well as the viscous drag force from the pipe wall and the body force from gravity.  The sum of forces is equal to the product of mass (rho V) and flow acceleration (dotu).   ","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"    rho V dotu = (p_1 - p_2) A - F_viscous + rho V g","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"where","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"beginalign\nF_viscous = A frac12 rho u^2 f fracLd_h\nendalign","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"given f is the fully developed flow pipe friction factor for a given shape, L is the pipe length, and d_h is the pipe hydraulic diameter.","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"note: Project Idea\nthe current implementation of this component in the ModelingToolkitStandardLibrary.jl does not include gravity force for this makes initialization challenging and will take some work to implement.","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"The density rho is an average of rho_1 and rho_2.  The velocity is also taken as an average of u_1 and u_2","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"u_1 = fracdotmrho_1 A","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"u_2 = fracdotmrho_2 A","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"(Image: momentum balance)","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"note: Conservation of Momentum\nthe term rho V dotu introduces what is referd to as fluid inertia.  This is what resolves the pressure wave propagation through a pipe.  A classic wave propagation example in pipes is the \"water hammer\" effect.  The full derivation for the flow velocity derivative is when deriving in 2 dimensions is fracD textVDt = fracpartial textVpartial t + fracpartial textVpartial x u + fracpartial textVpartial z wwhere textV is the velocity vector, u and w are the flow components in x and y directions.  In the ModelingToolkitStandardLibrary.jl this assumption is takenrho V fracD textVDt approx fracpartial dotmpartial t","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"note: Project Idea\nImplement a more detailed Conservation of Momentum using the standard derivation.  One idea is to implement the MethodOfLines.jl to provide the derivative in x.","category":"page"},{"location":"lectures/lecture2/#Pipe-Component","page":"Developing high-fidelity models of hydraulic systems","title":"Pipe Component","text":"","category":"section"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"To model a pipe for compressible flow, we can combine the mass balance and momentum balance components to give both mass storage and flow resistance.  Furthermore, to provide a more accurate model that allows for wave propagation we can discretize the volume connected by node of equal pressure and mass flow.  The diagram below shows an example of discretizing with 3 mass balance volumes and 2 momentum balance resistive elements.  Note: the Modelica Standard Library does this in a different way, by combining the mass and momentum balance in a single base class.  ","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"(Image: pipe)","category":"page"},{"location":"lectures/lecture2/#Dynamic-Volume-Component","page":"Developing high-fidelity models of hydraulic systems","title":"Dynamic Volume Component","text":"","category":"section"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"Both Modelica and SimScape model the actuator component with simply a uniform pressure volume component.  The Modelica library defines the base fluids class around the assumption of constant length (see: Object-Oriented Modeling of Thermo-Fluid Systems) and therefore adapting to a component that changes length is not possible.  But in cases with long actuators with high dynamics the pressure is not at all uniform, therefore this detail cannot be ignored.  Therefore, adding in the momentum balance to provide flow resistance and fluid inertia are necessary.  The diagram below shows the design of a DynamicVolume component which includes both mass and momentum balance in addition to discretization by volume.  The discretization is similar to the pipe, except the scheme becomes a bit more complicated with the moving wall (x).  As the volume shrinks, the control volumes will also shrink, however not in unison, but one at a time.  In this way, as the moving wall closes, the flow will come from the first volume cv1 and travel thru the full size remaining elements (cv2, cv3, etc.).  After the first component length drops to zero, the next element will then start to shrink.  ","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"(Image: volume)","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"This design has a flaw unfortunately, expanding the system for N=3 gives ","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"(Image: eqs1)","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"What happens when transitioning from one cv to the next, if the moving wall velocity is significant, then an abrupt change occurs due to the rho_i dotx term.  This creates an unstable condition for the solver and results in poor quality/accuracy.  To resolve this problem, the mass balance equation is split into 2 parts: mass balance 1 \\& 2 ","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"textmass balance 1  dotmA = dotrho x","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"textmass balance 2  dotmA = rho dotx","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"The below diagram explains how this component is constructed","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"(Image: dynamic volume)","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"Now the flows are simplified and are more numerically stable.  The acausal connections then handle the proper summing of flows.","category":"page"},{"location":"lectures/lecture2/","page":"Developing high-fidelity models of hydraulic systems","title":"Developing high-fidelity models of hydraulic systems","text":"(Image: eqs2)","category":"page"},{"location":"#ModelingToolkitCourse","page":"Home","title":"ModelingToolkitCourse","text":"","category":"section"},{"location":"#18.S191-Special-Subject-in-Mathematics:-Composable-System-Modeling-and-Its-Compilation","page":"Home","title":"18.S191 Special Subject in Mathematics: Composable System Modeling and Its Compilation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Traditionally, modeling physical systems often requires a deep understanding of the physics and equations of motions or states, simplifying the differential equations using conservation laws and constraints, and finally implementing simplified equations in a scientific computing language to numerically solve them. However, this workflow is tedious and not expressive. A simple change in the underlying physical system often requires a complete re-derivation of the simplified equations. A composable modeling system frees domain experts from the time-consuming derivation, simplification, and implementation by allowing them to model each physical component separately and hierarchically, thereby enabling them to build more accurate and complex models without compromising the simulation performance. In this course, we will dive into the practice of implementing composable physical models and the compilation process of the model system using the ModelingToolkit.jl acausal modeling framework in Julia. Students will learn the mathematics and numerical methods behind solving industry-scale models, covering topics such as differential-algebraic equations (DAEs), modern techniques in implicit integrators (backwards differentiation formulae (BDFs)), symbolic manipulation of equations via techniques like Pantelides algorithm and tearing of nonlinear systems, and more. Applications for solving real-world problems like modeling battery systems of electric vehicles, efficient control of hydraulic and HVAC systems, and more will be used to demonstrate how these techniques are used in industrial settings.","category":"page"},{"location":"#Syllabus","page":"Home","title":"Syllabus","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Prerequisites: While this course will be mixing ideas from symbolic computing, numerical differential equations, and topics from mechanical engineering, no one in the course is expected to have covered all of these topics before. Understanding of calculus, linear algebra, and programming is essential. The course is considered self-contained starting from the basic building blocks of undergraduate differential equations. Problem sets will involve use of Julia, a Matlab-like environment (little or no prior experience required; you will learn as you go), for doing acausal modeling via the ModelingToolkit.jl system.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Textbook & Other Reading: There is no textbook for this course. For a textbook that covers the practical parts of doing modeling and simulation in an acausal way, Michael Tiller's \"Modelica by Example\" is a good reference (see https://mbe.modelica.university/). For a textbook that covers the algorithms of acausal modeling compilers, there is no recommended textbook and lecture notes will be supplied as a primary source.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Grading: The final project proposal (due January 15th) is 25%, and 75% for the final project (due February 2nd). Final projects will be submitted electronically via email.","category":"page"},{"location":"#Final-Project","page":"Home","title":"Final Project","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The final project can take two forms: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Developing an acausal model of some real-world system. \nImplementation and analysis of a new acausal modeling compiler feature. \nImplementation and analysis of numerical methods for acausal models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A final project proposal is due January 19th and the final project is due on the last day of the course. The last day will be final project presentations where the work is demonstrated to the class.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The final project's deliverable can take two different forms:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A final project writeup: a 5-10 page paper using the style template from the SIAM Journal on Numerical Analysis (or similar) explaining what was done, along with a Github repository package with the components of the model and docs/tests which demonstrate the successful composed model.\nA pull request to one of the libraries (ModelingToolkit, ModelingToolkitStandardLibrary, OrdinaryDiffEq, NonlinearSolve, etc.). For this version of the project, it is sufficient to supply a pull request to MTK/MSL with a description of the feature being implemented, tests of the transformation, and documentation showcasing its correct action on test models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We expect the work to be roughly the same for the two routes, where the 1st would entail more theory and mathematical writeup while the latter is more focused on code and documentation. Note that any project considering doing a new acausal modeling feature should heavily consider doing the pull request route as writing a toy acausal modeling compiler within the timeframe of the course is likely to be unsuccessful.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that many of these projects are starter projects towards publications. If you're interested in continuing this work after the IAP towards a publication, please discuss during the project selection page so the project can be appropriately scoped.","category":"page"},{"location":"#Project-Type-1-Ideas:-Developing-an-Acausal-Model-of-A-Real-World-System","page":"Home","title":"Project Type 1 Ideas: Developing an Acausal Model of A Real-World System","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following sources can be used as inspiration:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modelica \"other\" libraries (https://modelica.org/libraries/) \nModelica Standard Library (https://github.com/modelica/ModelicaStandardLibrary)","category":"page"},{"location":"#Project-Type-2-Ideas:-Implementation-and-analysis-of-a-new-acausal-modeling-compiler-feature","page":"Home","title":"Project Type 2 Ideas: Implementation and analysis of a new acausal modeling compiler feature","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Automated Laplace and Fourier transforms\nAutomated function transformation of observables (i.e. log-transform states to enforce positivity)\nSymbolic generation of sensitivity analysis equations (https://github.com/SciML/ModelingToolkit.jl/issues/39)\nLamperti transformation of stochastic differential equations (https://github.com/SciML/ModelingToolkit.jl/issues/140)\nAutomated conversion of distributed delay equations into ODEs (https://github.com/SciML/ModelingToolkit.jl/issues/45)\nSpecialized nonlinear solvers based on strongly connected components\nInline integration (https://people.inf.ethz.ch/fcellier/Pubs/OO/esm_95.pdf)\nAutomated detection of events from discontinuities in the ODE/DAE definition\nPolynomial chaos expansions for fast uncertainty quantification\nDCP on OptimizationSystem to automatically transform nonlinear optimization problems to convex optimization problems (http://cvxr.com/cvx/doc/dcp.html)\nCommon subexpression elimination in Symbolic code generation\nExtendable C code generation maps from Symbolics\nDirect-quadrature-zero transformation for multibody systems and robotics (https://en.wikipedia.org/wiki/Direct-quadrature-zero_transformation)\nPryce's algorithm for DAE index reduction (https://link.springer.com/article/10.1023/A:1021998624799, https://inria.hal.science/hal-03104030v2/document)","category":"page"},{"location":"#Project-Type-3-Ideas:-Implementation-and-analysis-of-numerical-methods-for-acausal-models","page":"Home","title":"Project Type 3 Ideas: Implementation and analysis of numerical methods for acausal models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Adaptive order Radau methods (https://www.sciencedirect.com/science/article/pii/S037704279900134X)\nParallel Rosenbrock and FIRK methods\nHandling the difficulties of BDFs in DAE systems (i.e. handling known deficiencies in the DFBDF algorithm)\nNew time stepping schema for Rosenbrock methods for DAE interpolation performance\nInvestigation of nonlinear solver globalization schemes for difficult DAE initialization problems","category":"page"},{"location":"#Tentative-Schedule","page":"Home","title":"Tentative Schedule","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"January 10th: Introduction to the course, Guest lecture: Brad Carman, introduction to acausal modeling for physical systems with ModelingToolkit\nJanuary 12th: Guest lecture: Brad Carman, developing high-fidelity models of hydraulic systems \nJanuary 15th: Martin Luther King Day!\nJanuary 17th: Real numerical methods for implicit equations and stiff ordinary differential equations (ODEs), i.e., Jacobian-free Newton-Krylov, adaptive time stepping, dense output, sparse automatic differentiation, event handling.\nJanuary 18th (Make up day for MLK day): Continuing discussion of stiff ODEs and onto numerical methods for differential-algebraic equations (DAEs). Rosenbrock methods, Backwards-Differentiation Formulae (BDF), fully-implicit Runge-Kutta methods.\nJanuary 19th: Finishing the discussion on stiff ODEs and DAEs. If time allows, discussion of handling inverse problems (parameter estimation), adjoint methods, uncertainty quantification, and the connections to reverse-mode AD.\nJanuary 22nd: Discussion and interactive workshop on debugging difficult stiff ODE/DAE models (featuring Brad Carman and Yingbo Ma).\nJanuary 24th: Guest Lecture: Yingbo Ma. How acausal model compilers work: index reduction. Pantelides algorithm, dummy derivatives, and demonstrations.\nJanuary 26th: Guest Lecture: Yingbo Ma. How acausal model compilers work: Tearing of nonlinear systems and alias elimination.\nJanuary 29th: Guest Lecture: Yingbo Ma. How acausal model compilers work: Loop rerolling, specialized optimizations for multibody systems, and other generated code robustness and performance optimizations.\nJanuary 31st: TBD based on what is not sufficiently covered earlier in the course.\nFebruary 2nd: Final project presentations!","category":"page"},{"location":"lectures/lecture8/#Dummy-Derivatives-and-Reordering-of-Equations","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"","category":"section"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"Consider a single pendulum in the Cartesian coordinate","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"beginalign\ne_1 x - lambda x = 0 \ne_2 y - (lambda y - g) = 0 \ne_3 x^2 + y^2 - 1 = 0\nendalign","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"Its incidence matrix with respect to the highest differentiated variables x y lambda is","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"beginpmatrix\n1  0  1 \n0  1  1 \n0  0  0\nendpmatrix","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"We can obtain a structurally non-singular incidence matrix if we were to differentiate the last equation two times and get:","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"beginpmatrix\n1  0  1 \n0  1  1 \n1  1  0\nendpmatrix","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"The perfect matching m can be 1 mapsto 1 2 mapsto 3 3 mapsto 2. According to the perfect matching, we need to interchange the second and the third row of the incidence matrix to move all nonzero entries to the diagonal.","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"beginpmatrix\n1  0  1 \n1  1  0 \n0  1  1\nendpmatrix","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"The matching also informs us that we can attempt to solve the highest order differentiated variables by the assignment","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"beginalign\ne_1 lambda mapsto x \ne_3 x mapsto y \ne_2 y mapsto lambda\nendalign","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"Hence, we have the following dependency graph","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"flowchart LR\n    A(x'') --> B(λ)\n    C(y'') --> A\n    B --> C","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"Since all the variables are in one strongly connected component, unfortunately, we cannot break the nonlinear system into smaller subsystems. Let's implement the differentiated system and solve it numerically.","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"using ModelingToolkit, OrdinaryDiffEq, Plots, LinearAlgebra\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\nfunction pend_manual(out, u, g, t)\n    ẋ, x, ẏ, y, λ = u\n    ẍ = out[1] = λ * x\n    out[2] = ẋ\n    ÿ = out[3] = λ * y - g\n    out[4] = ẏ\n    # x^2 + y^2 - 1\n    # x' x + y' y\n    # x'' x + x'^2 + y'' y + y'^2\n    out[5] = ẍ*x + ẋ^2 + ÿ*y + ẏ^2\nend\nfun = ODEFunction(pend_manual, mass_matrix = Diagonal([1, 1, 1, 1, 0]))\nprob = ODEProblem(fun, [0, 1, 0, 0, 0.0], (0, 500.0), 1)\nsol = solve(prob, Rodas5P())\nplot(sol.t, (@. sol[2, :]^2 + sol[4, :]^2), lab = \"d0\")","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"plot(sol.t, (@. sol[1, :] * sol[2, :] + sol[3, :] * sol[4, :]), lab = \"d1\")","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"Note that the original constraints are not satisfied and, even worse, the residual drifts over time. Let's plot the pendulum in the Cartesian coordinate over time.","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"plot(sol, idxs = (2, 4), lab = \"pendulum\", aspect_ratio = 1)","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"The drift causes the system to be completely unphysical.","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"The issue stems from the fact that we are not explicitly enforcing length and momentum constraints in the differentiated DAE system. However, if we were to enforce the equations simultaneously","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"beginalign\ne_3 x^2 + y^2 - 1 = 0 \ne_3 x x + y y = 0 \ne_3 x x + x^2 + y y + y^2 = 0\nendalign","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"We will get an under-determined system that is not numerically integrable. However, we only need to balance the number of highest order differentiated variables with the number of equations. We can demote highest order differentiated variables to algebraic variables to increase the number of highest order differentiated variables by 1. Also, since our objective it to increase the number of highest order differentiated variables by the number of differentiated equations introduced during index reduction, we can just focus on the incidence matrix mathfrakI(F_d z_i), where F_d denotes differentiated equations. For the pendulum system, we have","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"mathfrakI(e_3 x y lambda) = beginpmatrix\n1  1  0\nendpmatrix","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"Furthermore, we want the newly introduced algebraic variables to be solvable. By analyzing the incidence matrix, we can conclude that we can pick either x or y. Let's arbitrarily pick x, we have","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"mathfrakI(e_3 x) = beginpmatrix\n1\nendpmatrix","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"which is structurally nonsingular. After demoteing x to an algebraic variable, the remaining highest order differentiated variable associated with x is x. Thus, we need to pick a variable in","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"mathfrakI(e_3 x) = beginpmatrix\n1\nendpmatrix","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"so that the incidence matrix is structurally nonsingular. Trivially, we can just pick x. From the above process, we can demote xin u_i and xin u_i to algebraic variables x_ddinu_i and x_dinu_i. We get the system","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"beginalign\ne_1 x_dd - lambda x = 0 \ne_2 y - (lambda y - g) = 0 \ne_3 x^2 + y^2 - 1 = 0 \ne_3 x_d x + y y = 0 \ne_3 x_dd x + x_d^2 + y y + y^2 = 0\nendalign","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"with the corresponding incidence matrix","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"mathfrakI(F x_dd x_d x y lambda) = beginpmatrix\n1  0  1  0  1 \n0  0  0  1  1 \n0  0  1  0  0 \n0  1  1  0  0 \n1  1  1  1  0\nendpmatrix","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"A perfect matching m for this system can be 1mapsto 5 2mapsto 4 3mapsto 3 4mapsto 2 5mapsto 1, i.e. we can reverse all rows to move all nonzeros to the diagonal","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"beginpmatrix\n1  1  1  0  0 \n0  1  1  0  0 \n0  0  1  0  0 \n0  0  0  1  1 \n1  0  1  0  1\nendpmatrix","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"Note that if we reorder the variables to x x_d y lambda x_dd according to the matching, the equation order should be e_3 e_3 e_2 e_1 e_3 the incidence matrix is then","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"beginpmatrix\n    1  0  0  0  0 \n    1  1  0  0  0 \n    0  0  1  1  0 \n    1  0  0  1  1 \n    1  1  0  0  1\nendpmatrix","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"The reordered original system is then","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"beginalign\ne_3 x^2 + y^2 - 1 = 0 \ne_3 x_d x + y y = 0 \ne_2 y - (lambda y - g) = 0 \ne_1 x_dd - lambda x = 0 \ne_3 x_dd x + x_d^2 + y y + y^2 = 0\nendalign","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"and applying the symbolic solving, we have","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"beginalign\ne_3 x^2 + y^2 - 1 = 0 \ne_3 x_d = -fracy yx \ne_2 y = lambda y - g\ne_1 x_dd = lambda x \ne_3 x_dd x + x_d^2 + y y + y^2 = 0\nendalign","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"The above system is still second order, we can lower its order to one if we introduce a variable y = v, i.e.","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"beginalign\ne_0 y = v \ne_3 x^2 + y^2 - 1 = 0 \ne_3 x_d = -fracv yx \ne_2 v = lambda y - g\ne_1 x_dd = lambda x \ne_3 x_dd x + x_d^2 + v y + v^2 = 0\nendalign","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"Note that v appears nonlinearly in e_3, so it is impossible to implement the above system in the mass matrix formulation Mu = f(u p t). However, we can substitute e_2 to e_3 to alleviate this problem. Let's implement this simplified system and solve it using a numerical solver.","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"function pend_manual_2(out, u, g, t)\n    y, x, v, λ = u\n    out[1] = v\n    out[2] = x^2 + y^2 - 1\n    x_d = -v*y/x\n    v̇ = out[3] = λ * y - g\n    x_dd = λ * x\n    out[4] = x_dd * x + x_d^2 + v̇ * y + v^2\nend\nfun = ODEFunction(pend_manual_2, mass_matrix = Diagonal([1, 0, 1, 0]))\nprob = ODEProblem(fun, [0, 1, 0, 0.0], (0, 500.0), 1)\nsol = solve(prob, Rodas5P())\nplot(sol.t, (@. sol[1, :]^2 + sol[2, :]^2), lab = \"d0\", ylims = (0, 2))","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"plot(sol.t, (@. sol[2, :] * (-sol[3, :] * sol[1, :] / sol[2, :]) + sol[1, :] * sol[3, :]), lab = \"d1\", ylims = (-1, 1))","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"plot(sol, idxs = (2, 1), lab = \"pendulum\", aspect_ratio = 1)","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"Note that this formulation solves the drift problem. However, this time, the numerical solver terminates early at x = 0. The root problem is that the true symbolic Jacobian is","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"mathfrakJ(e_3 x y lambda) = beginpmatrix\nx  y  0\nendpmatrix","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"and when x=0, the sub-matrix that we selected will become numerically singular. Even if we initially pick y, we would run into a similar problem when y=0. Therefore, a globally valid state selection does not exist in this system. We can implement the same system in ModelingToolkit and see the same behavior.","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"@parameters g\n@variables x(t) y(t) [state_priority = 10] λ(t)\n\neqs = [\n       D(D(x)) ~ λ * x\n       D(D(y)) ~ λ * y - g\n       x^2 + y^2 ~ 1\n      ]\n@named pend = ODESystem(eqs,t)\npend = complete(pend)\nss = structural_simplify(pend)\nprob_ir = ODEProblem(ss, [ModelingToolkit.missing_variable_defaults(ss); x => 1], (0.0, 25.0), [g => 1])\nsol = solve(prob_ir, Rodas5P())\nplot(sol, idxs = (x, y), lab = \"pendulum\", aspect_ratio = 1)","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"To have a globally valid state selection, we must pick the polar coordinate, and the system is then","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"beginalign\ne_1 x - lambda x = 0 \ne_2 y - (lambda y - g) = 0 \ne_3 x = cos(theta) \ne_3 y = sin(theta)\nendalign","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"To save the hassle of running algorithms by hand, we can just implement the new system in ModelingToolkit.","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"@parameters g\n@variables x(t) y(t) λ(t) θ(t) [state_priority = 10] T(t) V(t) E(t)\neqs = [\n       D(D(x)) ~ λ * x\n       D(D(y)) ~ λ * y - g\n       x ~ cos(θ)\n       y ~ sin(θ)\n       T ~ (D(x)^2 + D(y)^2) / 2\n       V ~ y * g\n       E ~ T + V\n      ]\n@named pend = ODESystem(eqs,t)\npend = complete(pend)\nss = structural_simplify(pend)\nprob_ir = ODEProblem(ss, ModelingToolkit.missing_variable_defaults(ss), (0.0, 25.0), [g => 1])\nsol = solve(prob_ir, Rodas5P())\nplot(sol, idxs = (x, y), lab = \"pendulum\", aspect_ratio = 1)","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"The trajectory looks perfect! For another sanity check, let's plot the energy variation of the system","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"plot(sol, idxs = [E-sol[E, 1]])","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"Unfortunately, we see that the total energy is slowly increasing. This is because Rodas5P is not symplectic. A relatively straightforward compiler internal project is to lower second dynamical systems directly to a SecondOrderODEProblem so that users can use symplectic integrators from ModelingToolkit as well. Finally, we note that a detail description of the balancing algorithm is available in the original dummy derivative paper [Mattsson1993].","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"[Mattsson1993]: Mattsson, Sven Erik, and Gustaf Söderlind. \"Index reduction in differential-algebraic equations using dummy derivatives.\" SIAM Journal on Scientific Computing 14.3 (1993): 677-692.","category":"page"},{"location":"lectures/lecture8/#Bonus-Demo","page":"Dummy Derivatives and Reordering of Equations","title":"Bonus Demo","text":"","category":"section"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"@parameters g\n@variables x1(t) x2(t) y1(t) y2(t) λ1(t) λ2(t) θ1(t) [state_priority = 10] θ2(t) [state_priority = 10]\n@variables T(t) V(t) lx2(t) ly2(t)\neqs = [\n       D(D(x1)) ~ λ1 * x1 - λ2 * lx2\n       D(D(y1)) ~ λ1 * y1 - λ2 * ly2 - g\n       x1 ~ cos(θ1)\n       y1 ~ sin(θ1)\n       D(D(x2)) ~ λ2 * lx2\n       D(D(y2)) ~ λ2 * ly2 - g\n       lx2 ~ cos(θ2)\n       ly2 ~ sin(θ2)\n       x2 ~ lx2 + x1\n       y2 ~ ly2 + y1\n       T ~ (D(x1)^2 + D(y1)^2) / 2 + (D(x2)^2 + D(y2)^2) / 2\n       V ~ y1 * g + y2 * g\n      ]\n\n@named pend = ODESystem(eqs,t)\npend = complete(pend)\nss = structural_simplify(pend)\nprob_ir = ODEProblem(ss,\n                     [ModelingToolkit.missing_variable_defaults(ss); θ2=>1.4],\n                     (0.0, 25.0), [g => 1])\nsol = solve(prob_ir, Rodas5P(), reltol=1e-7, abstol=1e-9)\nplot(sol, idxs = (x1, y1))\nplot!(sol, idxs = (x2, y2), xlab = \"x\", ylab = \"y\", aspect_ratio=1, dpi=400)","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"plot(sol, idxs = [T+V-sol[T+V, 1]])","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"(Image: )","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"Plotting code:","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"nframes = ceil(Int, sol.t[end]*20)\nts = range(0, sol.t[end], length=nframes)\nfps = 20\nloop_pend = let (x1s, y1s, x2s, y2s) = [Float64[] for _ in 1:4]\n    @time @animate for t in ts\n        @show t\n        nnn = sol(t, idxs=[x1, y1, x2, y2])\n        push!(x1s, nnn[1])\n        push!(y1s, nnn[2])\n        push!(x2s, nnn[3])\n        push!(y2s, nnn[4])\n        x1s = x1s[max(1, end-100):end]\n        y1s = y1s[max(1, end-100):end]\n        x2s = x2s[max(1, end-100):end]\n        y2s = y2s[max(1, end-100):end]\n        n = length(x1s)\n        plot([0, x1s[end]], [0, y1s[end]], linewidth = 3, color=:black)\n        plot!([x1s[end], x2s[end]], [y1s[end], y2s[end]], linewidth = 3, color=:black)\n        linewidth = 10\n        seriesalpha = 1\n        if n != 1\n            linewidth = range(0, linewidth, length = n)\n            seriesalpha = range(0, seriesalpha, length = n)\n        end\n        plot!(x1s, y1s; linewidth, seriesalpha)\n        linewidth = 10\n        if n != 1\n            linewidth = range(0, linewidth, length = n)\n        end\n        plot!(x2s, y2s; linewidth, seriesalpha,\n              dpi = 400, aspect_ratio = 1,\n              xlims = (-2.3, 2.3), ylims = (-2.3, 2.3),\n              axis=false, leg = false, grid=false)\n    end every 5\nend\n@time mp4(loop_pend, \"double_pendulum.mp4\"; fps)","category":"page"},{"location":"lectures/lecture8/#Details-on-Reordering","page":"Dummy Derivatives and Reordering of Equations","title":"Details on Reordering","text":"","category":"section"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"definition: Induced Directed Graphs\nThe induced directed graph G = (V E_v) from the destination vertices of a bipartite graph (U V E) and a perfect matching M is defined asE_v = (i j) (M(i) j) in ESimilarly, the induced directed graph G = (V E_u) from the source vertices is defined asE_u = (i j) (i M^-1(j)) in E","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"definition: Strongly Connected Component\nA strongly connected component csubseteq E of a directed graph G = (V E) is a maximum cardinality set of vertices such that any pair i in c j in c, there exists a path i rightsquigarrow j in G.","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"note: Strongly Connected Components Uniqueness Theorem\nThe strongly connected components are unique for induced directed graphs from bipartite graphs with a perfect matching.Proof:See [DulmageMendelsohn1958].","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"[DulmageMendelsohn1958]: Dulmage, Andrew L., and Nathan S. Mendelsohn. \"Coverings of bipartite graphs.\" Canadian Journal of Mathematics 10 (1958): 517-534.","category":"page"},{"location":"lectures/lecture8/#Example","page":"Dummy Derivatives and Reordering of Equations","title":"Example","text":"","category":"section"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"Consider a nonlinear system represented by","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"beginalign\nf_1(v_1 v_3) = 0 \nf_2(v_1 v_3) = 0 \nf_3(v_1 v_2) = 0\nendalign","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"The incidence matrix is","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"beginpmatrix\n1  0  1 \n1  0  1 \n1  1  0\nendpmatrix","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"where a perfect matching m is then defined as","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"1 mapsto 1 2 mapsto 3 3 mapsto 2","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"The permuted matrix is then","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"beginpmatrix\n1  0  1 \n1  1  0 \n1  0  1\nendpmatrix","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"The matching can be interpreted as a solvability assignment, i.e.","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"beginalign\nv_1 = hatf_1(v_3) \nv_2 = hatf_3(v_1) \nv_3 = hatf_2(v_2)\nendalign","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"Even if all hatf_i are symbolically solvable, the above assignment will not work because the interdependence of variables. The strongly connected component definition captures this idea well. Variables in a non-trivial strongly connected component are the largest set of variables that are interdependent. The strongly connected components of the above system are 1 3 2. Thus, by the previous matching, we should reorder the equations as e_1 e_2 e_3 and variables as v_1 v_3 v_2 to isolate the interdependent part. The resulting system is then","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"beginpmatrix\n1  1  0 \n1  1  0 \n1  0  1\nendpmatrix","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"Note that resulting matrix is block lower triangular and this is not a coincidence. We can always reorder the system to be block lower triangular granted by the following theorem.","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"definition: Condensation Graph\nA condensation graph G_c = (V_c E_c) of a directed graph G = (V E) is a directed graph that has verticesV_c = textstrongly connected components of  Gand edgesE_c = (i j) exists i_e in i j_e in j i ne j land (i_e j_e)\nin E","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"note: Condensation Graphs are Acyclic Theorem\nThe condensation graph G_c = (V_c E_c) induced from the directed graph G = (V E) is acyclic.Proof:Suppose G_c is cyclic with a cycle consisting of vertices s = v_1 v_2  subseteq V_c. Then, any original vertices in v_i has a path to any vertices in v_j for all i j. Thus, G_c must have only one vertex. By the definition of a condensation graph, G_c must has no edges, and therefore, no cycles.","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"Since the condensation graph has no cycles, we can topologically sort strongly connected components so that the resulting system is always block lower triangular. Further, each block on the diagonal must be square, because the perfect matching will map all variables in each strongly connected components to distinct equations.","category":"page"},{"location":"lectures/lecture8/#Demo","page":"Dummy Derivatives and Reordering of Equations","title":"Demo","text":"","category":"section"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"using ModelingToolkit, OrdinaryDiffEq, LinearAlgebra\nimport ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible as IC\nimport ModelingToolkitStandardLibrary.Blocks as B\nimport ModelingToolkitStandardLibrary.Mechanical.Translational as T\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\nfunction System(use_input, f; name)\n\n    pars = @parameters begin\n        p_s = 200e5\n        p_r = 5e5\n\n        A_1 = 360e-4\n        A_2 = 360e-4\n\n        p_1 = 45e5\n        p_2 = 45e5\n\n        l_1 = 0.01\n        l_2 = 0.05\n        m_f = 250\n        g = 0\n\n        d = 100e-3\n\n        Cd = 0.01\n\n        m_piston = 880\n    end\n\n    vars = @variables begin\n        ddx(t) = 0\n    end\n\n    systems = @named begin\n        src = IC.FixedPressure(; p = p_s)\n        valve = IC.SpoolValve2Way(; p_s_int = p_s, p_a_int = p_1, p_b_int = p_2,\n            p_r_int = p_r, g, m = m_f, x_int = 0, d, Cd)\n        piston = IC.Actuator(5;\n            p_a_int = p_1,\n            p_b_int = p_2,\n            area_a = A_1,\n            area_b = A_2,\n            length_a_int = l_1,\n            length_b_int = l_2,\n            m = m_piston,\n            g = 0,\n            x_int = 0,\n            minimum_volume_a = A_1 * 1e-3,\n            minimum_volume_b = A_2 * 1e-3,\n            damping_volume_a = A_1 * 5e-3,\n            damping_volume_b = A_2 * 5e-3)\n        body = T.Mass(; m = 1500)\n        pipe = IC.Tube(5; p_int = p_2, area = A_2, length = 2.0)\n        snk = IC.FixedPressure(; p = p_r)\n        pos = T.Position()\n\n        m1 = IC.FlowDivider(; p_int = p_2, n = 3)\n        m2 = IC.FlowDivider(; p_int = p_2, n = 3)\n\n        fluid = IC.HydraulicFluid()\n    end\n\n    if use_input\n        @named input = B.SampledData(Float64)\n    else\n        @named input = B.TimeVaryingFunction(f)\n    end\n\n    push!(systems, input)\n\n    eqs = [connect(input.output, pos.s)\n        connect(valve.flange, pos.flange)\n        connect(valve.port_a, piston.port_a)\n        connect(piston.flange, body.flange)\n        connect(piston.port_b, m1.port_a)\n        connect(m1.port_b, pipe.port_b)\n        connect(pipe.port_a, m2.port_b)\n        connect(m2.port_a, valve.port_b)\n        connect(src.port, valve.port_s)\n        connect(snk.port, valve.port_r)\n        connect(fluid, src.port, snk.port)\n        D(body.v) ~ ddx]\n\n    ODESystem(eqs, t, vars, pars; name, systems)\nend\n\n@named system = System(true, nothing)\n\n# sys = structural_simplify(system)\nusing ModelingToolkit.StructuralTransformations, ModelingToolkit.BipartiteGraphs,\n    Graphs\nts = TearingState(ModelingToolkit.expand_connections(system))\nm = BipartiteGraphs.maximal_matching(ts.structure.graph, _->true, x->ts.structure.var_to_diff[x] === nothing);\ncount(x->x isa Int, m)\ncount(x->x===nothing, ts.structure.eq_to_diff)\nModelingToolkit.pantelides!(ts)\nm = BipartiteGraphs.maximal_matching(ts.structure.graph, x->ts.structure.eq_to_diff[x]===nothing, x->ts.structure.var_to_diff[x] === nothing);\ncount(x->x isa Int, m)\ncount(x->x===nothing, ts.structure.eq_to_diff)\nM = incidence_matrix(ts.structure.graph)\nA = M[Int[m[i] for i in eachindex(m) if m[i] isa Int], Int[i for i in eachindex(m) if m[i] isa Int]]\nall(isequal(1), diag(A))\ng = BipartiteGraphs.DiCMOBiGraph{true}(complete(ts.structure.graph), complete(m));\nscc = strongly_connected_components(g);\nM[Int[m[i] for i in reduce(vcat, scc) if m[i] isa Int], Int[i for i in reduce(vcat, scc) if m[i] isa Int]]\nfor c in scc\n    length(c) > 1 || continue\n    B = M[Int[m[i] for i in c if m[i] isa Int], Int[i for i in c if m[i] isa Int]]\n    display(B)\nend","category":"page"},{"location":"lectures/lecture8/","page":"Dummy Derivatives and Reordering of Equations","title":"Dummy Derivatives and Reordering of Equations","text":"using ModelingToolkit, OrdinaryDiffEq, Plots\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@parameters g\n@variables x1(t) x2(t) y1(t) y2(t) λ1(t) λ2(t) θ1(t) [state_priority = 10] θ2(t) [state_priority = 10]\neqs = [\n       D(D(x1)) ~ λ1 * x1,\n       D(D(y1)) ~ λ1 * y1 - g,\n       x1 ~ cos(θ1),\n       y1 ~ sin(θ1),\n       D(D(x2)) ~ λ2 * x2,\n       D(D(y2)) ~ λ2 * y2 - g,\n       x2 ~ x1 + cos(θ2),\n       y2 ~ y1 + sin(θ2),\n      ]\n\n@named pend = ODESystem(eqs,t)\npend = complete(pend)\nss = structural_simplify(pend)\nprob_ir = ODEProblem(ss,\n    [\n     ModelingToolkit.missing_variable_defaults(ss);\n     θ1 => 0\n     θ2 => 0\n     D(θ1) => 0.0\n     D(θ2) => 0.0\n     λ1 => 0\n     λ2 => 0\n    ],\n    (0.0, 25.0), [g => 1])\nsol = solve(prob_ir, Rodas5P())\nplot(sol, idxs = (x1, y1))\nplot!(sol, idxs = (x2, y2), xlab = \"x\", ylab = \"y\", aspect_ratio=1, dpi=400)\nnframes = ceil(Int, sol.t[end]*20)\nts = range(0, sol.t[end], length=nframes)\nfps = 20\nlet (x1s, y1s, x2s, y2s) = [Float64[] for _ in 1:4]\n    loop_pend = @time @animate for t in ts\n        nnn = sol(t, idxs=[x1, y1, x2, y2])\n        push!(x1s, nnn[1])\n        push!(y1s, nnn[2])\n        push!(x2s, nnn[3])\n        push!(y2s, nnn[4])\n        x1s = x1s[max(1, end-100):end]\n        y1s = y1s[max(1, end-100):end]\n        x2s = x2s[max(1, end-100):end]\n        y2s = y2s[max(1, end-100):end]\n        n = length(x1s)\n        plot([0, x1s[end]], [0, y1s[end]], linewidth = 3, color=:black)\n        plot!([x1s[end], x2s[end]], [y1s[end], y2s[end]], linewidth = 3, color=:black)\n        linewidth = 10\n        seriesalpha = 1\n        if n != 1\n            linewidth = range(0, linewidth, length = n)\n            seriesalpha = range(0, seriesalpha, length = n)\n        end\n        plot!(x1s, y1s; linewidth, seriesalpha)\n        linewidth = 10\n        if n != 1\n            linewidth = range(0, linewidth, length = n)\n        end\n        plot!(x2s, y2s; linewidth, seriesalpha,\n              dpi = 400, aspect_ratio = 1,\n              xlims = (-2.3, 2.3), ylims = (-2.3, 1),\n              axis=false, leg = false, grid=false)\n    end every 5\n    @time mp4(loop_pend, \"double_pendulum.mp4\"; fps)\nend","category":"page"},{"location":"lectures/lecture1/#Introduction-to-acausal-modeling-for-physical-systems-with-ModelingToolkit.jl","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"","category":"section"},{"location":"lectures/lecture1/#Background","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Background","text":"","category":"section"},{"location":"lectures/lecture1/#Modeling-Tools-Reference","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Modeling Tools Reference","text":"","category":"section"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"The following list is a reference of the tools used for building advanced models in Julia:","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"ForwardDiff.jl\nDifferentialEquations.jl\nSymbolics.jl\nModelingToolkit.jl\nModelingToolkitStandardLibrary.jl","category":"page"},{"location":"lectures/lecture1/#Julia","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Julia","text":"","category":"section"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"This course will use Julia as the fundamental tool to solve numerical problems.  ModelingToolkit.jl is a package written in pure Julia and leverages the fundamental technologies of symbolic math from Symbolics.jl, numerical solvers from DifferentialEquations.jl, and automatic differentiation from ForwardDiff.jl.  To demonstrate an introduction to these technologeies, lets focus on one of the most fundamental engineering problems: the mass-spring-damper.  For now, let's leave the mass out of the system to avoid the 2nd derivative term and assume a non-linear spring (k cdot x^15)","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"(Image: )","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"This system can be represented by the ordinary differential equation (ODE):","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"d cdot dotx + k cdot x^15 = F","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"To solve this in Julia we can apply finite differencing dotx_i = fracx_i - x_i-1Delta t and Newton's method.  Here we solve for the first time step...","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"using ForwardDiff\nusing Plots\n\nd=1      # damping coefficient [N/(m/s)]\nk=1000   # spring stiffness [N/m]\nΔt=1e-3  # time step [s]\nF = 100  # input force [N]\n\nfunction f(xᵢ, xᵢ₋₁)\n\n    ẋᵢ = (xᵢ - xᵢ₋₁)/Δt     # finite difference derivative\n    lhs = d*ẋᵢ + k*xᵢ^1.5   # lhs --> left hand side\n    rhs = F                 # rhs --> right hand side\n\n    return lhs - rhs     # equation --> lhs = rhs, residual --> 0 = lhs - rhs\nend\n\n# Newton's Method\n# first time step (i=2)\nxᵢ₋₁ = 0.0\nxᵢ = xᵢ₋₁ #<-- guess\ng(xᵢ) = f(xᵢ, xᵢ₋₁)  # g(xᵢ) turns f(xᵢ, xᵢ₋₁) into a function of only xᵢ\n# Run Newton Iterations\nxᵢ -= g(xᵢ)/ForwardDiff.derivative(g, xᵢ) # iteration 1\nxᵢ -= g(xᵢ)/ForwardDiff.derivative(g, xᵢ) # iteration 2\nxᵢ -= g(xᵢ)/ForwardDiff.derivative(g, xᵢ) # iteration 3","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"note: about derivatives\nWe can get the derivative for f from automatic differentiation using ForwardDiff.derivative (or using ForwardDiff.jacobian for a system of equations).","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"To solve for a series of time steps, we can simply update x and run again for each time step Δt.  This is a simple form of the Implicit/Backwards Euler method.","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"tol = 1e-3\nx = zeros(10)\nfor i=2:10\n    g(xᵢ) = f(xᵢ, x[i-1])\n    Δx = Inf\n    while abs(Δx) > tol\n        Δx = g(x[i])/ForwardDiff.derivative(g, x[i]) \n        x[i] -= Δx\n    end\nend\n\nplot(x; ylabel=\"x [m]\", xlabel=\"time step\")","category":"page"},{"location":"lectures/lecture1/#DifferentialEquations.jl","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"DifferentialEquations.jl","text":"","category":"section"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"For this simple problem it's easy enough to implement the Newton method and solve directly, however it's possible to instead use the solvers from DifferentialEquations.jl.  To do this, we simply need to defined a NonlinearProblem by supplying the function f of the form f(up) where:","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"u is the variables (scalar or vector)\np is the parameters (scalar or vector)","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"In this case u and p correspond to xᵢ and xᵢ₋₁, respectively.  This is referred to as the \"out-of-place\" form, where each call to f allocates, it is also possible to define f(duup) as \"in-place\" form that gives du as a pre-allocated memory space to mutate.  ","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Then we can solve by specifying the method, in this case we specify NewtonRaphson to implement Newton's method.","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"using DifferentialEquations\n\np  = xᵢ₋₁ = 0.0 # initial condition if i=2, x[1]=0 \nu0 = xᵢ = xᵢ₋₁  # guess value for x[i]\n\nprob = NonlinearProblem(f, u0, p)\nsol=solve(prob, NewtonRaphson(); abstol=tol)","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Note:  we get exactly the same result for the first time step.","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"To solve for a series of time steps, we can now use the remake function to update the initial guess u0 and parameter p and generate an updated NonlinearProblem efficiently (i.e. with minimal allocations).","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"x = zeros(10)\nfor i=2:10\n    prob′ = remake(prob; u0=x[i], p=x[i-1])\n    sol = solve(prob′, NewtonRaphson(); abstol=tol)\n    x[i] = sol[]\nend\nplot(x; ylabel=\"x [m]\", xlabel=\"time step\")","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"This approach requires the use of finite differencing and building a solution vector of solves for each time step, which was done only for demonstration purposes.  Since this problem is an ODE, it can and should be solved directly with an ODE solver.  To do this with DifferentialEquations.jl, we simply re-arrange the equation to solve explicitly for the derivative of x, giving the form fracpartial upartial t = f(upt).  In this case we have","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"dotx= fracF - k cdot x^15d","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"function du_dt(u,p,t)\n    F, k, d = p\n    x = u\n    return (F - k*x^1.5)/d\nend\nu0 = 0.0            # initial value for x\np = [F, k, d]       # parameters\ntspan = (0.0, 0.01) # solution time span\nprob = ODEProblem(du_dt, u0, tspan, p) \nsol = solve(prob)\nplot(sol; xlabel=\"time [s]\", ylabel=\"x [m]\")","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"In some cases, it may not be so easy to rearrange the equations in such a way to provide an ODE form.  We can also solve the problem in another way: Differential Algebraic Equations (DAE) form.  Here we have a mix of differential and algebraic equations.  A mass matrix is used to specify which equations are differential vs. algebraic.  Note that we are now solving for both x and dotx and therefore need to supply initial conditions for each.  To satisfy the system at time 0 with x=0, we can see that dotx = fracFd.  ","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"note: about initial conditions\nTechnically the initial condition u0 can be either a guess or explicit.  By default it is treated as a guess value and an algorithm is used to solve for a u0 that satisfies the system at the initial time.  See the documentation for the initializealg keyword for more information.","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"function du_dt(u,p,t)\n    F, k, d = p\n    x, ẋ = u\n    \n    eqs = [\n        ẋ                       # D(x) = ẋ\n        (d*ẋ + k*x^1.5) - (F)   #    0 = ( lhs ) - ( rhs )\n    ]\n\n    return eqs\nend\n\nfmm = ODEFunction(du_dt; mass_matrix=[1 0; 0 0])\nu0 = [0.0, F/d] # initial value for x,ẋ\nprob = ODEProblem(fmm, u0, tspan, p)\nsol = solve(prob)\nplot(sol; idxs=1, xlabel=\"time [s]\", ylabel=\"x [m]\")","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Now, maybe we would like to know the 2nd derivative of x.  It should be easy enough to simply provide this in our function and solve.","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"function du_dt(u,p,t)\n    F, k, d = p\n    x, ẋ, ẍ = u\n    \n    eqs = [\n        ẋ                       # D(x) = ẋ\n        ẍ                       # D(ẋ) = ẍ\n        (d*ẋ + k*(x^1.5)) - (F)   #    0 = ( lhs ) - ( rhs )\n    ]\n\n    return eqs\nend\n\nfmm = ODEFunction(du_dt; mass_matrix=[1 0 0;0 1 0;0 0 0])\nu0 = [0.0, F/d, 0.0] # initial value for x, ẋ, ẍ\nprob = ODEProblem(fmm, u0, tspan, p)\nsol = solve(prob);\nsol.retcode","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Now we get a DtLessThanMin code, meaning the solver failed to converge.  The reason for this is an index problem, our algebraic constraint equation does not use the 2nd derivative term ddotx.  To solve index problems, the algrebraic constraints must be differentiated until they contain the highest order terms.  This can be done as an exercise, however, this provides a perfect segue to the tool that can make all this easier and automatic: ModelingToolkit.jl","category":"page"},{"location":"lectures/lecture1/#ModelingToolkit.jl","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"ModelingToolkit.jl","text":"","category":"section"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"ModelingToolkit.jl uses symbolic math from Symbolics.jl to provide automatic index reduction and problem simplification to provide the optimal form for a numerical solver.  To define the same problem attempted previously in ModelingToolkit.jl, we first specify an independent variable t and it's differential operator","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nnothing # hide","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"note: about Symbolics\nNote that t is now a symbolic term.  Writing sin(t) does not compute anything, it simply represents the function symbolically.  Writing D(sin(t)) then represents the derivative of sin(t) with respect to t.  To compute the derivative, we can use the function expand_derivativesD(sin(t)) |> expand_derivatives","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"To assemble a problem symbolically for ModelingToolkit.jl, we can define our variables and equations like","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"pars = @parameters F=100 d=1 k=1000\nvars = @variables x(t)=0.0 ẋ(t)=F/d ẍ(t)=0.0\neqs = [\n    D(x) ~ ẋ\n    D(ẋ) ~ ẍ\n    d*ẋ + k*x^1.5 ~ F\n]\nnothing # hide","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Note the variables are defined as a function of the independent variable t and given initial conditions which are captured in the variable vars.  The equations are then defined using the tilde ~ operator, which represents the equation equality.  This information is then fed to an ODESystem constructor and simplified using the structural_simplify function.  ","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"@mtkbuild odesys = ODESystem(eqs, t, vars, pars)","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"As can be seen, the 3 equation system is simplified down to 1 equation.  To see the solved states and equations we can use the respective functions","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"unknowns(odesys)","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Now we are solving for only x(t) with the equation:","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"equations(odesys)","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"This seems correct, but what is ẋ(t)?  This variable has been moved to the observables of the system, which are terms which can be computed algebraicly.","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"observed(odesys)","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Notice how the 2nd derivative term ẍ(t) has been automatically determined from the symbolic derivative of ẋ(t).","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"We can now assembly a problem and solve it.  The initial conditions do not need to be supplied here because the sys contains the variable defaults from vars.  The solution object sol can now be indexed symbolically from any symbol of the system regardless if it's a solved variable, observable, or even a parameter.  This way, if for example doing a batch of simulations, each respective solution object can easily retrieve all respective information about the simulation.","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"u0 = [] # <-- used to override defaults of ODESystem variables\np = [] # <-- used to override defaults of ODESystem parameters\nprob = ODEProblem(odesys, u0, tspan, p)\nsol = solve(prob; abstol=tol)\nplot(sol; idxs=ẍ, xlabel=\"time [s]\", ylabel=\"ẍ [m/s^2]\")","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Using ModelingToolkit.jl, the solution can also be indexed by expression, for example plotting the damping and spring force components can be done as so","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"plot(sol; idxs=x^1.5*k, xlabel=\"time [s]\", ylabel=\"force [N]\")\nplot!(sol; idxs=ẋ*d)","category":"page"},{"location":"lectures/lecture1/#Acausal-Component-Based-Modeling","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Acausal - Component Based Modeling","text":"","category":"section"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"ModelingToolkit.jl enables the application of Physical Network Acausal modeling, which is a type of modeling which is component based allowing one to build models by assembling parts together from a library.  The key to how this works is thru a simple rule of how components are connected.  A connection must define at minimum 2 variables (through and across see about connectors for a deeper explanation) which follows the rules:","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"connections can only be made by like connectors (i.e. same pairs of through and across variables from the same physical domain)\nthrough variables sum to zero at connection points\nacross variables are equal at connection points","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Consider a simple mechanical translational system of a mass and damper.  In this domain the through variable is force (f) and the across velocity (v).  We can define the mass component as","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"f_mass = m_mass cdot dotv_mass","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"And the damper component as","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"f_damper = d_damper cdot v_damper","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Based on the rules above, connecting these 2 components together would give the following additional equations","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"beginaligned \n    0 = f_mass + f_damper  \n    v_mass = v_damper \nendaligned  ","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"With simple substitution it can be seen that this gives the expected mass-damper system","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"m cdot dotv + d cdot v = 0","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Let's try this again by defining this system in ModelingToolkit.jl","category":"page"},{"location":"lectures/lecture1/#Connections","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Connections","text":"","category":"section"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"To define a connection in ModelingToolkit.jl we use the @connector macro and specify the through variable with connect = Flow","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"@connector MechanicalPort begin\n    v(t)\n    f(t), [connect = Flow]\nend\nnothing # hide","category":"page"},{"location":"lectures/lecture1/#Components","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Components","text":"","category":"section"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"To define a component, we use the @mtkmodel macro and define it's parameters, variables, connection ports, and equations.  The mass component can be defined as","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"@mtkmodel Mass begin\n    @parameters begin\n        m = 10\n    end\n    @variables begin\n        v(t)\n        f(t)\n    end\n    @components begin\n        port = MechanicalPort()\n    end\n    @equations begin\n        # connectors\n        port.v ~ v\n        port.f ~ f\n        \n        # physics\n        f ~ m*D(v)\n    end\nend\nnothing # hide","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Now there are 2 tricky issues when defining models at the component level.  First is the number of equations.  How can you know if you've properly defined a base component without having the remaining parts to close the system and ensure you have a matching set of variables and equations?  A general rule of thumb is that a base level component should have an equation number that matches the number of variables + connectors.  The Mass component has 2 variables and 1 connector and therefore 3 equations.","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"The 2nd tricky issue is signs.  To determine this one can draw a diagram like below.  Below the port draw the across variable from left to right (positive) direction.  Then draw the through variable entering the component.  If the arrows point in the same direction, the connection port through variable assignment is positive, if opposing, then the sign should be negative.  ","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"(Image: mass)","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Similarly the damper component is defined as below.  ","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"@mtkmodel Damper begin\n    @parameters begin\n        d = 1\n    end\n    @variables begin\n        v(t)\n        f(t)\n    end\n    @components begin\n        port = MechanicalPort()\n    end\n    @equations begin\n        # connectors\n        port.v ~ v\n        port.f ~ f\n        \n        # physics\n        f ~ d*v\n    end\nend\nnothing # hide","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"(Image: single port damper)","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Now the Mass and Damper components can be assembled in a system and connected together (note: the connect equation).  Also note the parameters v, m, and d are defined to expose the properties which can be set as keyword arguments of the same name.  ","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"@mtkmodel System begin\n    @parameters begin\n        v\n        m\n        d\n    end\n    @components begin\n        mass = Mass(;v,m)\n        damper = Damper(;v,d)\n    end\n    @equations begin\n        connect(mass.port, damper.port)\n    end\nend\n\n@mtkbuild sys = System(;v=100, m=5, d=3)\nfull_equations(sys)","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"As can be seen we arrive at the same equation as derived previously.  Now it would be easy to define a system that adds a spring, or has a series of connected masses, springs, dampers, etc.  ","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"The Damper component created previously was a little incomplete because it only had one port.  In reality a damper or spring will be connected between 2 objects, for example the car frame and the wheel.  Therefore a proper component will define 2 ports so that the component can be as analogous with real life as possible.  In the example below the component is defined properly with 2 ports.  Note the velocity of the component v is defined as a relative velocity between the 2 ports.  It's easy to understand how this works if it's assumed that port_b is connected to a stationary reference frame.","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"@mtkmodel Damper begin\n    @parameters begin\n        d = 1\n    end\n    @variables begin\n        v(t)\n        f(t)\n    end\n    @components begin\n        port_a = MechanicalPort()\n        port_b = MechanicalPort()\n    end\n    @equations begin\n        # connectors\n        (port_a.v - port_b.v) ~ v\n        port_a.f ~ +f\n        port_b.f ~ -f\n        \n        # physics\n        f ~ d*v\n    end\nend\nnothing # hide","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Note the force is drawn now as entering the component on both sides.  For port a the directions align, but for port b the directions are opposing, requiring a sign change: port_b.f ~ -f","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"(Image: damper)","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Now we can do the same for the spring component.  Note that the spring is of course very similar to the damper, but now we need a relative position.  This can be obtained by integrating the port velocities, but how do we integrate in ModelingToolkit.jl?  We want to write the equation","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"x = int v space partial t","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"But we know that this is also true","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"fracpartial xpartial t = v","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"In ModelingToolkit therefore we can \"integrate\" by moving the differential to the appropriate side of the equation.","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"@mtkmodel Spring begin\n    @parameters begin\n        k = 100\n    end\n    @variables begin\n        x(t)\n        v(t)\n        f(t)\n    end\n    @components begin\n        port_a = MechanicalPort()\n        port_b = MechanicalPort()\n    end\n    @equations begin\n        # derivatives\n        D(x) ~ v\n\n        # connectors\n        (port_a.v - port_b.v) ~ v\n        port_a.f ~ +f\n        port_b.f ~ -f\n        \n        # physics\n        f ~ k*x\n    end\nend\nnothing # hide","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"(Image: spring)","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"One thing to consider now in the Spring component is the meaning of the spring stretch/compression variable x.  What does it mean if this variable is positive or negative?  It's important to note when reviewing the model output that a positive x means the spring is compressed and vise versa for a negative x.","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Now, if we want to create a full mass-spring-damper system with our new Damper and Spring components, we need to create some boundary conditions, such as a stationary reference and an input force.  Creating a stationary reference in acausal modeling is a bit tricky.  We know that the velocity should be set to zero, as it's stationary.  But what should the force be?  Thinking about Newton's principles, every force on a non-moving object is met with an equal but opposite force.  Therefore we add a variable f to represent this force, which will be part of the solved system solution. ","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"@mtkmodel Reference begin\n    @parameters begin\n        \n    end\n    @variables begin\n        f(t)\n    end\n    @components begin\n        port = MechanicalPort(;f,v=0)\n    end\n    @equations begin\n        # connectors\n        port.v ~ 0\n        port.f ~ -f\n    end\nend\nnothing # hide","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Note the sign convention port.f ~ -f.  This is maybe not expected.  To understand why a negative is needed here is because this component is different from the others, there is no physics involved.  The component is instead only a boundary condition, therefore force should be leaving the component rather than entering.","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"(Image: reference)","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Finally, considering an input force, we can imagine this to be an invisible hand that pushes with a constant force.  This invisible hand will move with the port with velocity v.  We don't know this velocity, it's a variable that will part of the solved system solution.  ","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"@mtkmodel ConstantForce begin\n    @parameters begin\n        f\n    end\n    @variables begin\n        v(t)\n    end\n    @components begin\n        port = MechanicalPort()\n    end\n    @equations begin\n        # connectors\n        port.v ~ v\n        port.f ~ -f  \n    end\nend\nnothing # hide","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"As with the Reference component, the force is a boundary condition and is leaving the component rather than entering, giving the sign convention port.f ~ -f.","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"(Image: force input)","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Now let's assemble a mass-spring-damper system with the full collection of components.","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"@mtkmodel System begin\n    @parameters begin\n        v=0\n        x=0\n        m=100\n        d=10\n        k=1000\n        f=1\n    end\n    @components begin\n        mass = Mass(;v,m)\n        damper = Damper(;v, d)\n        spring = Spring(;v, k, x)\n        ref = Reference()\n        force = ConstantForce(;v,f)\n    end\n    @equations begin\n        connect(mass.port, damper.port_a, spring.port_a, force.port)\n        connect(damper.port_b, spring.port_b, ref.port)\n    end\nend\n\n@mtkbuild sys = System()\nprob = ODEProblem(sys, [], (0, 10))\nsol = solve(prob)\nplot(sol)","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"There's a couple things we can do now to ensure the system is correct.  First, we can look at the equations.","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"full_equations(sys)","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"The first equation (after re-aranging) it can be seen is the classic mass-spring-damper equation.","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"m cdot ddotx + d cdot dotx + k cdot x = f","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"This way we know all the signs and equations are set correctly.  Let's also check the Reference component sign, which should give an equal but opposite force to the system connected to it.","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"plot(sol; idxs=sys.ref.f)\nplot!(sol; idxs=sys.spring.f + sys.damper.f)","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Additionally it's easy enough in this case to re-construct the problem directly and solve to check the result.","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"vars = @variables x(t)=0 dx(t)=0 ddx(t)=0\npars = @parameters m=100 d=10 k=1000 F=1\neqs = [\n    D(x) ~ dx\n    D(dx) ~ ddx\n    m*ddx + d*dx + k*x ~ F\n]\n@mtkbuild odesys = ODESystem(eqs, t, vars, pars)\nprob = ODEProblem(odesys, [], (0,10))\nsol = solve(prob)\nplot(sol)","category":"page"},{"location":"lectures/lecture1/#Systems-and-Sub-Systems","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Systems and Sub-Systems","text":"","category":"section"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Acausal modeling allows for an \"object-oriented\" like system that can organize models with hierarchy.  Let's say for example we want to make a part that is a collection of the mass, spring, damper into a single system.  The MassSpringDamper component below shows how this is possible.  As can be seen, this is nearly the same system we generated previously, except no boundary conditions are given, instead 2 MechanicalPort's are added and connected to the component parts.  These connection points are now exposed and can be connected to other components.","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"@mtkmodel MassSpringDamper begin\n    @parameters begin\n        m\n        k\n        d\n        v\n        x\n    end\n    @components begin\n        port_a = MechanicalPort()\n        port_b = MechanicalPort()\n        mass = Mass(;m,v)\n        damper = Damper(;d,v)\n        spring = Spring(;k,v,x)\n    end\n    @equations begin\n        connect(mass.port, damper.port_a, spring.port_a, port_a)\n        connect(damper.port_b, spring.port_b, port_b)\n    end\nend\nnothing # hide","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"As an example, the MassSpringDamper component can be connected in series to make a complex system.  One can imagine then how this enables easy construction of complex models that can be quickly modified, extremely useful for the application of model based design.  ","category":"page"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"@mtkmodel System begin\n    @parameters begin\n        v = 0\n        x = 0\n    end\n    @components begin\n        msd1 = MassSpringDamper(;m = 10, d = 1, k = 1000, v, x)\n        msd2 = MassSpringDamper(;m = 20, d = 2, k = 2000, v, x)\n        msd3 = MassSpringDamper(;m = 30, d = 3, k = 3000, v, x)\n        ref = Reference()\n        force = ConstantForce(;f=1,v=0)\n    end\n    @equations begin\n        connect(force.port, msd1.port_a)\n        connect(msd1.port_b, msd2.port_a)\n        connect(msd2.port_b, msd3.port_a)\n        connect(msd3.port_b, ref.port)\n    end\nend\n\n@mtkbuild sys = System()\nprob = ODEProblem(sys, [], (0, 2))\nsol = solve(prob)\nplot(sol; idxs=[sys.msd1.spring.x, sys.msd2.spring.x, sys.msd3.spring.x])","category":"page"},{"location":"lectures/lecture1/#Practice-Exercise","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Practice Exercise","text":"","category":"section"},{"location":"lectures/lecture1/","page":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"The current solution shows how the springs are compressed.  How can the model be updated to show the absolute positions of the springs?  For example, if each spring starts at an unstreched length of 10mm, connected together they will form a collection of 30mm with masses inbetween.  Update the model to show the absolute position of each mass in time.","category":"page"}]
}
